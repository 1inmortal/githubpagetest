#!/usr/bin/env node

/**
 * Auditor√≠a de Seguridad - Vulnerabilidad CVE-2025-7783 en form-data
 * 
 * Este script analiza las dependencias del proyecto para identificar
 * versiones vulnerables de form-data (< 3.0.4) y genera un reporte
 * detallado de la auditor√≠a.
 */

const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class FormDataVulnerabilityAuditor {
    constructor() {
        this.vulnerableVersions = [];
        this.projectRoot = process.cwd();
        this.report = {
            timestamp: new Date().toISOString(),
            vulnerability: 'CVE-2025-7783',
            description: 'Vulnerabilidad de inyecci√≥n de boundary en form-data',
            affectedVersions: '< 3.0.4',
            safeVersion: '^3.0.4',
            findings: [],
            recommendations: []
        };
    }

    /**
     * Buscar archivos package.json en el proyecto
     */
    findPackageFiles() {
        const packageFiles = [];
        
        function searchRecursively(dir) {
            const items = fs.readdirSync(dir, { withFileTypes: true });
            
            for (const item of items) {
                const fullPath = path.join(dir, item.name);
                
                if (item.isDirectory() && !item.name.startsWith('.') && item.name !== 'node_modules') {
                    searchRecursively(fullPath);
                } else if (item.name === 'package.json') {
                    packageFiles.push(fullPath);
                }
            }
        }
        
        searchRecursively(this.projectRoot);
        return packageFiles;
    }

    /**
     * Analizar un archivo package.json
     */
    analyzePackageFile(packagePath) {
        try {
            const packageData = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
            const lockPath = packagePath.replace('package.json', 'package-lock.json');
            const yarnLockPath = packagePath.replace('package.json', 'yarn.lock');
            
            const analysis = {
                path: packagePath,
                name: packageData.name || 'unknown',
                version: packageData.version || 'unknown',
                hasFormData: false,
                formDataVersion: null,
                vulnerable: false,
                lockFileExists: false,
                lockFileType: null
            };

            // Verificar dependencias directas
            const allDependencies = {
                ...packageData.dependencies,
                ...packageData.devDependencies,
                ...packageData.peerDependencies
            };

            if (allDependencies['form-data']) {
                analysis.hasFormData = true;
                analysis.formDataVersion = allDependencies['form-data'];
                analysis.vulnerable = this.isVersionVulnerable(allDependencies['form-data']);
            }

            // Verificar archivos de lock
            if (fs.existsSync(lockPath)) {
                analysis.lockFileExists = true;
                analysis.lockFileType = 'npm';
                this.analyzeLockFile(lockPath, analysis);
            } else if (fs.existsSync(yarnLockPath)) {
                analysis.lockFileExists = true;
                analysis.lockFileType = 'yarn';
                this.analyzeYarnLockFile(yarnLockPath, analysis);
            }

            return analysis;
        } catch (error) {
            console.error(`Error analizando ${packagePath}:`, error.message);
            return null;
        }
    }

    /**
     * Verificar si una versi√≥n es vulnerable
     */
    isVersionVulnerable(version) {
        if (!version) return false;
        
        // Remover caracteres de rango
        const cleanVersion = version.replace(/[\^~>=<]/g, '');
        
        // Comparar versiones
        const parts = cleanVersion.split('.').map(Number);
        const major = parts[0] || 0;
        const minor = parts[1] || 0;
        const patch = parts[2] || 0;
        
        return major < 3 || (major === 3 && minor === 0 && patch < 4);
    }

    /**
     * Analizar package-lock.json
     */
    analyzeLockFile(lockPath, analysis) {
        try {
            const lockData = JSON.parse(fs.readFileSync(lockPath, 'utf8'));
            
            // Buscar form-data en las dependencias
            if (lockData.dependencies) {
                this.searchFormDataInDependencies(lockData.dependencies, analysis);
            }
        } catch (error) {
            console.error(`Error analizando lock file ${lockPath}:`, error.message);
        }
    }

    /**
     * Analizar yarn.lock
     */
    analyzeYarnLockFile(yarnLockPath, analysis) {
        try {
            const yarnLockContent = fs.readFileSync(yarnLockPath, 'utf8');
            
            // Buscar entradas de form-data en yarn.lock
            const formDataRegex = /form-data@[^:]+:\s*version\s*"([^"]+)"/g;
            let match;
            
            while ((match = formDataRegex.exec(yarnLockContent)) !== null) {
                const version = match[1];
                if (this.isVersionVulnerable(version)) {
                    analysis.vulnerable = true;
                    analysis.formDataVersion = version;
                    break;
                }
            }
        } catch (error) {
            console.error(`Error analizando yarn.lock ${yarnLockPath}:`, error.message);
        }
    }

    /**
     * Buscar form-data en dependencias anidadas
     */
    searchFormDataInDependencies(dependencies, analysis) {
        for (const [name, dep] of Object.entries(dependencies)) {
            if (name === 'form-data') {
                const version = dep.version;
                if (this.isVersionVulnerable(version)) {
                    analysis.vulnerable = true;
                    analysis.formDataVersion = version;
                    break;
                }
            }
            
            // Buscar en dependencias anidadas
            if (dep.dependencies) {
                this.searchFormDataInDependencies(dep.dependencies, analysis);
            }
        }
    }

    /**
     * Buscar uso de FormData en c√≥digo fuente
     */
    searchFormDataUsage() {
        const jsFiles = [];
        
        function findJSFiles(dir) {
            const items = fs.readdirSync(dir, { withFileTypes: true });
            
            for (const item of items) {
                const fullPath = path.join(dir, item.name);
                
                if (item.isDirectory() && !item.name.startsWith('.') && item.name !== 'node_modules') {
                    findJSFiles(fullPath);
                } else if (item.name.endsWith('.js') || item.name.endsWith('.ts') || item.name.endsWith('.jsx')) {
                    jsFiles.push(fullPath);
                }
            }
        }
        
        findJSFiles(this.projectRoot);
        
        const findings = [];
        
        for (const file of jsFiles) {
            try {
                const content = fs.readFileSync(file, 'utf8');
                
                // Buscar patrones de uso de FormData
                const patterns = [
                    { regex: /new\s+FormData\s*\(/g, description: 'Constructor FormData' },
                    { regex: /form-data/g, description: 'Importaci√≥n de form-data' },
                    { regex: /Math\.random\(\)/g, description: 'Uso de Math.random() para boundary' },
                    { regex: /boundary\s*=/g, description: 'Asignaci√≥n de boundary' }
                ];
                
                for (const pattern of patterns) {
                    const matches = content.match(pattern.regex);
                    if (matches) {
                        findings.push({
                            file: path.relative(this.projectRoot, file),
                            pattern: pattern.description,
                            count: matches.length,
                            lines: this.findLineNumbers(content, pattern.regex)
                        });
                    }
                }
            } catch (error) {
                console.error(`Error analizando ${file}:`, error.message);
            }
        }
        
        return findings;
    }

    /**
     * Encontrar n√∫meros de l√≠nea para un patr√≥n
     */
    findLineNumbers(content, regex) {
        const lines = content.split('\n');
        const lineNumbers = [];
        
        for (let i = 0; i < lines.length; i++) {
            if (regex.test(lines[i])) {
                lineNumbers.push(i + 1);
            }
        }
        
        return lineNumbers;
    }

    /**
     * Ejecutar auditor√≠a completa
     */
    async runAudit() {
        console.log('üîç Iniciando auditor√≠a de vulnerabilidad CVE-2025-7783...\n');
        
        // 1. Buscar archivos package.json
        const packageFiles = this.findPackageFiles();
        console.log(`üì¶ Encontrados ${packageFiles.length} archivos package.json`);
        
        // 2. Analizar cada package.json
        const analyses = [];
        for (const packageFile of packageFiles) {
            const analysis = this.analyzePackageFile(packageFile);
            if (analysis) {
                analyses.push(analysis);
                
                if (analysis.vulnerable) {
                    console.log(`‚ö†Ô∏è  VULNERABLE: ${analysis.name} (${analysis.path})`);
                    console.log(`   Versi√≥n: ${analysis.formDataVersion}`);
                }
            }
        }
        
        // 3. Buscar uso de FormData en c√≥digo
        console.log('\nüîç Buscando uso de FormData en c√≥digo fuente...');
        const codeFindings = this.searchFormDataUsage();
        
        // 4. Generar reporte
        this.report.findings = {
            packages: analyses,
            codeUsage: codeFindings
        };
        
        // 5. Generar recomendaciones
        this.generateRecommendations(analyses, codeFindings);
        
        // 6. Guardar reporte
        this.saveReport();
        
        return this.report;
    }

    /**
     * Generar recomendaciones
     */
    generateRecommendations(analyses, codeFindings) {
        const vulnerablePackages = analyses.filter(a => a.vulnerable);
        const hasFormDataUsage = codeFindings.length > 0;
        
        this.report.recommendations = [
            {
                priority: 'HIGH',
                action: 'Actualizar dependencias',
                description: 'Actualizar form-data a versi√≥n ^3.0.4 o superior',
                packages: vulnerablePackages.map(p => p.name)
            }
        ];
        
        if (hasFormDataUsage) {
            this.report.recommendations.push({
                priority: 'MEDIUM',
                action: 'Refactorizar c√≥digo',
                description: 'Reemplazar generaci√≥n de boundary basada en Math.random()',
                details: 'Usar crypto.randomBytes() para generar boundary seguro'
            });
        }
        
        this.report.recommendations.push({
            priority: 'LOW',
            action: 'Agregar tests de seguridad',
            description: 'Implementar tests para validar boundary generation',
            details: 'Crear tests que simulen ataques de inyecci√≥n de boundary'
        });
    }

    /**
     * Guardar reporte
     */
    saveReport() {
        const reportPath = path.join(this.projectRoot, 'security-audit-report.json');
        fs.writeFileSync(reportPath, JSON.stringify(this.report, null, 2));
        
        console.log(`\nüìÑ Reporte guardado en: ${reportPath}`);
        
        // Generar reporte en formato texto
        this.generateTextReport();
    }

    /**
     * Generar reporte en formato texto
     */
    generateTextReport() {
        const textReport = this.formatTextReport();
        const textPath = path.join(this.projectRoot, 'security-audit-report.txt');
        fs.writeFileSync(textPath, textReport);
        
        console.log(`üìÑ Reporte de texto guardado en: ${textPath}`);
    }

    /**
     * Formatear reporte en texto
     */
    formatTextReport() {
        let report = `AUDITOR√çA DE SEGURIDAD - CVE-2025-7783
==================================================
Fecha: ${this.report.timestamp}
Vulnerabilidad: ${this.report.vulnerability}
Descripci√≥n: ${this.report.description}

VERSIONES AFECTADAS
===================
Versiones vulnerables: ${this.report.affectedVersions}
Versi√≥n segura: ${this.report.safeVersion}

HALLAZGOS
==========

Paquetes Analizados:
`;

        for (const pkg of this.report.findings.packages) {
            report += `\n- ${pkg.name} (${pkg.path})
  Versi√≥n: ${pkg.formDataVersion || 'No encontrada'}
  Vulnerable: ${pkg.vulnerable ? 'S√ç' : 'NO'}
  Lock file: ${pkg.lockFileType || 'No encontrado'}`;
        }

        report += `\n\nUso en C√≥digo Fuente:
`;

        for (const finding of this.report.findings.codeUsage) {
            report += `\n- ${finding.file}
  Patr√≥n: ${finding.pattern}
  Ocurrencias: ${finding.count}
  L√≠neas: ${finding.lines.join(', ')}`;
        }

        report += `\n\nRECOMENDACIONES
===============
`;

        for (const rec of this.report.recommendations) {
            report += `\n[${rec.priority}] ${rec.action}
${rec.description}
${rec.details ? `Detalles: ${rec.details}` : ''}`;
        }

        return report;
    }
}

// Ejecutar auditor√≠a
if (require.main === module) {
    const auditor = new FormDataVulnerabilityAuditor();
    auditor.runAudit().then(report => {
        console.log('\n‚úÖ Auditor√≠a completada');
        console.log(`üìä Paquetes vulnerables: ${report.findings.packages.filter(p => p.vulnerable).length}`);
        console.log(`üîç Usos de FormData encontrados: ${report.findings.codeUsage.length}`);
    }).catch(error => {
        console.error('‚ùå Error durante la auditor√≠a:', error);
        process.exit(1);
    });
}

module.exports = FormDataVulnerabilityAuditor;
