<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Tactical OS Web Edition</title>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <!-- Libraries (CDNs) -->
    <!-- Three.js -->
    <!-- ✅ SECURITY: cdnjs.cloudflare.com y cdn.jsdelivr.net son CDNs confiables -->
    <!-- Ver docs/security/SECURITY-AUDIT-2026.md para lista completa de CDNs aprobados -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Anime.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <!-- TensorFlow.js (Base) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0"></script>
    <!-- Coco-SSD -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2"></script>
    
    <!-- NOTE: MediaPipe is now imported inside the module script below -->

    <style>
        :root {
            --primary: #00FFFF; /* Cian */
            --secondary: #00FF00; /* Verde Matrix */
            --danger: #FF0055; /* Magenta Neon */
            --bg-dark: #050505;
            --glass: rgba(0, 20, 20, 0.6);
            --glass-border: 1px solid rgba(0, 255, 255, 0.3);
            --font-main: 'Share Tech Mono', monospace;
            
            /* Responsive scaling variables */
            --hud-scale: 1;
            --panel-font-size: clamp(12px, 2vw, 16px);
            --title-font-size: clamp(14px, 2.5vw, 18px);
            --touch-btn-size: 44px;
            
            /* iPhone safe area insets (notch/gesture bars) */
            --inset-top: env(safe-area-inset-top, 0px);
            --inset-right: env(safe-area-inset-right, 0px);
            --inset-bottom: env(safe-area-inset-bottom, 0px);
            --inset-left: env(safe-area-inset-left, 0px);
            
            /* Safe area margins for panel layout */
            --safe-top: calc(var(--inset-top) + 10px);
            --safe-bottom: calc(var(--inset-bottom) + 10px);
            --safe-left: calc(var(--inset-left) + 10px);
            --safe-right: calc(var(--inset-right) + 10px);
            
            /* Panel layout variables (mobile-first) */
            --panel-width: 300px;
            --hud-padding: env(safe-area-inset-left, 10px);
            --panel-bg-mobile: rgba(5, 5, 5, 0.95);
            --panel-shadow-mobile: 0 0 5px var(--primary);
        }
        
        /* Mobile scaling */
        @media (max-width: 768px) {
            :root {
                --hud-scale: 0.7;
                --panel-font-size: 10px;
                --title-font-size: 11px;
                --touch-btn-size: 48px;
                /* Mobile safe areas (top bar + touch bar + device insets) */
                --safe-top: calc(var(--inset-top) + 60px);
                --safe-bottom: calc(var(--inset-bottom) + 100px);
            }
        }
        
        /* Mobile view class override */
        body.mobile-view {
            --safe-top: calc(var(--inset-top) + 60px);
            --safe-bottom: calc(var(--inset-bottom) + 100px);
        }
        
        @media (max-width: 480px) {
            :root {
                --hud-scale: 0.6;
                --panel-font-size: 9px;
                --title-font-size: 10px;
                --touch-btn-size: 52px;
            }
        }
        
        /* INTEL Filter Panel - Mobile Responsive */
        @media (max-width: 768px) {
            #intel-filter-panel {
                top: auto;
                bottom: 90px;
                left: 10px;
                right: auto;
                width: 180px;
                max-height: 250px;
            }
            
            #intel-filter-panel.collapsed {
                height: 32px !important;
                min-height: 32px;
            }
            
            .intel-filter-header {
                padding: 6px 10px;
            }
            
            .intel-filter-header h4 {
                font-size: 10px;
            }
            
            .intel-filter-content {
                padding: 8px;
                max-height: 200px;
            }
            
            .intel-filter-category {
                padding: 5px 6px;
                margin-bottom: 3px;
            }
            
            .filter-label {
                font-size: 9px;
            }
            
            .filter-count {
                font-size: 8px;
                padding: 1px 4px;
            }
            
            .intel-filter-actions {
                padding: 6px 8px;
                gap: 6px;
            }
            
            .intel-filter-btn {
                padding: 5px 6px;
                font-size: 8px;
            }
        }
        
        @media (max-width: 480px) {
            #intel-filter-panel {
                width: 160px;
                bottom: 100px;
            }
            
            .intel-filter-category {
                padding: 4px 5px;
            }
            
            .filter-checkbox {
                width: 14px;
                height: 14px;
                margin-right: 6px;
            }
        }

        * { box-sizing: border-box; user-select: none; }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-dark);
            color: var(--primary);
            font-family: var(--font-main);
        }

        /* --- Z-INDEX TOKENS (Unified Hierarchy) --- */
        :root {
            /* Base layers */
            --z-base: 1;
            --z-canvas2d: 2;
            --z-canvas3d: 3;
            
            /* UI layers */
            --z-ui: 10;
            --z-panels: 15;
            --z-telemetry: 20;
            --z-maps: 25;
            --z-overlays: 30;
            --z-filters: 45;
            --z-decorative: 50;
            
            /* Control layers */
            --z-controls: 99;
            --z-modal: 100;
            --z-touchbar: 100;
            --z-topbar: 100;
            --z-toggle: 101;
            --z-censorship: 9999;
        }
        
        /* --- LAYERS (Z-INDEX HIERARCHY) --- */
        /* 
         * Z-INDEX STRUCTURE (using CSS tokens):
         * Base: --z-base (1), --z-canvas2d (2), --z-canvas3d (3)
         * UI: --z-ui (10), --z-panels (15), --z-telemetry (20), --z-maps (25)
         * Overlays: --z-overlays (30), --z-filters (45), --z-decorative (50)
         * Controls: --z-controls (99), --z-modal (100), --z-touchbar (100), --z-topbar (100), --z-toggle (101)
         * Special: --z-censorship (9999)
         */
        #container { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
        
        video {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Espejo */
            z-index: var(--z-base);
            display: none; /* Hide raw video, draw to canvas */
            /* High-quality video rendering */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            filter: contrast(1.1) brightness(1.05) saturate(1.1);
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: var(--z-base);
            /* High-quality canvas rendering */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            filter: contrast(1.05) brightness(1.02);
        }

        #main-canvas {
            z-index: var(--z-canvas2d); /* 2D HUD & Video Render */
            /* Enhanced sharpness for main rendering canvas */
            image-rendering: pixelated; /* For cyber aesthetic, or use auto for smoother */
        }
        #three-canvas { z-index: var(--z-canvas3d); pointer-events: none; } /* 3D Overlay */
        
        /* --- UI OVERLAYS --- */
        #ui-layer {
            position: fixed; /* Changed from absolute to fixed for consistent positioning */
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: var(--z-ui);
            pointer-events: none;
        }
        
        /* ========== MOBILE TOP BAR ========== */
        #mobile-top-bar {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: linear-gradient(180deg, rgba(0,10,15,0.95) 0%, rgba(0,10,15,0.8) 80%, transparent 100%);
            z-index: var(--z-modal);
            padding: 5px 10px;
            box-sizing: border-box;
        }
        
        .top-bar-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 100%;
            gap: 8px;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            flex-wrap: nowrap;
        }
        
        .top-bar-container::-webkit-scrollbar {
            display: none;
        }
        
        .top-bar-btn {
            min-width: 44px;
            min-height: 44px;
            padding: 8px 12px;
            border: 1px solid var(--primary);
            border-radius: 6px;
            background: rgba(0, 20, 30, 0.9);
            color: var(--primary);
            font-family: var(--font-main);
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            white-space: nowrap;
            flex-shrink: 0;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .top-bar-btn:active {
            background: var(--primary);
            color: var(--bg-dark);
        }
        
        .top-bar-btn.active {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 10px var(--primary);
        }
        
        .top-bar-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
            flex-shrink: 0;
        }
        
        /* Mode indicator in top bar */
        #top-bar-mode {
            font-size: 12px;
            font-weight: bold;
            color: var(--danger);
            padding: 0 10px;
            text-align: center;
            min-width: 60px;
        }
        
        @media (max-width: 768px) {
            #mobile-top-bar {
                display: block;
                transition: transform 0.25s ease, opacity 0.25s ease;
                transform: translateY(0);
                opacity: 1;
            }
            
            /* Hide top bar when MORE panel is open (mobile-only) */
            body.more-modes-open #mobile-top-bar {
                transform: translateY(-110%);
                opacity: 0;
                pointer-events: none;
            }
            
            /* Hide desktop buttons on mobile */
            #fullscreen-btn,
            #mobile-btn {
                display: none !important;
            }
        }

        .panel {
            position: fixed; /* Changed from absolute to fixed for consistent HUD positioning */
            background: var(--glass);
            backdrop-filter: blur(8px);
            border: var(--glass-border);
            padding: 15px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
            color: #fff;
            transition: opacity 0.3s ease;
            pointer-events: auto;
            z-index: var(--z-panels);
        }

        .panel h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: var(--primary);
            border-bottom: 1px solid var(--primary);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .panel-content { font-size: 12px; line-height: 1.4; }

        .controls-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            flex-wrap: wrap;
            gap: 8px;
        }

        .controls-row:last-child {
            margin-bottom: 0;
        }

        .controls-row .key-badge {
            flex: 1;
            text-align: center;
            min-width: 60px;
        }

        /* Panel Tab for Toggle */
        .panel-tab {
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: 2px solid var(--glass-border);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0, 255, 255, 0.3);
            transition: all 0.3s ease;
            z-index: var(--z-maps);
        }

        .panel-tab:hover {
            transform: translateX(-50%) scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 255, 255, 0.5);
        }

        .panel-tab:active {
            transform: translateX(-50%) scale(0.95);
        }

        .panel.collapsed .panel-content,
        .panel.collapsed h3 {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
        }

        .panel.collapsed {
            height: 40px !important;
            overflow: hidden;
        }

        .panel.collapsed .panel-tab {
            top: 8px;
        }

        /* Posicionamiento de Paneles */
        #sys-panel {
            top: 20px;
            left: 20px;
            width: 300px;
            background: transparent !important;
            backdrop-filter: none !important;
        }
        #mode-panel { top: 20px; right: 20px; width: 200px; text-align: right; }
        #data-panel { bottom: 20px; left: 20px; width: 350px; }
        #latency-panel { bottom: 20px; right: 20px; width: 200px; text-align: right; }
        
        /* Loader */
        #loader {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: var(--z-modal);
        }
        
        .loader-text { font-size: 24px; animation: blink 1s infinite; color: var(--primary); }
        .loader-bar { width: 300px; height: 4px; background: #333; margin-top: 20px; }
        .loader-progress { width: 0%; height: 100%; background: var(--secondary); transition: width 0.3s; }

        /* Effects */
        .scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none; /* Don't block clicks */
            z-index: var(--z-decorative); /* Below controls */
            z-index: var(--z-telemetry); pointer-events: none; opacity: 0.3;
        }

        .glitch-active { animation: glitch-anim 0.2s infinite; }

        /* Censorship Glitch Effect */
        .censorship-glitch {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg,
                rgba(255, 0, 85, 0.9) 0%,
                rgba(0, 255, 255, 0.9) 25%,
                rgba(255, 0, 85, 0.9) 50%,
                rgba(0, 255, 255, 0.9) 75%,
                rgba(255, 0, 85, 0.9) 100%);
            background-size: 400% 400%;
            animation: censorship-glitch-bg 0.3s ease-in-out infinite alternate,
                       censorship-shake 0.1s ease-in-out infinite;
            z-index: 9998;
            pointer-events: none;
            backdrop-filter: blur(2px);
        }

        .censorship-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #FF0055;
            text-shadow:
                2px 2px 0px #000,
                -2px -2px 0px #000,
                2px -2px 0px #000,
                -2px 2px 0px #000,
                0px 0px 10px #FF0055;
            z-index: var(--z-censorship);
            pointer-events: none;
            animation: censorship-text 0.2s ease-in-out infinite alternate;
            font-family: 'Share Tech Mono', monospace;
        }

        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        @keyframes glitch-anim {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); filter: invert(1); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        @keyframes censorship-glitch-bg {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes censorship-shake {
            0%, 100% { transform: translate(0); }
            10% { transform: translate(-2px, -1px); }
            20% { transform: translate(2px, 1px); }
            30% { transform: translate(-1px, 2px); }
            40% { transform: translate(1px, -1px); }
            50% { transform: translate(-2px, 1px); }
            60% { transform: translate(2px, -2px); }
            70% { transform: translate(-1px, -1px); }
            80% { transform: translate(1px, 2px); }
            90% { transform: translate(-2px, -2px); }
        }

        @keyframes censorship-text {
            0% {
                transform: translate(-50%, -50%) scale(1);
                text-shadow: 2px 2px 0px #000, -2px -2px 0px #000, 2px -2px 0px #000, -2px 2px 0px #000, 0px 0px 10px #FF0055;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
                text-shadow: 4px 4px 0px #000, -4px -4px 0px #000, 4px -4px 0px #000, -4px 4px 0px #000, 0px 0px 20px #FF0055, 0px 0px 30px #FF0055;
            }
            100% {
                transform: translate(-50%, -50%) scale(0.9);
                text-shadow: 1px 1px 0px #000, -1px -1px 0px #000, 1px -1px 0px #000, -1px 1px 0px #000, 0px 0px 5px #FF0055;
            }
        }

        .key-badge {
            display: inline-block;
            background: rgba(0,255,255,0.2);
            padding: 2px 5px;
            margin: 2px;
            border-radius: 3px;
            font-size: 10px;
            color: var(--primary);
        }

        /* Fullscreen Button */
        #fullscreen-btn {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 15;
            background: var(--glass);
            backdrop-filter: blur(8px);
            border: var(--glass-border);
            color: var(--primary);
            font-family: var(--font-main);
            font-size: 12px;
            padding: 10px 20px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #fullscreen-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            transform: translateX(-50%) scale(1.05);
        }

        #fullscreen-btn:active {
            transform: translateX(-50%) scale(0.98);
        }

        #fullscreen-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        #fullscreen-btn.is-fullscreen svg.expand {
            display: none;
        }

        #fullscreen-btn.is-fullscreen svg.compress {
            display: block;
        }

        #fullscreen-btn svg.compress {
            display: none;
        }

        /* Mobile Toggle Button */
        #mobile-btn {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(calc(-50% + 100px));
            z-index: 15;
            background: var(--glass);
            backdrop-filter: blur(8px);
            border: var(--glass-border);
            color: var(--secondary);
            font-family: var(--font-main);
            font-size: 12px;
            padding: 10px 15px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #mobile-btn:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.4);
        }

        #mobile-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        #mobile-btn.is-mobile {
            color: var(--danger);
        }

        #mobile-btn.is-mobile svg.desktop {
            display: none;
        }

        #mobile-btn.is-mobile svg.mobile {
            display: block;
        }

        #mobile-btn svg.mobile {
            display: none;
        }

        /* Adjust fullscreen button position when mobile button exists */
        #fullscreen-btn {
            transform: translateX(calc(-50% - 70px));
        }

        #fullscreen-btn:hover {
            transform: translateX(calc(-50% - 70px)) scale(1.05);
        }

        #fullscreen-btn:active {
            transform: translateX(calc(-50% - 70px)) scale(0.98);
        }

        /* ========== MOBILE VIEW STYLES ========== */
        body.mobile-view .panel {
            padding: 8px;
            font-size: 10px;
        }

        body.mobile-view .panel h3 {
            font-size: 10px;
            margin: 0 0 5px 0;
            letter-spacing: 1px;
        }

        body.mobile-view .panel-content {
            font-size: 9px;
            line-height: 1.3;
        }

        body.mobile-view #sys-panel {
            top: 10px;
            left: 10px;
            width: 140px;
        }

        body.mobile-view #sys-panel #console-log {
            height: 35px;
            font-size: 8px;
        }

        body.mobile-view #mode-panel {
            top: 10px;
            right: 10px;
            width: 130px;
        }

        body.mobile-view #mode-panel #current-mode {
            font-size: 14px !important;
        }

        body.mobile-view #mode-panel #mode-desc {
            font-size: 8px !important;
        }

        body.mobile-view #data-panel {
            bottom: 10px;
            left: 10px;
            width: 220px;
        }

        body.mobile-view .controls-row {
            flex-direction: column;
            gap: 4px;
        }

        body.mobile-view .controls-row .key-badge {
            min-width: auto;
            flex: none;
        }

        /* Mobile adjustments for panel tab */
        body.mobile-view .panel-tab {
            width: 28px;
            height: 28px;
            top: -14px;
            font-size: 14px;
        }

        body.mobile-view .panel.collapsed {
            height: 45px !important;
        }

        body.mobile-view .panel.collapsed .panel-tab {
            top: 8px;
        }

        body.mobile-view #data-panel .key-badge {
            font-size: 8px;
            padding: 1px 3px;
            margin: 1px;
        }

        /* Background Control Styles */
        /* Hide background control panel and data panel on desktop (large screens) */
        @media (min-width: 769px) {
            #background-control-panel,
            #data-panel {
                display: none !important;
            }
        }
        
        #bg-opacity-slider, #bg-blur-slider {
            -webkit-appearance: none;
            appearance: none;
            background: rgba(0, 255, 255, 0.2);
            cursor: pointer;
            border-radius: 2px;
            height: 4px;
            outline: none;
        }

        #bg-opacity-slider::-webkit-slider-thumb, #bg-blur-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 6px rgba(0, 255, 255, 0.6);
            transition: all 0.2s ease;
        }

        #bg-opacity-slider::-webkit-slider-thumb:hover, #bg-blur-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        #bg-opacity-slider::-moz-range-thumb, #bg-blur-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 6px rgba(0, 255, 255, 0.6);
            transition: all 0.2s ease;
        }

        .preset-btn {
            transition: all 0.2s ease;
        }

        .preset-btn:hover {
            background: rgba(0, 255, 255, 0.3) !important;
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.4);
            transform: scale(1.05);
        }

        .preset-btn:active {
            transform: scale(0.95);
        }

        /* Background overlay styles */
        #background-overlay {
            mix-blend-mode: multiply;
            z-index: 1 !important;
        }

        body.mobile-view #latency-panel {
            bottom: 10px;
            right: 10px;
            width: 130px;
        }

        body.mobile-view #latency-panel #fps-counter {
            font-size: 14px !important;
        }

        body.mobile-view #fullscreen-btn,
        body.mobile-view #mobile-btn {
            padding: 6px 10px;
            font-size: 9px;
            gap: 4px;
        }

        body.mobile-view #fullscreen-btn svg,
        body.mobile-view #mobile-btn svg {
            width: 12px;
            height: 12px;
        }

        body.mobile-view #fullscreen-btn {
            transform: translateX(calc(-50% - 50px));
        }

        body.mobile-view #fullscreen-btn:hover {
            transform: translateX(calc(-50% - 50px)) scale(1.05);
        }

        body.mobile-view #mobile-btn {
            transform: translateX(calc(-50% + 50px));
        }

        body.mobile-view .loader-text {
            font-size: 16px;
        }

        body.mobile-view .loader-bar {
            width: 200px;
        }

        /* Mobile Background Controls */
        body.mobile-view #bg-opacity-slider,
        body.mobile-view #bg-blur-slider {
            height: 6px;
        }

        body.mobile-view #bg-opacity-slider::-webkit-slider-thumb,
        body.mobile-view #bg-blur-slider::-webkit-slider-thumb {
            width: 16px;
            height: 16px;
        }

        body.mobile-view .preset-btn {
            font-size: 10px;
            padding: 4px 8px;
        }

        body.mobile-view .scanlines {
            background-size: 100% 2px;
        }
        
        /* ========== MOBILE PERFORMANCE OPTIMIZATIONS ========== */
        @media (max-width: 768px) {
            /* CRITICAL: Disable expensive backdrop-filter (GPU killer) */
            .panel,
            .operator-panel,
            .telemetry-panel,
            #mobile-touch-bar,
            #more-modes-panel,
            #intel-filter-panel,
            #carousel-panel {
                backdrop-filter: none !important;
                -webkit-backdrop-filter: none !important;
                background: var(--panel-bg-mobile) !important;
                box-shadow: var(--panel-shadow-mobile) !important;
                border: 1px solid var(--primary);
            }
            
            /* Disable scanlines on mobile for performance */
            .scanlines {
                display: none !important;
            }
            
            /* Disable grain effect on mobile */
            .grain {
                display: none !important;
            }
            
            /* Simplify animations */
            .integrity-node,
            .cyber-fill {
                animation-duration: 3s;
            }
            
            /* Use GPU-accelerated transforms */
            .touch-btn,
            #mobile-touch-bar,
            #more-modes-panel {
                transform: translate3d(0, 0, 0);
                will-change: transform;
            }
            
            /* Increase touch target sizes */
            input[type="range"] {
                height: 44px;
                padding: 10px 0;
            }
            
            input[type="checkbox"] {
                width: 24px;
                height: 24px;
                min-width: 24px;
                min-height: 24px;
            }
            
            /* Make buttons more touchable */
            button,
            .touch-btn,
            .mode-btn {
                min-height: 44px;
                min-width: 44px;
                padding: 12px;
            }
            
            /* Reduce filter effects */
            canvas {
                filter: none !important;
            }
            
            video {
                filter: contrast(1.05) brightness(1.02) !important;
            }
        }
        
        /* Extra performance for low-end devices */
        @media (max-width: 480px) {
            .scanlines {
                display: none; /* Hide scanlines completely on small screens */
            }
            
            .panel,
            .telemetry-panel {
                backdrop-filter: none;
                -webkit-backdrop-filter: none;
                background: rgba(0, 15, 20, 0.9);
            }
        }

        /* Hide some text in mobile for space */
        body.mobile-view #fullscreen-text,
        body.mobile-view #mobile-text {
            display: none;
        }

        /* === DRAGGABLE OPERATOR PANELS === */
        .operator-panel {
            position: absolute;
            background: linear-gradient(135deg, rgba(5, 5, 5, 0.95), rgba(0, 20, 20, 0.8));
            backdrop-filter: blur(15px);
            border: 2px solid rgba(0, 255, 255, 0.4);
            box-shadow:
                0 0 50px rgba(0, 255, 255, 0.2),
                inset 0 0 50px rgba(0, 255, 255, 0.1);
            color: #fff;
            overflow: hidden;
            z-index: var(--z-maps);
            animation: panel-enter 0.8s ease-out;
            cursor: grab;
            pointer-events: auto;
        }

        .operator-panel:active {
            cursor: grabbing;
        }

        .operator-panel.dragging {
            opacity: 0.9;
            box-shadow: 0 10px 40px rgba(0, 255, 255, 0.4);
            transition: none; /* Disable transitions during drag for responsive movement */
        }

        .operator-panel:not(.dragging) {
            transition: left 0.1s ease, top 0.1s ease; /* Smooth transitions when not dragging */
        }

        .operator-panel:hover {
            box-shadow:
                0 0 30px rgba(0, 255, 255, 0.3),
                inset 0 0 30px rgba(0, 255, 255, 0.1);
        }

        .operator-panel.hand-hover {
            box-shadow:
                0 0 40px rgba(255, 184, 0, 0.5),
                0 0 20px rgba(255, 184, 0, 0.3),
                inset 0 0 40px rgba(255, 184, 0, 0.2);
            border-color: rgba(255, 184, 0, 0.6);
        }

        @keyframes panel-enter {
            0% {
                opacity: 0;
                transform: scale(0.8) translateY(20px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .operator-panel .drag-handle {
            background: linear-gradient(90deg, rgba(0, 255, 255, 0.2), transparent);
            padding: 12px 20px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            cursor: grab;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--primary);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .operator-panel .drag-handle:active {
            cursor: grabbing;
            background: linear-gradient(90deg, rgba(0, 255, 255, 0.4), rgba(0, 255, 255, 0.1));
        }

        .operator-panel .drag-handle::before {
            content: '⋮⋮';
            color: var(--primary);
            font-size: 12px;
            transform: rotate(90deg);
        }

        .operator-panel .content {
            padding: 20px;
            height: calc(100% - 50px);
            overflow-y: auto;
        }

        /* CYBER-DECK Panel */
        #cyber-deck {
            width: 400px;
            height: 320px;
        }

        #cyber-deck .hex-matrix {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: var(--secondary);
            height: 200px;
            overflow: hidden;
            background: rgba(0, 5, 5, 0.5);
            padding: 10px;
            position: relative;
        }

        #cyber-deck .progress-bars {
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .cyber-bar {
            height: 8px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            overflow: hidden;
        }

        .cyber-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--secondary), var(--primary));
            animation: cyber-pulse 2.5s ease-in-out infinite;
        }

        @keyframes cyber-pulse {
            0%, 100% { width: 15%; }
            50% { width: 85%; }
        }

        /* ORBITAL-SCAN Panel */
        #orbital-scan {
            width: 350px;
            height: 350px;
        }

        #orbital-scan .radar-display {
            width: 100%;
            height: 250px;
            background: radial-gradient(circle, rgba(0, 20, 20, 0.8) 0%, rgba(5, 5, 5, 0.9) 100%);
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            margin: 0 auto;
        }

        #orbital-scan .scan-data {
            margin-top: 15px;
            font-size: 10px;
            color: var(--secondary);
            text-align: center;
        }

        /* SYS-INTEGRITY Panel */
        #sys-integrity {
            width: 380px;
            height: 350px;
        }

        /* INTEL 3D Labels Container */
        #intel-3d-labels {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 15;
            overflow: hidden;
        }
        
        .intel-3d-label {
            position: absolute;
            background: rgba(0, 8, 16, 0.92);
            border: 1px solid #00ff88;
            border-radius: 4px;
            padding: 6px 10px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 10px;
            color: #00ff88;
            white-space: nowrap;
            pointer-events: none;
            transform: translate(-50%, -100%);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.4),
                        inset 0 0 10px rgba(0, 255, 136, 0.1);
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .intel-3d-label::before {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid #00ff88;
        }
        
        .intel-3d-label::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(0, 255, 136, 0.8), 
                transparent);
            animation: labelScan 2s linear infinite;
        }
        
        @keyframes labelScan {
            0% { transform: translateY(0); opacity: 1; }
            50% { opacity: 0.5; }
            100% { transform: translateY(100%); opacity: 1; }
        }
        
        /* Mobile responsive for 3D labels */
        @media (max-width: 768px) {
            .intel-3d-label {
                font-size: 9px;
                padding: 4px 8px;
            }
        }

        /* INTEL FILTER Panel */
        #intel-filter-panel {
            position: absolute;
            top: 170px;
            left: 15px;
            width: 220px;
            min-height: 50px;
            background: rgba(0, 8, 16, 0.95);
            border: 1px solid rgba(0, 255, 136, 0.5);
            border-radius: 8px;
            font-family: 'Share Tech Mono', monospace;
            z-index: var(--z-overlays);
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
        }
        
        #intel-filter-panel.collapsed {
            height: 36px !important;
            min-height: 36px;
        }
        
        #intel-filter-panel.collapsed .intel-filter-content {
            display: none;
        }
        
        .intel-filter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(0, 255, 136, 0.1);
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
            cursor: pointer;
            user-select: none;
        }
        
        .intel-filter-header:hover {
            background: rgba(0, 255, 136, 0.2);
        }
        
        .intel-filter-header h4 {
            margin: 0;
            font-size: 11px;
            color: #00ff88;
            letter-spacing: 1px;
        }
        
        .intel-filter-toggle {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #00ff88;
            font-size: 12px;
            transition: transform 0.3s ease;
        }
        
        #intel-filter-panel.collapsed .intel-filter-toggle {
            transform: rotate(-90deg);
        }
        
        .intel-filter-content {
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .intel-filter-category {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            margin-bottom: 4px;
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .intel-filter-category:hover {
            background: rgba(0, 255, 136, 0.15);
            border-color: rgba(0, 255, 136, 0.4);
        }
        
        .intel-filter-category.disabled {
            opacity: 0.4;
            background: rgba(255, 0, 85, 0.1);
            border-color: rgba(255, 0, 85, 0.3);
        }
        
        .intel-filter-category.disabled .filter-checkbox {
            background: rgba(255, 0, 85, 0.3);
            border-color: #ff0055;
        }
        
        .filter-checkbox {
            width: 16px;
            height: 16px;
            border: 2px solid #00ff88;
            border-radius: 3px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 255, 136, 0.2);
            transition: all 0.2s ease;
        }
        
        .filter-checkbox::after {
            content: '✓';
            color: #00ff88;
            font-size: 10px;
            font-weight: bold;
        }
        
        .intel-filter-category.disabled .filter-checkbox::after {
            content: '✗';
            color: #ff0055;
        }
        
        .filter-label {
            flex: 1;
            font-size: 10px;
            color: #AAAAAA;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .filter-count {
            font-size: 9px;
            color: #00ffff;
            background: rgba(0, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .intel-filter-actions {
            display: flex;
            gap: 8px;
            padding: 8px 10px;
            border-top: 1px solid rgba(0, 255, 136, 0.2);
        }
        
        .intel-filter-btn {
            flex: 1;
            padding: 6px 8px;
            font-size: 9px;
            font-family: 'Share Tech Mono', monospace;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.4);
            color: #00ff88;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
        }
        
        .intel-filter-btn:hover {
            background: rgba(0, 255, 136, 0.3);
        }
        
        .intel-filter-btn.danger {
            background: rgba(255, 0, 85, 0.1);
            border-color: rgba(255, 0, 85, 0.4);
            color: #ff0055;
        }
        
        .intel-filter-btn.danger:hover {
            background: rgba(255, 0, 85, 0.3);
        }

        /* CAROUSEL Panel */
        #carousel-panel {
            width: 450px;
            height: 400px;
            background: linear-gradient(135deg, rgba(5, 5, 5, 0.95), rgba(0, 20, 20, 0.85));
            border: 2px solid rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            z-index: var(--z-overlays);
            cursor: grab;
        }

        #carousel-panel .drag-handle {
            cursor: grab;
            user-select: none;
            pointer-events: auto;
            z-index: 35;
            position: relative;
        }

        #carousel-panel .drag-handle:active {
            cursor: grabbing;
        }

        #carousel-canvas {
            pointer-events: none;
            transition: all 0.3s ease;
        }

        #sys-integrity .body-diagram {
            width: 180px;
            height: 280px;
            margin: 0 auto;
            position: relative;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 200'%3E%3Cpath d='M50 10 Q40 5 35 15 L35 50 Q35 60 45 65 L45 120 Q45 135 50 140 Q55 135 55 120 L55 65 Q65 60 65 50 L65 15 Q60 5 50 10 Z M35 80 Q30 85 35 90 L35 110 Q35 125 45 130 L45 160 Q45 175 50 180 Q55 175 55 160 L55 130 Q65 125 65 110 L65 90 Q70 85 65 80 Z' fill='none' stroke='%2300FFFF' stroke-width='2'/%3E%3C/svg%3E") no-repeat center;
            background-size: contain;
        }

        .integrity-node {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--secondary);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--secondary);
            animation: node-pulse 1.5s ease-in-out infinite;
        }

        .integrity-node.warning {
            background: var(--danger);
            box-shadow: 0 0 10px var(--danger);
            animation: node-pulse 0.8s ease-in-out infinite;
        }

        @keyframes node-pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.6;
                transform: scale(1.2);
            }
        }

        /* === MAPS DOCK SYSTEM (Unified telemetry/mini-maps container) === */
        #maps-dock {
            position: fixed;
            bottom: 60px; /* Espacio para la barra de modos */
            left: 380px; /* A la derecha del data-panel (350px width + 20px left + 10px gap) */
            right: auto;
            top: auto;
            transform: none;
            display: flex;
            flex-direction: row;
            gap: 15px;
            z-index: var(--z-maps);
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        /* Legacy telemetry-sidebar (now maps-dock) */
        #telemetry-sidebar {
            /* Maps dock is the new container, telemetry-sidebar becomes an alias */
            position: fixed;
            bottom: 60px; /* Espacio para la barra de modos */
            left: 380px; /* A la derecha del data-panel (350px width + 20px left + 10px gap) */
            right: auto;
            top: auto;
            transform: none;
            display: flex;
            flex-direction: row;
            gap: 15px;
            z-index: var(--z-maps);
            pointer-events: none;
        }
        
        /* MODES BAR - Barra horizontal minimalista de modos */
        #modes-bar {
            position: fixed;
            bottom: 20px;
            left: 380px;
            right: auto;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 4px;
            padding: 6px 10px;
            background: rgba(0, 10, 15, 0.85);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            z-index: var(--z-maps);
            pointer-events: none;
            font-family: 'Share Tech Mono', monospace;
            backdrop-filter: blur(5px);
        }
        
        .mode-item {
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .mode-key {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 18px;
            padding: 0 4px;
            background: rgba(0, 255, 255, 0.15);
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 2px;
            color: rgba(0, 255, 255, 0.9);
            font-size: 9px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.2s ease;
        }
        
        .mode-label {
            font-size: 7px;
            color: rgba(0, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Resaltar modo activo */
        body[data-mode="HUD"] #modes-bar .mode-item[data-mode="HUD"] .mode-key,
        body[data-mode="DRAW"] #modes-bar .mode-item[data-mode="DRAW"] .mode-key,
        body[data-mode="XRAY"] #modes-bar .mode-item[data-mode="XRAY"] .mode-key,
        body[data-mode="INTEL"] #modes-bar .mode-item[data-mode="INTEL"] .mode-key,
        body[data-mode="MATRIX"] #modes-bar .mode-item[data-mode="MATRIX"] .mode-key,
        body[data-mode="VOID"] #modes-bar .mode-item[data-mode="VOID"] .mode-key,
        body[data-mode="WIREFRAME"] #modes-bar .mode-item[data-mode="WIREFRAME"] .mode-key,
        body[data-mode="DRONE"] #modes-bar .mode-item[data-mode="DRONE"] .mode-key,
        body[data-mode="FACE"] #modes-bar .mode-item[data-mode="FACE"] .mode-key,
        body[data-mode="OPERATOR"] #modes-bar .mode-item[data-mode="OPERATOR"] .mode-key,
        body[data-mode="TOUCH"] #modes-bar .mode-item[data-mode="TOUCH"] .mode-key,
        body[data-mode="CAROUSEL"] #modes-bar .mode-item[data-mode="CAROUSEL"] .mode-key,
        body[data-mode="SANDTABLE"] #modes-bar .mode-item[data-mode="SANDTABLE"] .mode-key,
        body[data-mode="FLUID"] #modes-bar .mode-item[data-mode="FLUID"] .mode-key {
            background: rgba(0, 255, 255, 0.4);
            border-color: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
        }
        
        /* Resaltar cubo activo */
        body.cube-active #modes-bar .mode-item.cube-toggle .mode-key {
            background: rgba(0, 255, 255, 0.4);
            border-color: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
        }
        
        /* Maps dock visibility by mode */
        body[data-mode="CAROUSEL"] #maps-dock,
        body[data-mode="CAROUSEL"] #telemetry-sidebar {
            opacity: 0.3; /* Reduced visibility in carousel mode */
        }
        
        body[data-mode="INTEL"] #maps-dock .map-item[data-priority="low"],
        body[data-mode="INTEL"] #telemetry-sidebar .telemetry-panel[data-priority="low"] {
            display: none; /* Hide low priority maps in INTEL mode */
        }
        
        body[data-mode="OPERATOR"] #maps-dock .map-item:not([data-type="radar"]),
        body[data-mode="OPERATOR"] #telemetry-sidebar .telemetry-panel:not([data-type="radar"]) {
            opacity: 0.5; /* Dim non-radar maps in OPERATOR mode */
        }

        .telemetry-panel {
            background: linear-gradient(135deg, rgba(5, 5, 5, 0.9), rgba(0, 20, 20, 0.7));
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.2);
            pointer-events: auto;
            overflow: visible; /* Cambiado de hidden a visible para ver el texto */
            display: flex;
            flex-direction: column;
        }

        .telemetry-panel h4 {
            margin: 0;
            padding: 8px 12px;
            background: rgba(0, 255, 255, 0.1);
            color: var(--primary);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
        }

        .telemetry-panel canvas {
            display: block;
        }

        .telemetry-info {
            padding: 4px 8px;
            font-size: 9px;
            color: rgba(0, 255, 255, 0.9); /* Más visible */
            text-align: center;
            line-height: 1.4;
            font-family: 'Share Tech Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: rgba(0, 255, 255, 0.1); /* Más visible */
            border-top: 1px solid rgba(0, 255, 255, 0.4);
            margin-top: auto; /* Empujar al final del panel */
            flex-shrink: 0; /* No reducir tamaño */
        }

        /* Thermal Optics Panel */
        #thermal-optics {
            width: 220px;
            height: 160px;
        }

        #thermal-optics canvas {
            width: 100%;
            height: 110px; /* Reducido para dejar espacio al texto */
        }

        /* MoCap Data Panel */
        #mocap-data {
            width: 220px;
            height: 160px;
        }

        #mocap-data canvas {
            width: 100%;
            height: 110px; /* Reducido para dejar espacio al texto */
            background: #000;
        }

        /* Hand Map Panel */
        #hand-map {
            width: 220px;
            height: 160px;
        }

        #hand-map canvas {
            width: 100%;
            height: 110px; /* Reducido para dejar espacio al texto */
            background: #000;
        }
        
        /* Toggle HUD Button */
        #toggle-hud-btn {
            position: fixed;
            top: var(--safe-top);
            right: var(--safe-right);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(0, 20, 30, 0.9);
            border: 2px solid var(--primary);
            color: var(--primary);
            font-size: 18px;
            cursor: pointer;
            z-index: var(--z-toggle);
            display: none;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        #toggle-hud-btn:active {
            transform: scale(0.95);
        }
        
        #toggle-hud-btn.hud-hidden {
            background: rgba(255, 0, 85, 0.3);
            border-color: var(--danger);
            color: var(--danger);
        }
        
        /* HUD hidden state */
        body.hud-collapsed #telemetry-sidebar,
        body.hud-collapsed #mode-panel,
        body.hud-collapsed #sys-panel,
        body.hud-collapsed #data-panel,
        body.hud-collapsed #latency-panel {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        @media (max-width: 768px) {
            #toggle-hud-btn {
                display: flex;
            }
        }

        /* === RESPONSIVE ADJUSTMENTS === */
        @media (max-width: 1400px) {
            #telemetry-sidebar {
                left: 370px; /* Ajustado para pantallas medianas */
                bottom: 50px; /* Espacio para la barra de modos */
            }
            
            #modes-bar {
                left: 370px;
                bottom: 10px;
                gap: 3px;
                padding: 4px 8px;
            }
            
            .mode-key {
                min-width: 16px;
                height: 16px;
                font-size: 8px;
            }
            
            .mode-label {
                font-size: 6px;
            }

            .telemetry-panel {
                width: 180px;
                height: 130px;
            }

            .telemetry-panel canvas {
                height: 90px;
}
        }

        @media (max-width: 1200px) {
            .operator-panel {
                width: 300px !important;
                height: 280px !important;
            }
        }

        @media (max-width: 768px) {
            .operator-panel {
                display: none; /* Hide operator panels on mobile */
            }

            /* Maps dock: horizontal carousel above touch bar */
            #maps-dock,
            #telemetry-sidebar {
                position: fixed;
                bottom: calc(var(--safe-bottom) + 50px); /* Above modes bar and touch bar */
                left: var(--safe-left);
                right: auto;
                top: auto;
                transform: none;
                flex-direction: row;
                gap: 8px;
                overflow-x: auto;
                overflow-y: hidden;
                scroll-snap-type: x mandatory;
                -webkit-overflow-scrolling: touch;
                max-width: calc(100vw - var(--safe-left) - var(--safe-right));
                padding: 0 5px;
            }
            
            /* Modes bar en móvil - más compacta */
            #modes-bar {
                position: fixed;
                bottom: calc(var(--safe-bottom) + 10px);
                left: var(--safe-left);
                right: var(--safe-right);
                width: auto;
                max-width: calc(100vw - var(--safe-left) - var(--safe-right));
                overflow-x: auto;
                overflow-y: hidden;
                gap: 2px;
                padding: 4px 6px;
                flex-wrap: nowrap;
            }
            
            .mode-key {
                min-width: 14px;
                height: 14px;
                font-size: 7px;
                flex-shrink: 0;
            }
            
            .mode-label {
                font-size: 5px;
                flex-shrink: 0;
            }
            
            #maps-dock .map-item,
            #telemetry-sidebar .telemetry-panel {
                scroll-snap-align: start;
                flex-shrink: 0;
                overflow-x: auto;
                overflow-y: hidden;
                transition: bottom 0.3s ease, opacity 0.3s ease;
                max-width: calc(100vw - 20px);
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
                padding-bottom: 5px;
            }
            
            #telemetry-sidebar::-webkit-scrollbar {
                display: none;
            }

            .telemetry-panel {
                width: 110px; /* 50% of 220px */
                height: 80px; /* 50% of 160px */
                flex-shrink: 0;
            }
            
            .telemetry-panel h4 {
                font-size: 8px;
                padding: 4px 6px;
            }

            .telemetry-panel canvas {
                height: 45px; /* Reducido para dejar espacio al texto */
                width: 100%;
                display: block;
            }

            .telemetry-info {
                font-size: 6px;
                padding: 2px 4px;
                line-height: 1.2;
            }
            
            /* Hide desktop panels on mobile - auto collapse */
            #sys-panel,
            #latency-panel,
            #data-panel {
                display: none !important;
            }
            
            /* Compact mode panel on mobile - positioned below top bar */
            #mode-panel {
                top: var(--safe-top);
                right: calc(var(--safe-right) + 50px); /* Make room for toggle button */
                left: auto;
                width: auto;
                min-width: 80px;
                padding: 6px 10px;
                transform: scale(var(--hud-scale));
                transform-origin: top right;
                z-index: 15;
            }
            
            #mode-panel h3 {
                font-size: 9px;
                margin-bottom: 3px;
                letter-spacing: 1px;
            }
            
            #current-mode {
                font-size: 14px !important;
            }
            
            #mode-desc {
                font-size: 7px !important;
            }
            
            /* Make remaining visible panels more responsive */
            .panel {
                max-width: calc(100vw - 20px);
                box-sizing: border-box;
            }
            
            /* Prevent panels from overflowing on small screens */
            #intel-filter-panel,
            #carousel-panel,
            #tracking-quality-meter {
                max-width: calc(100vw - 20px);
                overflow: hidden;
            }
            
            /* Responsive panel widths */
            #intel-filter-panel {
                width: min(180px, calc(100vw - 20px));
            }
            
            /* Ensure text doesn't overflow */
            .panel h3,
            .panel p,
            .panel label {
                overflow-wrap: break-word;
                word-wrap: break-word;
                hyphens: auto;
            }
        }
        
        /* Extra small screens - Minimal UI Mode */
        @media (max-width: 480px) {
            /* Even more aggressive panel width limits */
            .panel,
            #intel-filter-panel,
            #carousel-panel {
                max-width: calc(100vw - 16px) !important;
            }
            
            #mode-panel #mode-desc {
                display: none; /* Hide description by default on very small screens */
            }
            
            #mode-panel.expanded #mode-desc {
                display: block; /* Show on tap/click */
            }
            
            /* Line clamp for console log */
            .console-log {
                display: -webkit-box;
                -webkit-line-clamp: 2;
                line-clamp: 2;
                -webkit-box-orient: vertical;
                overflow: hidden;
            }
            
            /* Reduce padding on very small screens */
            .panel {
                padding: 8px !important;
            }
            
            /* Make telemetry even smaller */
            .telemetry-panel {
                width: 80px !important;
                height: 60px !important;
            }
            
            .telemetry-panel canvas {
                height: 35px !important;
            }
            
            .telemetry-panel h4 {
                font-size: 7px !important;
                padding: 3px 4px !important;
            }
            
            /* Hide desktop fullscreen/mobile buttons - use top bar instead */
            #fullscreen-btn,
            #mobile-btn {
                display: none !important;
            }
        }
        
        /* Extra small screens */
        @media (max-width: 480px) {
            .telemetry-panel {
                width: 90px;
                height: 65px;
            }
            
            .telemetry-panel canvas {
                height: 40px;
            }
            
            #mode-panel {
                padding: 4px 8px;
                min-width: 60px;
            }
            
            #current-mode {
                font-size: 12px !important;
            }
        }
        
        /* ========== MOBILE TOUCH BAR ========== */
        #mobile-touch-bar {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,10,15,0.95) 30%);
            backdrop-filter: blur(10px);
            z-index: var(--z-modal);
            padding: 8px 10px 12px;
            box-sizing: border-box;
        }
        
        #mobile-touch-bar.visible {
            display: block;
        }
        
        .touch-bar-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
            height: 100%;
            max-width: 600px;
            margin: 0 auto;
            gap: 4px;
        }
        
        .touch-btn {
            width: var(--touch-btn-size);
            height: var(--touch-btn-size);
            min-width: 40px;
            min-height: 40px;
            border: 2px solid var(--primary);
            border-radius: 8px;
            background: rgba(0, 20, 30, 0.8);
            color: var(--primary);
            font-family: var(--font-main);
            font-size: 9px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            transition: all 0.15s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .touch-btn:active {
            background: var(--primary);
            color: var(--bg-dark);
            transform: scale(0.92);
            box-shadow: 0 0 20px var(--primary);
        }
        
        .touch-btn.active {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }
        
        .touch-btn-icon {
            font-size: 16px;
            line-height: 1;
        }
        
        .touch-btn-label {
            font-size: 7px;
            letter-spacing: 0.5px;
            opacity: 0.9;
        }
        
        /* Touch bar toggle button */
        #touch-bar-toggle {
            position: fixed;
            bottom: calc(var(--safe-bottom) - 25px);
            right: var(--safe-right);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(0, 20, 30, 0.9);
            border: 2px solid var(--primary);
            color: var(--primary);
            font-size: 18px;
            cursor: pointer;
            z-index: var(--z-toggle);
            display: none;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }
        
        #touch-bar-toggle.visible {
            display: flex;
        }
        
        /* More modes panel (swipe up or toggle) */
        #more-modes-panel {
            position: fixed;
            bottom: 70px;
            left: 0;
            right: 0;
            background: rgba(0, 10, 15, 0.95);
            backdrop-filter: blur(15px);
            border-top: 1px solid var(--primary);
            padding: 15px;
            z-index: 99;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            display: none;
        }
        
        #more-modes-panel.visible {
            display: block;
        }
        
        #more-modes-panel.open {
            transform: translateY(0);
        }
        
        .more-modes-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            max-width: 400px;
            margin: 0 auto;
        }
        
        @media (max-width: 768px) {
            #mobile-touch-bar.visible,
            #touch-bar-toggle.visible {
                display: flex;
            }
            
            #more-modes-panel.visible {
                display: block;
            }
        }

        /* Mobile frame simulation */
        body.mobile-view::before {
            content: '';
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: min(100vw, 400px);
            height: 100vh;
            border-left: 2px solid rgba(0, 255, 255, 0.3);
            border-right: 2px solid rgba(0, 255, 255, 0.3);
            pointer-events: none;
            z-index: var(--z-decorative);
            box-shadow: 
                inset 0 0 50px rgba(0, 0, 0, 0.5),
                0 0 30px rgba(0, 0, 0, 0.8);
        }

        body.mobile-view #container {
            max-width: 400px;
            margin: 0 auto;
            border-left: 1px solid rgba(0, 255, 255, 0.2);
            border-right: 1px solid rgba(0, 255, 255, 0.2);
            overflow: hidden;
        }

        body.mobile-view canvas {
            object-fit: cover;
            object-position: center;
        }

        /* Notch simulation */
        body.mobile-view::after {
            content: '';
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 25px;
            background: #000;
            border-radius: 0 0 15px 15px;
            z-index: calc(var(--z-decorative) + 1);
            pointer-events: none;
        }

        body.mobile-view #ui-layer {
            padding-top: 30px;
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="loader-text">INITIALIZING TACTICAL OS...</div>
        <div class="loader-bar"><div class="loader-progress" id="progress-bar"></div></div>
        <div style="margin-top: 10px; color: #666; font-size: 12px;" id="loader-status">Loading Neural Networks...</div>
    </div>

    <div id="container">
        <!-- Raw video feed (hidden) -->
        <video id="video-feed" playsinline></video>
        
        <!-- Render Layers -->
        <canvas id="main-canvas"></canvas>
        <canvas id="three-canvas"></canvas>
        
        <!-- Scanlines Overlay -->
        <div class="scanlines"></div>
        
        <!-- MOBILE TOP BAR (Hidden on desktop) -->
        <div id="mobile-top-bar">
            <div class="top-bar-container">
                <button class="top-bar-btn" id="top-fullscreen-btn" title="Fullscreen">
                    <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
                    <span>FULL</span>
                </button>
                <button class="top-bar-btn" id="top-mobile-btn" title="Mobile View">
                    <svg viewBox="0 0 24 24"><path d="M17 1.01L7 1c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z"/></svg>
                    <span>MOBILE</span>
                </button>
                <div id="top-bar-mode">HUD</div>
                <button class="top-bar-btn" id="top-camera-btn" title="Switch Camera">
                    <svg viewBox="0 0 24 24"><path d="M20 5h-3.17L15 3H9L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-8 13c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"/></svg>
                    <span>CAM</span>
                </button>
                <button class="top-bar-btn" id="top-settings-btn" title="Settings">
                    <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
                </button>
            </div>
        </div>
        
        <!-- Toggle HUD Button (Mobile only) -->
        <button id="toggle-hud-btn" title="Toggle HUD">👁️</button>

        <!-- Fullscreen Button -->
        <button id="fullscreen-btn" title="Pantalla Completa [F]">
            <svg class="expand" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
            </svg>
            <svg class="compress" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>
            </svg>
            <span id="fullscreen-text">FULLSCREEN</span>
        </button>

        <!-- Mobile View Toggle Button -->
        <button id="mobile-btn" title="Vista Móvil [M]">
            <svg class="desktop" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M21 2H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h7l-2 3v1h8v-1l-2-3h7c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 12H3V4h18v10z"/>
            </svg>
            <svg class="mobile" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M17 1.01L7 1c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z"/>
            </svg>
            <span id="mobile-text">MOBILE</span>
        </button>

        <!-- UI Layout -->
        <div id="ui-layer">
            <div id="sys-panel" class="panel">
                <h3>SYSTEM STATUS</h3>
                <div class="panel-content">
                    CPU: <span style="color:var(--secondary)">OPTIMAL</span><br>
                    MEMORY: <span id="mem-stat">--</span><br>
                    NET: SECURE<br>
                    <div style="margin-top:10px; border-top:1px solid #333; padding-top:5px;">
                        <div id="console-log" style="height: 60px; overflow:hidden; color: #aaa;">
                            > Boot sequence initiated...
                        </div>
                    </div>
                </div>
            </div>

            <div id="mode-panel" class="panel">
                <h3>ACTIVE MODE</h3>
                <div class="panel-content">
                    <div id="current-mode" style="font-size: 24px; color: var(--danger); font-weight: bold;">STANDBY</div>
                    <div id="mode-desc" style="font-size: 10px; color: #aaa; margin-top:5px;">WAITING FOR INPUT</div>
                </div>
            </div>

            <div id="data-panel" class="panel expanded">
                <div class="panel-tab" id="controls-tab" title="Toggle Controls Panel">
                    <span class="tab-icon">⚙️</span>
                </div>
                <h3>CONTROLS</h3>
                <div class="panel-content" id="controls-list">
                    <div class="controls-row">
                        <span class="key-badge">[U]</span> HUD
                        <span class="key-badge">[L]</span> DRAW
                        <span class="key-badge">[X]</span> X-RAY
                        <span class="key-badge">[K]</span> INTEL
                        <span class="key-badge">[V]</span> MATRIX
                    </div>
                    <div class="controls-row">
                        <span class="key-badge">[T]</span> VOID
                        <span class="key-badge">[P]</span> WIRE
                        <span class="key-badge">[B]</span> FACE
                        <span class="key-badge">[C]</span> DRONE
                        <span class="key-badge" style="background:rgba(255,184,0,0.3)">[O]</span> OPERATOR
                        <span class="key-badge" style="background:rgba(100,200,255,0.3)">[J]</span> CAROUSEL
                        <span class="key-badge" style="background:rgba(255,0,255,0.3)">[R]</span> TOUCH
                    </div>
                    <div class="controls-row">
                        <span class="key-badge" style="background:rgba(255,0,85,0.3)">[H]</span> CUBE*
                        <span class="key-badge">[F]</span> FULL
                        <span class="key-badge">[M]</span> MOBILE
                    </div>

                    <!-- BACKGROUND CONTROL SUB-PANEL -->
                    <div id="background-control-panel" style="margin-top: 12px; border-top: 1px solid rgba(0,255,255,0.3); padding-top: 8px;">
                        <div style="font-size: 11px; color: var(--primary); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">
                            BACKGROUND CONTROL
                        </div>

                        <!-- Background Opacity Control -->
                        <div style="margin-bottom: 8px;">
                            <div style="font-size: 9px; color: #aaa; margin-bottom: 4px;">OPACITY: <span id="bg-opacity-value">0</span>%</div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <button id="test-bg-btn" style="background: rgba(255,0,85,0.5); border: 1px solid rgba(255,0,85,0.8); color: white; padding: 4px 8px; font-size: 10px; cursor: pointer;">TEST BG</button>
                                <input type="range" id="bg-opacity-slider" min="0" max="90" value="0" step="10" style="flex: 1; height: 4px; background: rgba(0,255,255,0.2); border-radius: 2px;">
                            </div>
                        </div>

                        <!-- Background Blur Control -->
                        <div style="margin-bottom: 8px;">
                            <div style="font-size: 9px; color: #aaa; margin-bottom: 4px;">BLUR: <span id="bg-blur-value">0</span>px</div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span class="key-badge" style="background: rgba(255,0,85,0.2)">[3]</span>
                                <input type="range" id="bg-blur-slider" min="0" max="20" value="0" step="1" style="flex: 1; height: 4px; background: rgba(0,255,255,0.2); border-radius: 2px;">
                                <span class="key-badge" style="background: rgba(255,0,85,0.2)">[4]</span>
                            </div>
                        </div>

                        <!-- Quick Presets -->
                        <div style="margin-bottom: 8px;">
                            <div style="font-size: 9px; color: #aaa; margin-bottom: 4px;">PRESETS:</div>
                            <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                                <button class="preset-btn" data-preset="clear" style="background: rgba(0,255,255,0.1); border: 1px solid rgba(0,255,255,0.3); color: var(--primary); font-size: 8px; padding: 2px 6px; border-radius: 3px; cursor: pointer;">CLEAR</button>
                                <button class="preset-btn" data-preset="subtle" style="background: rgba(0,255,255,0.1); border: 1px solid rgba(0,255,255,0.3); color: var(--primary); font-size: 8px; padding: 2px 6px; border-radius: 3px; cursor: pointer;">SUBTLE</button>
                                <button class="preset-btn" data-preset="medium" style="background: rgba(0,255,255,0.1); border: 1px solid rgba(0,255,255,0.3); color: var(--primary); font-size: 8px; padding: 2px 6px; border-radius: 3px; cursor: pointer;">MEDIUM</button>
                                <button class="preset-btn" data-preset="heavy" style="background: rgba(0,255,255,0.1); border: 1px solid rgba(0,255,255,0.3); color: var(--primary); font-size: 8px; padding: 2px 6px; border-radius: 3px; cursor: pointer;">HEAVY</button>
                            </div>
                        </div>

                        <!-- Additional Effects -->
                        <div>
                            <div style="font-size: 9px; color: #aaa; margin-bottom: 4px;">EFFECTS:</div>
                            <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                                <span class="key-badge" style="background: rgba(255,184,0,0.2)">[5]</span> VIGNETTE
                                <span class="key-badge" style="background: rgba(255,184,0,0.2)">[6]</span> GRAIN
                                <span class="key-badge" style="background: rgba(255,184,0,0.2)">[7]</span> SCANLINES
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="latency-panel" class="panel">
                <h3>PERFORMANCE</h3>
                <div class="panel-content">
                    FPS: <span id="fps-counter" style="color:var(--secondary); font-size:18px;">0</span><br>
                    RANGE: <span id="fps-range" style="color:#888; font-size:10px;">--</span><br>
                    LATENCY: <span id="latency-val">0</span>ms
                </div>
            </div>
        </div>

        <!-- OPERATOR MODE FLOATING PANELS (Hidden by default) -->
        <div id="operator-panels" style="display: none;">
            <!-- CYBER-DECK Panel -->
            <div id="cyber-deck" class="operator-panel draggable">
                <div class="drag-handle">CYBER-DECK</div>
                <div class="content">
                    <div class="hex-matrix" id="hex-matrix">
                        <div>DEADBEEF 8BADF00D</div>
                        <div>CAFEBABE DEADC0DE</div>
                        <div>FEEDFACE BADCOFFEE</div>
                        <div>C0DEBABE FACEFEED</div>
                        <div>BADDCAFE 8BADFOOD</div>
                        <div>DEADCODE FEEDBABE</div>
                        <div>8BADF00D CAFEBABE</div>
                    </div>
                    <div class="progress-bars">
                        <div class="cyber-bar"><div class="cyber-fill"></div></div>
                        <div class="cyber-bar"><div class="cyber-fill"></div></div>
                        <div class="cyber-bar"><div class="cyber-fill"></div></div>
                    </div>
                </div>
            </div>

            <!-- ORBITAL-SCAN Panel -->
            <div id="orbital-scan" class="operator-panel draggable">
                <div class="drag-handle">ORBITAL-SCAN</div>
                <div class="content">
                    <canvas id="radar-canvas" class="radar-display"></canvas>
                    <div class="scan-data" id="scan-data">
                        SCANNING SECTOR 7G<br>
                        TARGETS: 3 ACTIVE<br>
                        SIGNAL STRENGTH: 87%
                    </div>
                </div>
            </div>

            <!-- SYS-INTEGRITY Panel -->
            <div id="sys-integrity" class="operator-panel draggable">
                <div class="drag-handle">SYS-INTEGRITY</div>
                <div class="content">
                    <div class="body-diagram">
                        <div class="integrity-node" style="top: 15%; left: 50%; transform: translateX(-50%);"></div>
                        <div class="integrity-node warning" style="top: 35%; left: 35%;"></div>
                        <div class="integrity-node" style="top: 35%; right: 35%;"></div>
                        <div class="integrity-node" style="top: 55%; left: 50%; transform: translateX(-50%);"></div>
                        <div class="integrity-node warning" style="top: 75%; left: 40%;"></div>
                        <div class="integrity-node" style="top: 75%; right: 40%;"></div>
                        <div class="integrity-node" style="top: 90%; left: 50%; transform: translateX(-50%);"></div>
                    </div>
                    <div style="text-align: center; margin-top: 15px; font-size: 11px; color: var(--secondary);">
                        INTEGRITY: 94%<br>
                        NEURAL LINK: STABLE
                    </div>
                </div>
            </div>
        </div>

        <!-- CAROUSEL MODE PANEL (Hidden by default) -->
        <div id="carousel-panel" class="operator-panel draggable" style="display: none;">
            <div class="drag-handle">3D CYLINDRICAL CAROUSEL</div>
            <div class="content">
                <canvas id="carousel-canvas" style="width: 100%; height: 300px; background: transparent; border-radius: 8px;"></canvas>
                <div style="text-align: center; margin-top: 15px; font-size: 11px; color: var(--secondary);">
                    SWIPE WITH INDEX FINGER TO NAVIGATE<br>
                    <span id="carousel-info">IMAGE 1 / 5</span>
                </div>
            </div>
        </div>
        
        <!-- INTEL FILTER PANEL (Mode K) -->
        <div id="intel-filter-panel" style="display: none;">
            <div class="intel-filter-header" onclick="window.tacticalOS.toggleIntelFilterPanel()">
                <h4>◆ CAPTURE FILTERS</h4>
                <div class="intel-filter-toggle">▼</div>
            </div>
            <div class="intel-filter-content">
                <!-- Categories will be populated dynamically -->
                <div id="intel-filter-categories">
                    <div class="intel-filter-category" data-category="person">
                        <div class="filter-checkbox"></div>
                        <span class="filter-label">👤 Person</span>
                        <span class="filter-count" id="count-person">0</span>
                    </div>
                    <div class="intel-filter-category" data-category="vehicle">
                        <div class="filter-checkbox"></div>
                        <span class="filter-label">🚗 Vehicles</span>
                        <span class="filter-count" id="count-vehicle">0</span>
                    </div>
                    <div class="intel-filter-category" data-category="electronics">
                        <div class="filter-checkbox"></div>
                        <span class="filter-label">📱 Electronics</span>
                        <span class="filter-count" id="count-electronics">0</span>
                    </div>
                    <div class="intel-filter-category" data-category="furniture">
                        <div class="filter-checkbox"></div>
                        <span class="filter-label">🪑 Furniture</span>
                        <span class="filter-count" id="count-furniture">0</span>
                    </div>
                    <div class="intel-filter-category" data-category="animals">
                        <div class="filter-checkbox"></div>
                        <span class="filter-label">🐕 Animals</span>
                        <span class="filter-count" id="count-animals">0</span>
                    </div>
                    <div class="intel-filter-category" data-category="food">
                        <div class="filter-checkbox"></div>
                        <span class="filter-label">🍕 Food</span>
                        <span class="filter-count" id="count-food">0</span>
                    </div>
                    <div class="intel-filter-category" data-category="sports">
                        <div class="filter-checkbox"></div>
                        <span class="filter-label">⚽ Sports</span>
                        <span class="filter-count" id="count-sports">0</span>
                    </div>
                    <div class="intel-filter-category" data-category="accessories">
                        <div class="filter-checkbox"></div>
                        <span class="filter-label">👜 Accessories</span>
                        <span class="filter-count" id="count-accessories">0</span>
                    </div>
                    <div class="intel-filter-category" data-category="kitchen">
                        <div class="filter-checkbox"></div>
                        <span class="filter-label">🍴 Kitchen</span>
                        <span class="filter-count" id="count-kitchen">0</span>
                    </div>
                    <div class="intel-filter-category" data-category="other">
                        <div class="filter-checkbox"></div>
                        <span class="filter-label">📦 Other</span>
                        <span class="filter-count" id="count-other">0</span>
                    </div>
                </div>
                <div class="intel-filter-actions">
                    <button class="intel-filter-btn" onclick="window.tacticalOS.enableAllFilters()">ALL ON</button>
                    <button class="intel-filter-btn danger" onclick="window.tacticalOS.disableAllFilters()">ALL OFF</button>
                </div>
            </div>
        </div>

        <!-- TELEMETRY SIDEBAR -->
        <div id="telemetry-sidebar">
            <div id="thermal-optics" class="telemetry-panel">
                <h4>1. THERMAL OPTICS</h4>
                <canvas id="thermal-canvas"></canvas>
                <div class="telemetry-info">Thermal vision overlay<br/>Heat signature detection</div>
            </div>
            <div id="mocap-data" class="telemetry-panel">
                <h4>2. MOCAP DATA</h4>
                <canvas id="mocap-canvas"></canvas>
                <div class="telemetry-info">Motion capture tracking<br/>Hand landmarks & cube</div>
            </div>
            <div id="hand-map" class="telemetry-panel">
                <h4>3. HAND MAP</h4>
                <canvas id="hand-map-canvas"></canvas>
                <div class="telemetry-info">Hand topography map<br/>Energy visualization</div>
            </div>
        </div>
        
        <!-- MODES BAR (Minimalista debajo de los mini mapas) -->
        <div id="modes-bar">
            <div class="mode-item" data-mode="HUD"><div class="mode-key">U</div><span class="mode-label">HUD</span></div>
            <div class="mode-item" data-mode="DRAW"><div class="mode-key">L</div><span class="mode-label">DRAW</span></div>
            <div class="mode-item" data-mode="XRAY"><div class="mode-key">X</div><span class="mode-label">XRAY</span></div>
            <div class="mode-item" data-mode="INTEL"><div class="mode-key">K</div><span class="mode-label">INTEL</span></div>
            <div class="mode-item" data-mode="MATRIX"><div class="mode-key">V</div><span class="mode-label">MATRIX</span></div>
            <div class="mode-item" data-mode="VOID"><div class="mode-key">T</div><span class="mode-label">VOID</span></div>
            <div class="mode-item" data-mode="WIREFRAME"><div class="mode-key">P</div><span class="mode-label">WIRE</span></div>
            <div class="mode-item" data-mode="DRONE"><div class="mode-key">C</div><span class="mode-label">DRONE</span></div>
            <div class="mode-item" data-mode="FACE"><div class="mode-key">B</div><span class="mode-label">FACE</span></div>
            <div class="mode-item" data-mode="OPERATOR"><div class="mode-key">O</div><span class="mode-label">OP</span></div>
            <div class="mode-item" data-mode="TOUCH"><div class="mode-key">R</div><span class="mode-label">TOUCH</span></div>
            <div class="mode-item" data-mode="CAROUSEL"><div class="mode-key">J</div><span class="mode-label">CAR</span></div>
            <div class="mode-item" data-mode="SANDTABLE"><div class="mode-key">S</div><span class="mode-label">SAND</span></div>
            <div class="mode-item" data-mode="FLUID"><div class="mode-key">Z</div><span class="mode-label">FLUID</span></div>
            <div class="mode-item cube-toggle"><div class="mode-key">H</div><span class="mode-label">CUBE</span></div>
        </div>
        
        <!-- MOBILE TOUCH BAR -->
        <div id="mobile-touch-bar">
            <div class="touch-bar-container">
                <button class="touch-btn" data-mode="HUD" data-key="U">
                    <span class="touch-btn-icon">📡</span>
                    <span class="touch-btn-label">HUD</span>
                </button>
                <button class="touch-btn" data-mode="DRAW" data-key="L">
                    <span class="touch-btn-icon">✏️</span>
                    <span class="touch-btn-label">DRAW</span>
                </button>
                <button class="touch-btn" data-mode="XRAY" data-key="X">
                    <span class="touch-btn-icon">💀</span>
                    <span class="touch-btn-label">X-RAY</span>
                </button>
                <button class="touch-btn" data-mode="MATRIX" data-key="V">
                    <span class="touch-btn-icon">🔢</span>
                    <span class="touch-btn-label">MATRIX</span>
                </button>
                <button class="touch-btn" data-mode="FACE" data-key="B">
                    <span class="touch-btn-icon">👤</span>
                    <span class="touch-btn-label">FACE</span>
                </button>
                <button class="touch-btn" data-action="more">
                    <span class="touch-btn-icon">⚙️</span>
                    <span class="touch-btn-label">MORE</span>
                </button>
            </div>
        </div>
        
        <!-- MORE MODES PANEL (Hidden by default) -->
        <div id="more-modes-panel">
            <div class="more-modes-grid">
                <button class="touch-btn" data-mode="VOID" data-key="T">
                    <span class="touch-btn-icon">🌀</span>
                    <span class="touch-btn-label">VOID</span>
                </button>
                <button class="touch-btn" data-mode="WIREFRAME" data-key="P">
                    <span class="touch-btn-icon">🔲</span>
                    <span class="touch-btn-label">WIRE</span>
                </button>
                <button class="touch-btn" data-mode="DRONE" data-key="C">
                    <span class="touch-btn-icon">🚁</span>
                    <span class="touch-btn-label">DRONE</span>
                </button>
                <button class="touch-btn" data-mode="INTEL" data-key="K">
                    <span class="touch-btn-icon">🎯</span>
                    <span class="touch-btn-label">INTEL</span>
                </button>
                <button class="touch-btn" data-mode="OPERATOR" data-key="O">
                    <span class="touch-btn-icon">💻</span>
                    <span class="touch-btn-label">OPERATOR</span>
                </button>
                <button class="touch-btn" data-mode="CAROUSEL" data-key="J">
                    <span class="touch-btn-icon">🎠</span>
                    <span class="touch-btn-label">CAROUSEL</span>
                </button>
                <button class="touch-btn" data-mode="TOUCH" data-key="R">
                    <span class="touch-btn-icon">👆</span>
                    <span class="touch-btn-label">TOUCH</span>
                </button>
                <button class="touch-btn" data-mode="SANDTABLE" data-key="S">
                    <span class="touch-btn-icon">🏔️</span>
                    <span class="touch-btn-label">SAND</span>
                </button>
                <button class="touch-btn" data-mode="FLUID" data-key="Z">
                    <span class="touch-btn-icon">🌊</span>
                    <span class="touch-btn-label">FLUID</span>
                </button>
                <button class="touch-btn" data-action="cube" data-key="H">
                    <span class="touch-btn-icon">🎲</span>
                    <span class="touch-btn-label">CUBE</span>
                </button>
                <button class="touch-btn" data-action="fullscreen" data-key="F">
                    <span class="touch-btn-icon">⛶</span>
                    <span class="touch-btn-label">FULL</span>
                </button>
            </div>
        </div>
        
        <!-- Touch bar toggle -->
        <button id="touch-bar-toggle" title="Toggle Controls">⚙️</button>
    </div>

<script type="module">
import { FilesetResolver, HandLandmarker, FaceLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js";

// Objectron for 3D object detection (loaded dynamically for INTEL mode)
let Objectron = null;
let objectronReady = false;

// Load Objectron dynamically when needed
async function loadObjectron() {
    if (objectronReady) return true;
    try {
        // Import MediaPipe Objectron
        const objectronModule = await import('https://cdn.jsdelivr.net/npm/@mediapipe/objectron@0.5/objectron.js');
        Objectron = objectronModule.Objectron;
        objectronReady = true;
        log('OBJECTRON: 3D Detection Module Loaded');
        return true;
    } catch (e) {
        console.warn('Objectron not available, using fallback 3D simulation', e);
        return false;
    }
}

// ========== CAMERA INTRINSICS SYNC ==========
// Sync Three.js camera with webcam parameters for accurate 3D projection
class CameraIntrinsicsSync {
    constructor() {
        this.focalLength = null;
        this.principalPoint = null;
        this.aspectRatio = null;
        this.estimatedFOV = 60; // Default FOV estimate
    }
    
    // Estimate camera intrinsics from video dimensions
    estimateFromVideo(video) {
        if (!video || !video.videoWidth) return;
        
        const width = video.videoWidth;
        const height = video.videoHeight;
        
        this.aspectRatio = width / height;
        
        // Estimate FOV based on common webcam specs
        // Most webcams have 60-90 degree horizontal FOV
        // Use 65 degrees as a reasonable default
        const hFOV = 65 * (Math.PI / 180);
        this.focalLength = (width / 2) / Math.tan(hFOV / 2);
        
        // Principal point at image center
        this.principalPoint = { x: width / 2, y: height / 2 };
        
        // Calculate vertical FOV
        this.estimatedFOV = 2 * Math.atan(height / (2 * this.focalLength)) * (180 / Math.PI);
    }
    
    // Apply intrinsics to Three.js camera
    applyToCamera(camera, video) {
        if (!camera || !video || !video.videoWidth) return;
        
        this.estimateFromVideo(video);
        
        // Update camera with estimated FOV
        camera.fov = this.estimatedFOV;
        camera.aspect = this.aspectRatio;
        camera.updateProjectionMatrix();
    }
    
    // Convert 2D normalized coordinates to 3D ray
    normalizedTo3D(nx, ny, depth = 1) {
        if (!this.focalLength) return { x: 0, y: 0, z: -depth };
        
        // Convert normalized coords to camera space
        const x = (nx - 0.5) * depth * this.aspectRatio;
        const y = -(ny - 0.5) * depth;
        const z = -depth;
        
        return { x, y, z };
    }
}

// Global camera sync instance
const cameraSync = new CameraIntrinsicsSync();

// ========== DETECTION FRAME LIMITER ==========
// Ensure detection doesn't drop below target FPS
class DetectionFrameLimiter {
    constructor(targetFPS = 30) {
        this.targetFPS = targetFPS;
        this.minFrameTime = 1000 / targetFPS;
        this.lastDetectionTime = 0;
        this.frameCount = 0;
        this.fps = 0;
        this.lastFPSUpdate = performance.now();
        this.skipFrames = 0;
        this.adaptiveSkip = 1; // Process every Nth frame
    }
    
    shouldProcess() {
        const now = performance.now();
        const elapsed = now - this.lastDetectionTime;
        
        // Check if enough time has passed
        if (elapsed < this.minFrameTime * this.adaptiveSkip) {
            return false;
        }
        
        this.lastDetectionTime = now;
        this.frameCount++;
        
        // Update FPS calculation every second
        if (now - this.lastFPSUpdate > 1000) {
            this.fps = this.frameCount;
            this.frameCount = 0;
            this.lastFPSUpdate = now;
            
            // Adaptive frame skipping
            if (this.fps < this.targetFPS * 0.8) {
                // Performance is low, increase skip
                this.adaptiveSkip = Math.min(3, this.adaptiveSkip + 0.5);
            } else if (this.fps >= this.targetFPS && this.adaptiveSkip > 1) {
                // Performance is good, decrease skip
                this.adaptiveSkip = Math.max(1, this.adaptiveSkip - 0.25);
            }
        }
        
        return true;
    }
    
    getCurrentFPS() {
        return this.fps;
    }
    
    getAdaptiveSkip() {
        return Math.round(this.adaptiveSkip);
    }
}

/**
 * TACTICAL OS WEB EDITION
 * Core Architecture:
 * 1. AppManager: Orchestrates the loop.
 * 2. VisionSystem: Handles MediaPipe & TFJS.
 * 3. RenderEngine: Handles Canvas 2D & Three.js.
 * 4. ModeController: State machine.
 */

// --- CONFIGURATION ---
const CONFIG = {
    camera: {
        width: { ideal: 1920, min: 1280 },
        height: { ideal: 1080, min: 720 },
        frameRate: { ideal: 60, max: 60 },
        facingMode: "user"
    },
    colors: {
        primary: '#00FFFF',
        secondary: '#00FF00',
        danger: '#FF0055',
        void: '#000000'
    },
    // Configuración de calidad de video para iPhone
    videoQuality: {
        highResMode: true, // Modo alta resolución activado
        smoothingQuality: 'high', // Suavizado de alta calidad
        contrastBoost: 1.1, // Boost de contraste para mayor definición
        brightnessBoost: 1.05, // Boost de brillo
        saturationBoost: 1.1, // Boost de saturación
        sharpnessFilter: true // Filtro de nitidez adicional
    }
};

// Hand connections for MediaPipe (21 landmarks)
const HAND_CONNECTIONS = [
    [0, 1], [1, 2], [2, 3], [3, 4],       // Thumb
    [0, 5], [5, 6], [6, 7], [7, 8],       // Index
    [0, 9], [9, 10], [10, 11], [11, 12],  // Middle
    [0, 13], [13, 14], [14, 15], [15, 16], // Ring
    [0, 17], [17, 18], [18, 19], [19, 20], // Pinky
    [5, 9], [9, 13], [13, 17]              // Palm connections
];

// --- GLOBAL UTILS ---
const log = (msg) => {
    const el = document.getElementById('console-log');
    if (el) {
        el.innerHTML += `> ${msg}<br>`;
        el.scrollTop = el.scrollHeight;
    }
};

// --- VISION SYSTEM (AI) ---
class VisionSystem {
    constructor() {
        this.handLandmarker = null;
        this.faceLandmarker = null;
        this.objectDetector = null;
        this.objectron = null;
        this.objectronCategory = 'Shoe'; // Options: 'Shoe', 'Cup', 'Camera', 'Chair'
        this.lastVideoTime = -1;
        this.results = { hands: null, face: null, objects: [], objects3D: [] };
        this.isLoaded = false;
        this.objectronInitialized = false;
        
        // 3D object tracking state
        this.tracked3DObjects = new Map(); // Track objects across frames
        this.object3DIdCounter = 0;
        
        // Frame limiter for 3D detection optimization
        this.frameLimiter = new DetectionFrameLimiter(30);
        
        // Detection mode for performance tuning
        this.detectionMode = 'balanced'; // 'performance', 'balanced', 'quality'
    }

    async init(updateProgress) {
        try {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
            );
            
            updateProgress(30);
            log("Vision WASM Loaded");

            // Initialize Hands
            this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 2
            });
            updateProgress(60);
            log("Hand Tracking Online");

            // Initialize Face (Lighter model for web)
            this.faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                    delegate: "GPU"
                },
                outputFaceBlendshapes: true,
                runningMode: "VIDEO",
                numFaces: 1
            });
            updateProgress(80);
            log("Biometrics Online");

            // Initialize Object Detection (Coco-SSD)
            if (window.cocoSsd) {
                this.objectDetector = await window.cocoSsd.load();
                updateProgress(95);
                log("Neural Intel Online");
            } else {
                log("WARN: Coco-SSD not found");
                updateProgress(95);
            }
            
            // Try to initialize Objectron for true 3D detection
            this.initObjectron();
            
            updateProgress(100);
            this.isLoaded = true;

        } catch (e) {
            console.error(e);
            log("CRITICAL ERROR IN AI SUBSYSTEM: " + e.message);
        }
    }
    
    // Initialize Objectron for 3D object detection
    async initObjectron() {
        try {
            // Check if Objectron is available
            if (typeof Objectron !== 'undefined' && Objectron) {
                this.objectron = new Objectron({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/objectron@0.5/${file}`;
                    }
                });
                
                this.objectron.setOptions({
                    modelName: this.objectronCategory,
                    maxNumObjects: 5,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                this.objectron.onResults((results) => this.onObjectronResults(results));
                
                this.objectronInitialized = true;
                log('OBJECTRON: 3D Detection Ready');
            } else {
                log('OBJECTRON: Using simulated 3D (real Objectron not available)');
                this.objectronInitialized = false;
            }
        } catch (e) {
            console.warn('Objectron initialization failed:', e);
            this.objectronInitialized = false;
        }
    }
    
    // Process Objectron 3D results
    onObjectronResults(results) {
        if (!results.objectDetections) {
            this.results.objects3D = [];
            return;
        }
        
        const objects3D = [];
        
        results.objectDetections.forEach((detection, index) => {
            // Get the 8 keypoints (vertices) of the 3D bounding box
            const keypoints = detection.keypoints;
            
            if (keypoints && keypoints.length >= 8) {
                const obj3D = {
                    id: this.getOrCreateObject3DId(detection, index),
                    category: this.objectronCategory,
                    confidence: detection.score || 0.8,
                    // 8 vertices of 3D bounding box
                    vertices: keypoints.slice(0, 8).map(kp => ({
                        x: kp.x,
                        y: kp.y,
                        z: kp.z || 0,
                        visibility: kp.visibility || 1
                    })),
                    // Center point (keypoint 8 in Objectron)
                    center: keypoints[8] ? {
                        x: keypoints[8].x,
                        y: keypoints[8].y,
                        z: keypoints[8].z || 0
                    } : this.calculateCenter(keypoints),
                    // Rotation and scale from landmarks
                    rotation: this.calculateRotation(keypoints),
                    scale: this.calculateScale(keypoints),
                    // Tracking state
                    scanProgress: this.updateScanProgress(detection, index),
                    isNew: !this.tracked3DObjects.has(detection.id || index),
                    framesSeen: this.getFramesSeen(detection, index)
                };
                
                objects3D.push(obj3D);
            }
        });
        
        this.results.objects3D = objects3D;
    }
    
    // Generate simulated 3D bounding box from 2D detection
    simulate3DBoundingBox(obj2D, index) {
        const [x, y, width, height] = obj2D.bbox;
        
        // Estimate depth based on object size (larger = closer)
        const estimatedDepth = Math.max(0.3, Math.min(3.0, 500 / Math.sqrt(width * height)));
        
        // Calculate normalized coordinates
        const nx = x / this.videoWidth;
        const ny = y / this.videoHeight;
        const nw = width / this.videoWidth;
        const nh = height / this.videoHeight;
        
        // Generate 8 vertices for a 3D box (front face then back face)
        const depthOffset = 0.1 * estimatedDepth;
        
        const vertices = [
            // Front face (z = 0)
            { x: nx, y: ny + nh, z: 0 },
            { x: nx + nw, y: ny + nh, z: 0 },
            { x: nx + nw, y: ny, z: 0 },
            { x: nx, y: ny, z: 0 },
            // Back face (z = depth)
            { x: nx, y: ny + nh, z: depthOffset },
            { x: nx + nw, y: ny + nh, z: depthOffset },
            { x: nx + nw, y: ny, z: depthOffset },
            { x: nx, y: ny, z: depthOffset }
        ];
        
        // Add slight rotation based on screen position
        const screenCenterX = 0.5;
        const objectCenterX = nx + nw / 2;
        const rotationY = (objectCenterX - screenCenterX) * 0.3;
        
        // Apply perspective rotation
        vertices.forEach(v => {
            const cosY = Math.cos(rotationY);
            const sinY = Math.sin(rotationY);
            const newX = v.x * cosY - v.z * sinY;
            const newZ = v.x * sinY + v.z * cosY;
            v.x = newX;
            v.z = newZ;
        });
        
        // Stable ID based on class and index (not coordinates)
        // This prevents duplicate boxes when object moves slightly
        return {
            id: `${obj2D.class}_${index}`,
            category: obj2D.class,
            confidence: obj2D.score,
            vertices: vertices,
            center: {
                x: nx + nw / 2,
                y: ny + nh / 2,
                z: depthOffset / 2
            },
            rotation: { x: 0, y: rotationY, z: 0 },
            scale: { x: nw, y: nh, z: depthOffset },
            depth: estimatedDepth,
            bbox2D: obj2D.bbox,
            isSimulated: true,
            scanProgress: 100,
            framesSeen: 1
        };
    }
    
    calculateCenter(keypoints) {
        const sum = keypoints.reduce((acc, kp) => ({
            x: acc.x + kp.x,
            y: acc.y + kp.y,
            z: acc.z + (kp.z || 0)
        }), { x: 0, y: 0, z: 0 });
        
        return {
            x: sum.x / keypoints.length,
            y: sum.y / keypoints.length,
            z: sum.z / keypoints.length
        };
    }
    
    calculateRotation(keypoints) {
        // Calculate rotation from 3D box orientation
        if (keypoints.length < 4) return { x: 0, y: 0, z: 0 };
        
        // Use front face to determine rotation
        const v1 = { x: keypoints[1].x - keypoints[0].x, y: keypoints[1].y - keypoints[0].y };
        const v2 = { x: keypoints[3].x - keypoints[0].x, y: keypoints[3].y - keypoints[0].y };
        
        const angleZ = Math.atan2(v1.y, v1.x);
        const angleX = Math.atan2(v2.y, v2.x) - Math.PI / 2;
        
        return { x: angleX, y: 0, z: angleZ };
    }
    
    calculateScale(keypoints) {
        if (keypoints.length < 8) return { x: 1, y: 1, z: 1 };
        
        // Calculate dimensions from vertices
        const width = Math.hypot(keypoints[1].x - keypoints[0].x, keypoints[1].y - keypoints[0].y);
        const height = Math.hypot(keypoints[3].x - keypoints[0].x, keypoints[3].y - keypoints[0].y);
        const depth = Math.hypot(
            (keypoints[4].x - keypoints[0].x),
            (keypoints[4].y - keypoints[0].y),
            ((keypoints[4].z || 0) - (keypoints[0].z || 0))
        );
        
        return { x: width, y: height, z: depth || 0.1 };
    }
    
    getOrCreateObject3DId(detection, index) {
        const key = detection.id || `obj_${index}`;
        if (!this.tracked3DObjects.has(key)) {
            this.tracked3DObjects.set(key, {
                id: this.object3DIdCounter++,
                firstSeen: performance.now(),
                frameCount: 0,
                scanProgress: 0
            });
        }
        return this.tracked3DObjects.get(key).id;
    }
    
    updateScanProgress(detection, index) {
        const key = detection.id || `obj_${index}`;
        const tracked = this.tracked3DObjects.get(key);
        if (tracked) {
            tracked.frameCount++;
            tracked.scanProgress = Math.min(100, tracked.frameCount * 5);
            return tracked.scanProgress;
        }
        return 0;
    }
    
    getFramesSeen(detection, index) {
        const key = detection.id || `obj_${index}`;
        const tracked = this.tracked3DObjects.get(key);
        return tracked ? tracked.frameCount : 1;
    }
    
    // Store video dimensions for coordinate conversion
    setVideoDimensions(width, height) {
        this.videoWidth = width;
        this.videoHeight = height;
    }

    async detect(video, mode) {
        if (!this.isLoaded || video.currentTime === this.lastVideoTime) return;
        this.lastVideoTime = video.currentTime;
        
        // Store video dimensions
        this.setVideoDimensions(video.videoWidth, video.videoHeight);
        
        // Update camera intrinsics sync for accurate 3D projection
        if (mode === 'INTEL' && video.videoWidth) {
            cameraSync.estimateFromVideo(video);
        }

        // Hands tracking is ALWAYS active (except STANDBY)
        const needsHands = mode !== 'STANDBY';
        // Face tracking only in FACE mode
        const needsFace = mode === 'FACE';
        const needsObjects = mode === 'INTEL';

        if (needsHands && this.handLandmarker) {
            this.results.hands = this.handLandmarker.detectForVideo(video, performance.now());
        } else {
            this.results.hands = null;
        }

        if (needsFace && this.faceLandmarker) {
            this.results.face = this.faceLandmarker.detectForVideo(video, performance.now());
        } else {
            this.results.face = null;
        }

        if (needsObjects) {
            // Use frame limiter to maintain target FPS
            if (!this.frameLimiter.shouldProcess()) {
                return; // Skip this frame to maintain performance
            }
            
            // Try Objectron first for true 3D detection
            if (this.objectronInitialized && this.objectron) {
                try {
                    await this.objectron.send({ image: video });
                } catch (e) {
                    // Fallback to 2D detection with simulated 3D
                    this.detect2DWithSimulated3D(video, mode);
                }
            } else if (this.objectDetector) {
                // Use Coco-SSD with simulated 3D boxes
                this.detect2DWithSimulated3D(video, mode);
            }
        } else {
            this.results.objects3D = [];
        }
    }
    
    // Get current detection FPS
    getDetectionFPS() {
        return this.frameLimiter.getCurrentFPS();
    }
    
    // Set detection quality mode
    setDetectionMode(mode) {
        this.detectionMode = mode;
        switch (mode) {
            case 'performance':
                this.frameLimiter = new DetectionFrameLimiter(20);
                break;
            case 'balanced':
                this.frameLimiter = new DetectionFrameLimiter(30);
                break;
            case 'quality':
                this.frameLimiter = new DetectionFrameLimiter(45);
                break;
        }
    }
    
    // 2D detection with simulated 3D bounding boxes
    async detect2DWithSimulated3D(video, mode) {
        if (!this.objectDetector) return;
        
        try {
            const predictions = await this.objectDetector.detect(video);
            
            // Filter predictions
            const filtered = predictions.filter(pred => pred.score > 0.25);
            
            // Add size-based prioritization
            filtered.forEach(pred => {
                const [predX, predY, predWidth, predHeight] = pred.bbox;
                pred.area = predWidth * predHeight;
                pred.size = Math.sqrt(pred.area);
            });
            
            this.results.objects = filtered;
            
            // Generate simulated 3D boxes for each detection
            // Use index for stable IDs to prevent duplicate boxes
            this.results.objects3D = filtered.map((obj, index) => this.simulate3DBoundingBox(obj, index));
            
            // Update tracking for objects that disappeared
            this.cleanupTrackedObjects();
            
        } catch (e) {
            console.warn('2D detection error:', e);
        }
    }
    
    cleanupTrackedObjects() {
        const now = performance.now();
        const maxAge = 2000; // 2 seconds
        
        for (const [key, tracked] of this.tracked3DObjects) {
            if (now - tracked.lastSeen > maxAge) {
                this.tracked3DObjects.delete(key);
            }
        }
    }
}

// ========== HAND PARTICLE SYSTEM (Micro-partículas desintegrando landmarks) ==========
class HandParticleSystem {
    constructor(scene, camera, renderer) {
        this.scene = scene;
        this.camera = camera;
        this.renderer = renderer;
        
        // Configuración de partículas
        this.particlesPerLandmark = 12; // K partículas por landmark
        this.maxParticles = 21 * 2 * this.particlesPerLandmark; // 21 landmarks * 2 manos * K
        this.particles = [];
        this.particleGroups = new Map(); // Por hand+landmark
        
        // Flow field (ruido curl/simplex)
        this.flowTime = 0;
        this.flowScale = 0.02;
        this.flowStrength = 0.5;
        
        // Gestos activos
        this.activeGestures = {
            pinch: null,
            spread: null,
            swipe: null
        };
        
        // InstancedMesh para rendimiento
        this.particleGeometry = new THREE.BufferGeometry();
        this.particleMaterial = null;
        this.particleMesh = null;
        this.initParticleSystem();
    }
    
    initParticleSystem() {
        // Crear geometría de puntos
        const positions = new Float32Array(this.maxParticles * 3);
        const colors = new Float32Array(this.maxParticles * 3);
        const sizes = new Float32Array(this.maxParticles);
        const phases = new Float32Array(this.maxParticles);
        const seeds = new Float32Array(this.maxParticles);
        
        // Inicializar arrays
        for (let i = 0; i < this.maxParticles; i++) {
            positions[i * 3] = 0;
            positions[i * 3 + 1] = 0;
            positions[i * 3 + 2] = 0;
            colors[i * 3] = 0;
            colors[i * 3 + 1] = 1;
            colors[i * 3 + 2] = 1;
            sizes[i] = 2;
            phases[i] = Math.random() * Math.PI * 2;
            seeds[i] = Math.random();
        }
        
        this.particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        this.particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        this.particleGeometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
        this.particleGeometry.setAttribute('seed', new THREE.BufferAttribute(seeds, 1));
        
        // Shader material para partículas con estelas y pulso
        this.particleMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                pixelRatio: { value: window.devicePixelRatio }
            },
            vertexShader: `
                attribute float size;
                attribute float phase;
                attribute float seed;
                attribute vec3 color;
                uniform float time;
                uniform float pixelRatio;
                varying vec3 vColor;
                varying float vLife;
                
                void main() {
                    vColor = color;
                    vLife = sin(time * 2.0 + phase + seed * 10.0) * 0.5 + 0.5;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * pixelRatio * (300.0 / -mvPosition.z) * (0.5 + vLife * 0.5);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vLife;
                
                void main() {
                    vec2 center = gl_PointCoord - vec2(0.5);
                    float dist = length(center);
                    
                    // Círculo suave con brillo
                    float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                    alpha *= vLife;
                    
                    // Estela radial
                    float trail = 1.0 - dist * 2.0;
                    trail = max(0.0, trail);
                    
                    gl_FragColor = vec4(vColor, alpha * trail);
                }
            `,
            transparent: true,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        
        this.particleMesh = new THREE.Points(this.particleGeometry, this.particleMaterial);
        this.particleMesh.frustumCulled = false;
        this.scene.add(this.particleMesh);
    }
    
    // Simplex noise aproximado (simplificado)
    simplexNoise(x, y, t) {
        const n1 = Math.sin(x * 12.9898 + y * 78.233 + t) * 43758.5453;
        return (n1 - Math.floor(n1)) * 2.0 - 1.0;
    }
    
    // Curl noise para flow field
    curlNoise(x, y, t) {
        const eps = 0.01;
        const n1 = this.simplexNoise(x, y, t);
        const n2 = this.simplexNoise(x + eps, y, t);
        const n3 = this.simplexNoise(x, y + eps, t);
        
        return {
            x: (n3 - n1) / eps,
            y: -(n2 - n1) / eps
        };
    }
    
    // Actualizar partículas basado en landmarks
    update(hands, deltaTime, gestureState) {
        if (!hands || !hands.landmarks) return;
        
        this.flowTime += deltaTime * 0.5;
        this.particleMaterial.uniforms.time.value = this.flowTime;
        
        const positions = this.particleGeometry.attributes.position.array;
        const colors = this.particleGeometry.attributes.color.array;
        const sizes = this.particleGeometry.attributes.size.array;
        const phases = this.particleGeometry.attributes.phase.array;
        
        let particleIndex = 0;
        
        // Procesar cada mano
        for (let handIdx = 0; handIdx < Math.min(hands.landmarks.length, 2); handIdx++) {
            const landmarks = hands.landmarks[handIdx];
            if (!landmarks || landmarks.length < 21) continue;
            
            // Calcular velocidad promedio de la mano
            const palmCenter = {
                x: (landmarks[0].x + landmarks[5].x + landmarks[17].x) / 3,
                y: (landmarks[0].y + landmarks[5].y + landmarks[17].y) / 3
            };
            
            // Procesar cada landmark
            for (let lmIdx = 0; lmIdx < 21; lmIdx++) {
                const landmark = landmarks[lmIdx];
                if (!landmark) continue;
                
                const key = `h${handIdx}_l${lmIdx}`;
                
                // Obtener o crear grupo de partículas para este landmark
                if (!this.particleGroups.has(key)) {
                    this.particleGroups.set(key, {
                        anchor: { x: landmark.x, y: landmark.y, z: landmark.z || 0 },
                        particles: []
                    });
                }
                
                const group = this.particleGroups.get(key);
                
                // Actualizar anchor
                group.anchor.x = landmark.x;
                group.anchor.y = landmark.y;
                group.anchor.z = landmark.z || 0;
                
                // Calcular confianza/estabilidad (simplificado)
                const confidence = 1.0; // Podrías calcular esto basado en jitter
                
                // Spawn/update partículas para este landmark
                const targetParticles = this.particlesPerLandmark;
                
                // Asegurar que tenemos suficientes partículas
                while (group.particles.length < targetParticles && particleIndex < this.maxParticles) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = (Math.random() * 0.02 + 0.01);
                    group.particles.push({
                        offsetX: Math.cos(angle) * radius,
                        offsetY: Math.sin(angle) * radius,
                        phase: Math.random() * Math.PI * 2,
                        seed: Math.random(),
                        life: 1.0,
                        velX: 0,
                        velY: 0
                    });
                }
                
                // Actualizar partículas
                for (let pIdx = 0; pIdx < group.particles.length && particleIndex < this.maxParticles; pIdx++) {
                    const p = group.particles[pIdx];
                    
                    // Posición del landmark en espacio 3D (normalizado a pantalla)
                    const screenX = (1 - landmark.x) * 2 - 1;
                    const screenY = -(landmark.y * 2 - 1);
                    const depth = -(landmark.z || 0) * 2;
                    
                    // Flow field
                    const flowX = landmark.x * this.flowScale;
                    const flowY = landmark.y * this.flowScale;
                    const flow = this.curlNoise(flowX, flowY, this.flowTime);
                    
                    // Fuerza de resorte hacia el anchor
                    const springStrength = 0.1;
                    const springX = -p.offsetX * springStrength;
                    const springY = -p.offsetY * springStrength;
                    
                    // Viento de velocidad del landmark (si se mueve rápido)
                    const windStrength = Math.min(1.0, Math.abs(flow.x) + Math.abs(flow.y)) * 0.05;
                    
                    // Combinar fuerzas: flow cuando quieto, velocidad cuando se mueve
                    const handSpeed = Math.sqrt(flow.x * flow.x + flow.y * flow.y);
                    const flowMix = handSpeed < 0.01 ? 1.0 : 0.3; // Flow domina cuando quieto
                    
                    p.velX += (flow.x * this.flowStrength * flowMix + springX) * deltaTime;
                    p.velY += (flow.y * this.flowStrength * flowMix + springY) * deltaTime;
                    
                    // Aplicar velocidad
                    p.offsetX += p.velX * deltaTime * 10;
                    p.offsetY += p.velY * deltaTime * 10;
                    
                    // Amortiguación
                    p.velX *= 0.95;
                    p.velY *= 0.95;
                    
                    // Efectos de gestos
                    if (gestureState.pinch && gestureState.pinch.handIdx === handIdx) {
                        // Colapsar hacia punto de pinch
                        const pinchX = gestureState.pinch.x - landmark.x;
                        const pinchY = gestureState.pinch.y - landmark.y;
                        const dist = Math.sqrt(pinchX * pinchX + pinchY * pinchY);
                        if (dist > 0) {
                            p.velX += (pinchX / dist) * 0.2 * deltaTime;
                            p.velY += (pinchY / dist) * 0.2 * deltaTime;
                        }
                        p.life = Math.min(1.0, p.life + 0.1); // Brillo alto
                    }
                    
                    if (gestureState.swipe && gestureState.swipe.handIdx === handIdx) {
                        // Reorganizar siguiendo línea de swipe
                        const swipeDirX = Math.cos(gestureState.swipe.angle);
                        const swipeDirY = Math.sin(gestureState.swipe.angle);
                        p.velX += swipeDirX * 0.15 * deltaTime;
                        p.velY += swipeDirY * 0.15 * deltaTime;
                    }
                    
                    // Pulso según confianza
                    const pulse = Math.sin(this.flowTime * 2.0 + p.phase + p.seed * 10.0) * 0.3 + 0.7;
                    p.life = confidence * pulse;
                    
                    // Actualizar buffers
                    const worldX = screenX + p.offsetX * 2;
                    const worldY = screenY + p.offsetY * 2;
                    const worldZ = depth;
                    
                    positions[particleIndex * 3] = worldX;
                    positions[particleIndex * 3 + 1] = worldY;
                    positions[particleIndex * 3 + 2] = worldZ;
                    
                    // Color basado en energía/velocidad
                    const energy = Math.min(1.0, Math.sqrt(p.velX * p.velX + p.velY * p.velY) * 10);
                    colors[particleIndex * 3] = 0.0 + energy * 0.5; // R
                    colors[particleIndex * 3 + 1] = 1.0; // G (cian)
                    colors[particleIndex * 3 + 2] = 1.0 - energy * 0.3; // B
                    
                    sizes[particleIndex] = 2 + energy * 3;
                    phases[particleIndex] = p.phase;
                    
                    particleIndex++;
                }
            }
        }
        
        // Ocultar partículas no usadas
        for (let i = particleIndex; i < this.maxParticles; i++) {
            positions[i * 3 + 2] = -1000; // Mover fuera de vista
        }
        
        // Marcar como actualizado
        this.particleGeometry.attributes.position.needsUpdate = true;
        this.particleGeometry.attributes.color.needsUpdate = true;
        this.particleGeometry.attributes.size.needsUpdate = true;
    }
}

// ========== HAND MAP RENDERER (Topografía + Heatmap) ==========
class HandMapRenderer {
    constructor(canvas, ctx, scene, camera, handMapCanvas = null) {
        this.canvas = canvas;
        this.ctx = ctx;
        this.scene = scene;
        this.camera = camera;
        this.handMapCanvas = handMapCanvas; // Canvas HTML del panel
        
        // Canvas offscreen para el mapa
        this.mapCanvas = document.createElement('canvas');
        this.mapCanvas.width = 512;
        this.mapCanvas.height = 512;
        this.mapCtx = this.mapCanvas.getContext('2d');
        
        // Textura y material para el mapa
        this.mapTexture = new THREE.CanvasTexture(this.mapCanvas);
        this.mapTexture.minFilter = THREE.LinearFilter;
        this.mapTexture.magFilter = THREE.LinearFilter;
        this.mapTexture.needsUpdate = true;
        
        // Plano para mostrar el mapa (HUD) - renderizado en 2D canvas overlay en lugar de 3D
        // El mapa se renderiza directamente en el canvas 2D como overlay
        this.mapVisible = false;
        
        // Estado del escáner
        this.scannerProgress = 0;
        this.scannerDirection = 1;
        this.lastUpdate = 0;
        
        // Energía por dedo
        this.fingerEnergy = new Map();
        this.palmPulse = 0;
    }
    
    // Calcular energía de un dedo (velocidad del tip)
    calculateFingerEnergy(landmarks, fingerTips) {
        const energy = {};
        const now = performance.now();
        
        for (const tipIdx of fingerTips) {
            const tip = landmarks[tipIdx];
            if (!tip) continue;
            
            const key = `tip_${tipIdx}`;
            if (!this.fingerEnergy.has(key)) {
                this.fingerEnergy.set(key, { x: tip.x, y: tip.y, lastTime: now });
                energy[tipIdx] = 0;
                continue;
            }
            
            const prev = this.fingerEnergy.get(key);
            const dt = (now - prev.lastTime) / 1000;
            if (dt > 0) {
                const dx = tip.x - prev.x;
                const dy = tip.y - prev.y;
                const speed = Math.sqrt(dx * dx + dy * dy) / dt;
                energy[tipIdx] = Math.min(1.0, speed * 10);
                
                prev.x = tip.x;
                prev.y = tip.y;
                prev.lastTime = now;
            } else {
                energy[tipIdx] = 0;
            }
        }
        
        return energy;
    }
    
    // Dibujar mapa de mano en canvas offscreen
    renderHandMap(hands, deltaTime, gestureState = null) {
        // Guardar gestureState para usar en el renderizado
        this.currentGestureState = gestureState;
        const ctx = this.mapCtx;
        const w = this.mapCanvas.width;
        const h = this.mapCanvas.height;
        
        // Si no hay manos, limpiar completamente el canvas
        if (!hands || !hands.landmarks || hands.landmarks.length === 0) {
            ctx.clearRect(0, 0, w, h);
            // También limpiar el canvas HTML del panel si existe
            if (this.handMapCanvas && this.handMapCanvas.width > 0) {
                const handMapCtx = this.handMapCanvas.getContext('2d');
                if (handMapCtx) {
                    handMapCtx.clearRect(0, 0, this.handMapCanvas.width, this.handMapCanvas.height);
                }
            }
            this.mapTexture.needsUpdate = true;
            return;
        }
        
        // Limpiar con fade solo cuando hay manos (para efecto de rastro)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, w, h);
        
        // Procesar todas las manos (hasta 2)
        const maxHands = Math.min(hands.landmarks.length, 2);
        
        for (let handIdx = 0; handIdx < maxHands; handIdx++) {
            const landmarks = hands.landmarks[handIdx];
            if (!landmarks || landmarks.length < 21) continue;
            
            // Calcular energía de dedos
            const fingerTips = [4, 8, 12, 16, 20]; // Thumb, Index, Middle, Ring, Pinky
            const fingerEnergy = this.calculateFingerEnergy(landmarks, fingerTips);
            
            // Calcular pulso de palma
            const palmCenter = {
                x: (landmarks[0].x + landmarks[5].x + landmarks[17].x) / 3,
                y: (landmarks[0].y + landmarks[5].y + landmarks[17].y) / 3
            };
            this.palmPulse = Math.sin(performance.now() * 0.002) * 0.5 + 0.5;
            
            // Color diferente para cada mano (primera mano: cyan, segunda mano: magenta)
            const handColor = handIdx === 0 ? 'rgba(0, 255, 255' : 'rgba(255, 0, 255';
            const handColorFull = handIdx === 0 ? 'rgba(0, 255, 255' : 'rgba(255, 0, 255';
            
            // Dibujar SDF/blur del esqueleto
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            
            // Dibujar conexiones con blur
            ctx.strokeStyle = `${handColor}, 0.3)`;
            ctx.lineWidth = 3;
            ctx.shadowBlur = 10;
            ctx.shadowColor = `${handColor}, 0.5)`;
            
            for (const [idx1, idx2] of HAND_CONNECTIONS) {
                const p1 = landmarks[idx1];
                const p2 = landmarks[idx2];
                if (!p1 || !p2) continue;
                
                const x1 = (1 - p1.x) * w;
                const y1 = p1.y * h;
                const x2 = (1 - p2.x) * w;
                const y2 = p2.y * h;
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            // Dibujar landmarks como puntos calientes
            for (let i = 0; i < landmarks.length; i++) {
                const lm = landmarks[i];
                if (!lm) continue;
                
                const x = (1 - lm.x) * w;
                const y = lm.y * h;
                
                // Calor basado en energía si es un tip
                let heat = 0.3;
                if (fingerTips.includes(i)) {
                    heat = 0.5 + fingerEnergy[i] * 0.5;
                }
                
                const radius = 5 + heat * 10;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                
                if (handIdx === 0) {
                    // Primera mano: cyan/amarillo
                    gradient.addColorStop(0, `rgba(255, ${Math.floor(255 * heat)}, 0, ${0.8 * heat})`);
                    gradient.addColorStop(0.5, `rgba(0, 255, 255, ${0.4 * heat})`);
                } else {
                    // Segunda mano: magenta/rosa
                    gradient.addColorStop(0, `rgba(255, ${Math.floor(100 * heat)}, ${Math.floor(255 * heat)}, ${0.8 * heat})`);
                    gradient.addColorStop(0.5, `rgba(255, 0, 255, ${0.4 * heat})`);
                }
                gradient.addColorStop(1, `${handColor}, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Isolíneas (marching squares aproximado)
            ctx.strokeStyle = `${handColor}, 0.2)`;
            ctx.lineWidth = 1;
            ctx.shadowBlur = 0;
            
            // Dibujar múltiples contornos con distintos umbrales
            for (let level = 0.3; level <= 0.9; level += 0.2) {
                ctx.globalAlpha = level * 0.3;
                this.drawIsoline(ctx, landmarks, w, h, level);
            }
            
            ctx.restore();
        }
        
        // Scanner line
        this.scannerProgress += deltaTime * this.scannerDirection * 0.3;
        if (this.scannerProgress > 1) {
            this.scannerProgress = 1;
            this.scannerDirection = -1;
        } else if (this.scannerProgress < 0) {
            this.scannerProgress = 0;
            this.scannerDirection = 1;
        }
        
        const scanY = this.scannerProgress * h;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, scanY);
        ctx.lineTo(w, scanY);
        ctx.stroke();
        
        // Glitch cuando hay jitter (simplificado)
        if (Math.random() < 0.05) {
            ctx.fillStyle = 'rgba(255, 0, 85, 0.3)';
            ctx.fillRect(Math.random() * w, Math.random() * h, 10, 10);
        }
        
        // Efectos de gestos en el mapa
        if (this.currentGestureState && this.currentGestureState.spread) {
            // Anillos concéntricos desde la palma cuando hay spread
            const centerX = (1 - this.currentGestureState.spread.center.x) * w;
            const centerY = this.currentGestureState.spread.center.y * h;
            const ringCount = 5;
            const maxRadius = Math.min(w, h) * 0.3;
            
            for (let i = 0; i < ringCount; i++) {
                const radius = (maxRadius / ringCount) * (i + 1);
                const alpha = 0.3 * (1 - i / ringCount);
                ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // Renderizar cubo de energía (estrella en forma de cubo) cuando está activo
        if (window.app && window.app.cubeActive && window.app.engine) {
            const cubePos = window.app.engine.cubeBasePosition;
            const cubeScale = window.app.engine.cubeBaseScale || 1.0;
            
            if (cubePos) {
                // Mapear posición 3D del cubo a coordenadas 2D del mapa
                // El cubo se mueve en rango aproximado: X: -4 a 4, Y: -3 a 3
                const cubeX = ((cubePos.x + 4) / 8) * w;  // Mapear -4..4 a 0..width
                // Invertir Y para que coincida con el movimiento (Y positivo en 3D = arriba, pero en canvas Y positivo = abajo)
                const cubeY = (1 - (cubePos.y + 3) / 6) * h;  // Mapear -3..3 a height..0 (invertido)
                
                const time = performance.now() * 0.005;
                const pulse = Math.sin(time * 4) * 0.4 + 0.6;
                const energyPulse = Math.sin(time * 6) * 0.3 + 0.7;
                
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                
                // Efecto de estrella de energía - múltiples capas de brillo
                const starLayers = 8;
                for (let layer = 0; layer < starLayers; layer++) {
                    const layerSize = (15 + cubeScale * 10) * (1 + layer * 0.3);
                    const layerAlpha = (0.8 / starLayers) * (starLayers - layer) * pulse;
                    
                    // Gradiente radial para efecto de energía
                    const gradient = ctx.createRadialGradient(
                        cubeX, cubeY, 0,
                        cubeX, cubeY, layerSize
                    );
                    
                    // Colores de energía (cyan brillante con toques de blanco)
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${layerAlpha * energyPulse})`);
                    gradient.addColorStop(0.3, `rgba(0, 255, 255, ${layerAlpha * 0.8})`);
                    gradient.addColorStop(0.6, `rgba(0, 200, 255, ${layerAlpha * 0.5})`);
                    gradient.addColorStop(1, `rgba(0, 255, 255, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(cubeX, cubeY, layerSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Dibujar cubo como estrella de energía - vértices brillantes
                const vertices = [
                    [-0.5, -0.5, -0.5], [0.5, -0.5, -0.5], [0.5, 0.5, -0.5], [-0.5, 0.5, -0.5], // Cara frontal
                    [-0.5, -0.5, 0.5], [0.5, -0.5, 0.5], [0.5, 0.5, 0.5], [-0.5, 0.5, 0.5]    // Cara trasera
                ];
                
                // Rotación animada
                const rotX = time * 0.5;
                const rotY = time * 0.3;
                const rotZ = time * 0.2;
                
                const projectedVertices = vertices.map(vertex => {
                    let [x, y, z] = vertex;
                    
                    // Aplicar rotación
                    const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
                    const cosY = Math.cos(rotY), sinY = Math.sin(rotY);
                    const cosZ = Math.cos(rotZ), sinZ = Math.sin(rotZ);
                    
                    // Rotar alrededor de Y
                    let tempX = x * cosY - z * sinY;
                    let tempZ = x * sinY + z * cosY;
                    x = tempX;
                    z = tempZ;
                    
                    // Rotar alrededor de X
                    let tempY = y * cosX - z * sinX;
                    tempZ = y * sinX + z * cosX;
                    y = tempY;
                    z = tempZ;
                    
                    // Proyección perspectiva simple
                    const scale = 2 / (2 + z);
                    const screenX = cubeX + x * scale * (15 * cubeScale);
                    const screenY = cubeY + y * scale * (15 * cubeScale);
                    
                    return { x: screenX, y: screenY, z: z, scale: scale };
                });
                
                // Dibujar vértices como puntos de energía brillantes
                projectedVertices.forEach((v, index) => {
                    const size = (3 + cubeScale * 2) * v.scale * pulse;
                    const alpha = Math.max(0.6, v.scale * pulse * energyPulse);
                    
                    // Gradiente para cada vértice
                    const vertexGradient = ctx.createRadialGradient(v.x, v.y, 0, v.x, v.y, size * 2);
                    vertexGradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                    vertexGradient.addColorStop(0.5, `rgba(0, 255, 255, ${alpha * 0.8})`);
                    vertexGradient.addColorStop(1, `rgba(0, 255, 255, 0)`);
                    
                    ctx.fillStyle = vertexGradient;
                    ctx.beginPath();
                    ctx.arc(v.x, v.y, size * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Punto central brillante
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(v.x, v.y, size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Dibujar aristas del cubo como líneas de energía
                const edges = [
                    [0, 1], [1, 2], [2, 3], [3, 0], // Cara frontal
                    [4, 5], [5, 6], [6, 7], [7, 4], // Cara trasera
                    [0, 4], [1, 5], [2, 6], [3, 7]  // Aristas conectivas
                ];
                
                ctx.strokeStyle = `rgba(0, 255, 255, ${0.6 * pulse})`;
                ctx.lineWidth = 1.5;
                ctx.shadowBlur = 5;
                ctx.shadowColor = 'rgba(0, 255, 255, 0.8)';
                
                edges.forEach(([i1, i2]) => {
                    const v1 = projectedVertices[i1];
                    const v2 = projectedVertices[i2];
                    
                    ctx.beginPath();
                    ctx.moveTo(v1.x, v1.y);
                    ctx.lineTo(v2.x, v2.y);
                    ctx.stroke();
                });
                
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }
        
        // Actualizar textura
        this.mapTexture.needsUpdate = true;
    }
    
    // Dibujar isolínea aproximada
    drawIsoline(ctx, landmarks, w, h, threshold) {
        // Simplificado: dibujar círculos alrededor de puntos calientes
        const fingerTips = [4, 8, 12, 16, 20];
        for (const tipIdx of fingerTips) {
            const tip = landmarks[tipIdx];
            if (!tip) continue;
            
            const x = (1 - tip.x) * w;
            const y = tip.y * h;
            const radius = 30 + threshold * 40;
            
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // También dibujar contorno alrededor de la palma
        if (landmarks[0] && landmarks[5] && landmarks[17]) {
            const palmX = (1 - (landmarks[0].x + landmarks[5].x + landmarks[17].x) / 3) * w;
            const palmY = ((landmarks[0].y + landmarks[5].y + landmarks[17].y) / 3) * h;
            const palmRadius = 40 + threshold * 30;
            
            ctx.beginPath();
            ctx.arc(palmX, palmY, palmRadius, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
    
    setVisible(visible) {
        this.mapVisible = visible;
    }
    
    // Renderizar mapa en el canvas HTML del panel (igual que thermal y mocap)
    renderMapOverlay(ctx, canvasWidth, canvasHeight) {
        if (!this.mapVisible) return;
        
        // Si hay canvas HTML del panel, renderizar ahí (igual que los otros mapas)
        if (this.handMapCanvas && this.handMapCanvas.width > 0) {
            const handMapCtx = this.handMapCanvas.getContext('2d');
            if (handMapCtx) {
                // Limpiar canvas
                handMapCtx.clearRect(0, 0, this.handMapCanvas.width, this.handMapCanvas.height);
                
                // Dibujar el mapa escalado al tamaño del canvas (220px × 120px para el área del canvas)
                const canvasWidth = this.handMapCanvas.width;
                const canvasHeight = this.handMapCanvas.height;
                handMapCtx.drawImage(this.mapCanvas, 0, 0, canvasWidth, canvasHeight);
            }
        }
    }
}

// ========== GESTURE DETECTOR (Pinch, Spread, Swipe) ==========
class GestureDetector {
    constructor() {
        this.lastHandPositions = new Map();
        this.gestureState = {
            pinch: null,
            spread: null,
            swipe: null
        };
        this.swipeHistory = [];
    }
    
    detect(hands) {
        if (!hands || !hands.landmarks) {
            this.gestureState = { pinch: null, spread: null, swipe: null };
            return this.gestureState;
        }
        
        const now = performance.now();
        
        // Detectar pinch (pulgar + índice)
        this.gestureState.pinch = this.detectPinch(hands);
        
        // Detectar spread (mano abierta)
        this.gestureState.spread = this.detectSpread(hands);
        
        // Detectar swipe
        this.gestureState.swipe = this.detectSwipe(hands, now);
        
        return this.gestureState;
    }
    
    detectPinch(hands) {
        for (let i = 0; i < hands.landmarks.length; i++) {
            const landmarks = hands.landmarks[i];
            if (!landmarks || landmarks.length < 21) continue;
            
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            
            if (!thumbTip || !indexTip) continue;
            
            const dx = thumbTip.x - indexTip.x;
            const dy = thumbTip.y - indexTip.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 0.05) { // Umbral de pinch
                return {
                    handIdx: i,
                    x: (thumbTip.x + indexTip.x) / 2,
                    y: (thumbTip.y + indexTip.y) / 2,
                    strength: 1.0 - (dist / 0.05)
                };
            }
        }
        return null;
    }
    
    detectSpread(hands) {
        for (let i = 0; i < hands.landmarks.length; i++) {
            const landmarks = hands.landmarks[i];
            if (!landmarks || landmarks.length < 21) continue;
            
            const indexTip = landmarks[8];
            const pinkyTip = landmarks[20];
            
            if (!indexTip || !pinkyTip) continue;
            
            const dx = indexTip.x - pinkyTip.x;
            const dy = indexTip.y - pinkyTip.y;
            const spread = Math.sqrt(dx * dx + dy * dy);
            
            if (spread > 0.15) { // Mano abierta
                return {
                    handIdx: i,
                    spread: spread,
                    center: {
                        x: (indexTip.x + pinkyTip.x) / 2,
                        y: (indexTip.y + pinkyTip.y) / 2
                    }
                };
            }
        }
        return null;
    }
    
    detectSwipe(hands, now) {
        for (let i = 0; i < hands.landmarks.length; i++) {
            const landmarks = hands.landmarks[i];
            if (!landmarks || landmarks.length < 21) continue;
            
            const indexTip = landmarks[8];
            if (!indexTip) continue;
            
            const key = `hand_${i}`;
            const lastPos = this.lastHandPositions.get(key);
            
            if (lastPos) {
                const dx = indexTip.x - lastPos.x;
                const dy = indexTip.y - lastPos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const dt = (now - lastPos.time) / 1000;
                
                if (dt > 0 && dist / dt > 0.3) { // Velocidad alta = swipe
                    const angle = Math.atan2(dy, dx);
                    
                    // Guardar en historial
                    this.swipeHistory.push({ x: indexTip.x, y: indexTip.y, angle, time: now });
                    if (this.swipeHistory.length > 10) {
                        this.swipeHistory.shift();
                    }
                    
                    // Retornar swipe activo por 0.5-1s
                    return {
                        handIdx: i,
                        x: indexTip.x,
                        y: indexTip.y,
                        angle: angle,
                        velocity: dist / dt,
                        startTime: now
                    };
                }
            }
            
            // Actualizar posición
            this.lastHandPositions.set(key, {
                x: indexTip.x,
                y: indexTip.y,
                time: now
            });
        }
        
        // Limpiar swipes antiguos
        const activeSwipe = this.gestureState.swipe;
        if (activeSwipe && now - activeSwipe.startTime > 1000) {
            return null;
        }
        
        return activeSwipe;
    }
}

// --- RENDER ENGINE (Visuals) ---
class RenderEngine {
    constructor() {
        this.canvas = document.getElementById('main-canvas');
        this.ctx = this.canvas.getContext('2d', {
            alpha: false, // Disable alpha for better performance
            desynchronized: true, // Reduce latency
            willReadFrequently: false // Optimize for drawing operations
        });

        // Configure high-quality rendering for iPhone camera
        if (this.ctx) {
            this.ctx.imageSmoothingEnabled = true;
            this.ctx.imageSmoothingQuality = 'high';
        }

        // Mini-canvas setups
        this.thermalCanvas = document.getElementById('thermal-canvas');
        this.thermalCtx = this.thermalCanvas ? this.thermalCanvas.getContext('2d', { willReadFrequently: true }) : null;

        this.mocapCanvas = document.getElementById('mocap-canvas');
        this.mocapCtx = this.mocapCanvas ? this.mocapCanvas.getContext('2d') : null;

        this.handMapCanvas = document.getElementById('hand-map-canvas');
        this.handMapCtx = this.handMapCanvas ? this.handMapCanvas.getContext('2d') : null;

        // Operator panel canvases
        this.radarCanvas = document.getElementById('radar-canvas');
        this.radarCtx = this.radarCanvas ? this.radarCanvas.getContext('2d') : null;

        // Three.js Setup
        this.threeCanvas = document.getElementById('three-canvas');
        this.scene = new THREE.Scene();
        this.camera3D = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer3D = new THREE.WebGLRenderer({ canvas: this.threeCanvas, alpha: true, antialias: true });

        this.resize();
        window.addEventListener('resize', () => this.resize());

        // Effect State
        this.drawPath = []; // For AirDraw

        // Operator panel state
        this.radarAngle = 0;
        this.lastHexUpdate = 0;

        // Touch mode state
        this.touchEffects = [];
        this.touchThreshold = 0.15; // Distance threshold for touch detection
        this.lastFingerPositions = new Map(); // Track finger positions for velocity

        // 3D Objects
        this.cube = null;
        // Cube interaction state
        this.cubeBaseScale = 1.0;
        this.cubeBasePosition = { x: 0, y: 0, z: 0 };
        this.lastPinchDistance = null;
        this.init3D();
    }

    resize() {
        const isMobileView = document.body.classList.contains('mobile-view');
        
        // Use matchMedia for reliable mobile detection
        const isMobileMediaQuery = window.matchMedia('(max-width: 768px)').matches;
        const isSmallScreen = isMobileMediaQuery || window.innerWidth <= 768;
        const isPortrait = window.innerHeight > window.innerWidth;
        const isMobileDevice = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase());
        const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        // Store device info for other systems
        this.isPortraitMode = isPortrait;
        this.isMobileScreen = isSmallScreen || isMobileDevice;
        this.isTouchDevice = hasTouchScreen;
        
        // Calculate safe areas for mobile UI elements
        const topBarHeight = this.isMobileScreen ? 50 : 0;  // Mobile top bar
        const bottomBarHeight = this.isMobileScreen ? 70 : 0;  // Touch bar

        if (isMobileView) {
            // Simulated mobile view: use container dimensions
            const containerWidth = Math.min(400, window.innerWidth);
            const containerHeight = window.innerHeight;

            this.canvas.width = containerWidth;
            this.canvas.height = containerHeight;
            this.renderer3D.setSize(containerWidth, containerHeight);
            this.camera3D.aspect = containerWidth / containerHeight;
            this.camera3D.fov = 75;
        } else if (this.isMobileScreen) {
            // Real mobile device or small screen
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Full viewport for canvas (UI overlays on top)
            this.canvas.width = viewportWidth;
            this.canvas.height = viewportHeight;
            this.renderer3D.setSize(viewportWidth, viewportHeight);
            this.camera3D.aspect = viewportWidth / viewportHeight;
            
            // Adjust FOV based on orientation for better scene visibility
            if (isPortrait) {
                // Portrait: wider FOV to compensate for narrow width
                this.camera3D.fov = 90;
            } else {
                // Landscape: slightly wider than desktop
                this.camera3D.fov = 80;
            }
        } else {
            // Desktop view: full window
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.renderer3D.setSize(window.innerWidth, window.innerHeight);
            this.camera3D.aspect = window.innerWidth / window.innerHeight;
            this.camera3D.fov = 75;
        }

        this.camera3D.updateProjectionMatrix();
        
        // Store main canvas aspect ratio for mini-canvas viewport calculations (mobile)
        this.mainCanvasAspect = this.canvas.width / this.canvas.height;

        // Resize mini-canvases if they exist
        if (this.thermalCanvas) {
            const thermalRect = this.thermalCanvas.getBoundingClientRect();
            if (thermalRect.width > 0 && thermalRect.height > 0) {
                this.thermalCanvas.width = thermalRect.width;
                this.thermalCanvas.height = thermalRect.height;
            }
        }

        if (this.mocapCanvas) {
            const mocapRect = this.mocapCanvas.getBoundingClientRect();
            if (mocapRect.width > 0 && mocapRect.height > 0) {
                this.mocapCanvas.width = mocapRect.width;
                this.mocapCanvas.height = mocapRect.height;
            }
            
            // Hand Map Canvas
            if (this.handMapCanvas) {
                const handMapRect = this.handMapCanvas.getBoundingClientRect();
                if (handMapRect.width > 0 && handMapRect.height > 0) {
                    this.handMapCanvas.width = handMapRect.width;
                    this.handMapCanvas.height = handMapRect.height;
                }
            }
        }

        if (this.radarCanvas) {
            const radarRect = this.radarCanvas.getBoundingClientRect();
            if (radarRect.width > 0 && radarRect.height > 0) {
                this.radarCanvas.width = radarRect.width;
                this.radarCanvas.height = radarRect.height;
            }
        }
    }

    init3D() {
        // Lighting for metallic reflections
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        this.scene.add(ambientLight);
        
        // Main cyan light
        const pointLight1 = new THREE.PointLight(0x00ffff, 2, 100);
        pointLight1.position.set(5, 5, 5);
        this.scene.add(pointLight1);
        
        // Magenta accent light
        const pointLight2 = new THREE.PointLight(0xff0055, 1.5, 100);
        pointLight2.position.set(-5, -3, 3);
        this.scene.add(pointLight2);
        
        // Green accent light
        const pointLight3 = new THREE.PointLight(0x00ff00, 1, 100);
        pointLight3.position.set(0, -5, -5);
        this.scene.add(pointLight3);
        
        // Create cube group
        this.cubeGroup = new THREE.Group();
        
        // Metallic cube with MeshStandardMaterial
        const geometry = new THREE.BoxGeometry(2, 2, 2);
        const metalMaterial = new THREE.MeshStandardMaterial({
            color: 0x888899,
            metalness: 1.0,
            roughness: 0.1,
            envMapIntensity: 1.0
        });
        this.cube = new THREE.Mesh(geometry, metalMaterial);
        this.cubeGroup.add(this.cube);
        
        // Glowing edges
        const edges = new THREE.EdgesGeometry(geometry);
        const edgeMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00ffff,
            transparent: true,
            opacity: 0.8
        });
        this.cubeEdges = new THREE.LineSegments(edges, edgeMaterial);
        this.cubeGroup.add(this.cubeEdges);
        
        // Partículas de energía dentro del cubo
        this.cubeEnergyParticles = [];
        this.cubeParticleVelocities = [];
        const particleCount = 30;
        
        for (let i = 0; i < particleCount; i++) {
            // Crear partícula de energía
            const particleGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const particleMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8,
                emissive: 0x00ffff,
                emissiveIntensity: 1.5,
                metalness: 0.0,
                roughness: 0.1
            });
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            
            // Posición aleatoria dentro del cubo (rango -0.9 a 0.9 para mantenerlas dentro)
            particle.position.set(
                (Math.random() - 0.5) * 1.8,
                (Math.random() - 0.5) * 1.8,
                (Math.random() - 0.5) * 1.8
            );
            
            // Velocidad aleatoria para cada partícula
            this.cubeParticleVelocities.push({
                x: (Math.random() - 0.5) * 0.02,
                y: (Math.random() - 0.5) * 0.02,
                z: (Math.random() - 0.5) * 0.02
            });
            
            // Guardar referencia para animación
            particle.userData = {
                basePosition: particle.position.clone(),
                phase: Math.random() * Math.PI * 2,
                speed: 0.5 + Math.random() * 0.5
            };
            
            this.cubeEnergyParticles.push(particle);
            this.cubeGroup.add(particle);
        }
        
        this.scene.add(this.cubeGroup);
        this.camera3D.position.z = 5;
        this.cubeGroup.visible = false;

        // Sandtable initialization
        this.initSandtable();

        // Store lights for animation
        this.lights = [pointLight1, pointLight2, pointLight3];

        // Initialize touch effect system
        
        // Initialize Hand Particle System & Map Renderer
        this.handParticleSystem = new HandParticleSystem(this.scene, this.camera3D, this.renderer3D);
        this.handMapRenderer = new HandMapRenderer(this.canvas, this.ctx, this.scene, this.camera3D, this.handMapCanvas);
        this.gestureDetector = new GestureDetector();
        this.handParticlesEnabled = true; // Activado por defecto
        try {
            this.initTouchEffects();
        } catch (error) {
            console.warn('Touch effects initialization failed:', error);
            // Continue without touch effects
        }
        
        // Initialize INTEL 3D box system
        this.initIntel3DSystem();
        
        // Initialize CAROUSEL hand FX system
        this.initCarouselHandFX();
    }
    
    // ========== CAROUSEL 3D HAND FX SYSTEM (PREMIUM) ==========
    initCarouselHandFX() {
        // Main group for all carousel hand effects
        this.carouselHandGroup = new THREE.Group();
        this.carouselHandGroup.visible = false;
        this.scene.add(this.carouselHandGroup);
        
        // ========== LANDMARK SMOOTHING STATE (Anti-Jitter EMA Filter) ==========
        this.carouselSmoothing = {
            enabled: true,
            alpha: 0.35,  // EMA factor (0.3-0.4 = responsive but smooth)
            landmarks: {}, // Stores smoothed positions per landmark index
            velocities: {}, // Stores velocity per landmark for prediction
            lastTime: 0
        };
        
        // ========== SWIPE VELOCITY STATE ==========
        this.carouselSwipe = {
            lastIndexX: null,
            lastTime: 0,
            velocity: 0,
            smoothVelocity: 0
        };
        
        // ========== PREMIUM BRACELET SHADER ==========
        this.braceletShaderUniforms = {
            uTime: { value: 0 },
            uGlowIntensity: { value: 1.0 },
            uScanlineSpeed: { value: 2.0 },
            uFresnelPower: { value: 2.5 },
            uNoiseIntensity: { value: 0.03 },
            uSparkDensity: { value: 0.5 },
            uSwipeVelocity: { value: 0.0 },
            uPrimaryColor: { value: new THREE.Color(0x00FFFF) },
            uSecondaryColor: { value: new THREE.Color(0xFF0055) }
        };
        
        // Premium ShaderMaterial for main bracelet
        this.braceletMaterial = new THREE.ShaderMaterial({
            uniforms: this.braceletShaderUniforms,
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                
                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform float uGlowIntensity;
                uniform float uScanlineSpeed;
                uniform float uFresnelPower;
                uniform float uNoiseIntensity;
                uniform float uSparkDensity;
                uniform float uSwipeVelocity;
                uniform vec3 uPrimaryColor;
                uniform vec3 uSecondaryColor;
                
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                
                // Pseudo-random noise
                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                }
                
                void main() {
                    // Fresnel glow (edge highlighting)
                    vec3 viewDir = normalize(vViewPosition);
                    float fresnel = pow(1.0 - abs(dot(viewDir, vNormal)), uFresnelPower);
                    
                    // Animated scanlines
                    float scanline = sin((vUv.y + uTime * uScanlineSpeed) * 40.0) * 0.5 + 0.5;
                    scanline = smoothstep(0.4, 0.6, scanline);
                    
                    // Film grain noise (very subtle)
                    float noise = hash(vUv * 100.0 + uTime * 10.0) * uNoiseIntensity;
                    
                    // Sparkling points
                    float sparkle = 0.0;
                    float sparkThreshold = 1.0 - uSparkDensity * 0.1;
                    float sparkNoise = hash(floor(vUv * 50.0) + floor(uTime * 8.0));
                    if (sparkNoise > sparkThreshold) {
                        sparkle = pow(sparkNoise, 8.0) * 2.0;
                    }
                    
                    // Color mixing based on UV and velocity
                    float colorMix = sin(vUv.x * 6.28 + uTime) * 0.5 + 0.5;
                    colorMix += uSwipeVelocity * 0.3;
                    vec3 baseColor = mix(uPrimaryColor, uSecondaryColor, colorMix * 0.3);
                    
                    // Combine effects
                    float intensity = fresnel * uGlowIntensity;
                    intensity += scanline * 0.2;
                    intensity += sparkle;
                    intensity = clamp(intensity + noise, 0.0, 1.5);
                    
                    // Velocity boost
                    intensity *= 1.0 + abs(uSwipeVelocity) * 0.5;
                    
                    vec3 finalColor = baseColor * intensity;
                    float alpha = clamp(intensity * 0.8 + 0.2, 0.0, 0.95);
                    
                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        
        // ========== FRONT BRACELET (180 degrees) ==========
        const braceletGeometry = new THREE.TorusGeometry(0.4, 0.025, 16, 64, Math.PI);
        this.bracelet = new THREE.Mesh(braceletGeometry, this.braceletMaterial);
        this.bracelet.rotation.x = Math.PI / 2;
        this.carouselHandGroup.add(this.bracelet);
        
        // ========== BACK BRACELET (180 degrees - subtle occlusion hint) ==========
        const backBraceletGeometry = new THREE.TorusGeometry(0.4, 0.02, 8, 32, Math.PI);
        this.braceletBack = new THREE.Mesh(backBraceletGeometry, new THREE.MeshBasicMaterial({
            color: 0x00FFFF,
            transparent: true,
            opacity: 0.0,  // Start hidden, show based on wrist rotation
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        }));
        this.braceletBack.rotation.x = Math.PI / 2;
        this.braceletBack.rotation.z = Math.PI; // Flip to back
        this.carouselHandGroup.add(this.braceletBack);
        
        // Inner ring (shader material)
        const innerUniforms = { ...this.braceletShaderUniforms };
        innerUniforms.uGlowIntensity = { value: 0.6 };
        const braceletInnerGeometry = new THREE.TorusGeometry(0.35, 0.015, 12, 48, Math.PI);
        this.braceletInner = new THREE.Mesh(braceletInnerGeometry, this.braceletMaterial.clone());
        this.braceletInner.rotation.x = Math.PI / 2;
        this.carouselHandGroup.add(this.braceletInner);
        
        // Outer decorative ring
        const braceletOuterGeometry = new THREE.TorusGeometry(0.45, 0.01, 8, 32, Math.PI);
        this.braceletOuter = new THREE.Mesh(braceletOuterGeometry, new THREE.MeshBasicMaterial({
            color: 0xFF0055,
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        }));
        this.braceletOuter.rotation.x = Math.PI / 2;
        this.carouselHandGroup.add(this.braceletOuter);
        
        // ========== INDEX FINGER LINE ==========
        const fingerLinePoints = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0.5, 0),
            new THREE.Vector3(0, 1, 0),
            new THREE.Vector3(0, 1.5, 0),
            new THREE.Vector3(0, 2, 0)
        ];
        
        this.fingerLineGeometry = new THREE.BufferGeometry().setFromPoints(fingerLinePoints);
        this.fingerLineMaterial = new THREE.LineDashedMaterial({
            color: 0x00FFFF,
            dashSize: 0.08,
            gapSize: 0.04,
            transparent: true,
            opacity: 0.7,
            linewidth: 1
        });
        
        this.fingerLine = new THREE.Line(this.fingerLineGeometry, this.fingerLineMaterial);
        this.fingerLine.computeLineDistances();
        this.scene.add(this.fingerLine);
        
        // ========== JOINT SPHERES (Premium glow) ==========
        const jointGeometry = new THREE.SphereGeometry(0.03, 12, 12);
        this.fingerJoints = [];
        for (let i = 0; i < 3; i++) {
            const jointMat = new THREE.MeshBasicMaterial({
                color: i === 2 ? 0xFFFFFF : 0x00FFFF, // Tip is white
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            const joint = new THREE.Mesh(jointGeometry, jointMat);
            joint.visible = false;
            this.scene.add(joint);
            this.fingerJoints.push(joint);
        }
        
        // ========== RETICLE AT FINGERTIP ==========
        const reticleGeometry = new THREE.RingGeometry(0.06, 0.1, 32);
        this.reticleMaterial = new THREE.MeshBasicMaterial({
            color: 0x00FFFF,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        
        this.reticle = new THREE.Mesh(reticleGeometry, this.reticleMaterial);
        this.scene.add(this.reticle);
        
        const reticleInnerGeometry = new THREE.RingGeometry(0.02, 0.04, 16);
        this.reticleInner = new THREE.Mesh(reticleInnerGeometry, new THREE.MeshBasicMaterial({
            color: 0xFF0055,
            transparent: true,
            opacity: 0.9,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        }));
        this.scene.add(this.reticleInner);
        
        // Crosshairs
        const crosshairMaterial = new THREE.LineBasicMaterial({
            color: 0x00FFFF,
            transparent: true,
            opacity: 0.5
        });
        
        const hCrossPoints = [new THREE.Vector3(-0.12, 0, 0), new THREE.Vector3(0.12, 0, 0)];
        this.crosshairH = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints(hCrossPoints),
            crosshairMaterial
        );
        this.scene.add(this.crosshairH);
        
        const vCrossPoints = [new THREE.Vector3(0, -0.12, 0), new THREE.Vector3(0, 0.12, 0)];
        this.crosshairV = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints(vCrossPoints),
            crosshairMaterial
        );
        this.scene.add(this.crosshairV);
        
        // Animation state
        this.carouselHandFXTime = 0;
        
        log('CAROUSEL: Premium 3D Hand FX initialized');
    }
    
    // ========== LANDMARK SMOOTHING (EMA + Velocity Prediction) ==========
    applyLandmarkSmoothing(landmarkIndex, rawPos, deltaTime) {
        const sm = this.carouselSmoothing;
        if (!sm.enabled) return rawPos;
        
        const key = `lm_${landmarkIndex}`;
        
        if (!sm.landmarks[key]) {
            // First frame - initialize
            sm.landmarks[key] = { x: rawPos.x, y: rawPos.y };
            sm.velocities[key] = { x: 0, y: 0 };
            return rawPos;
        }
        
        const prev = sm.landmarks[key];
        const vel = sm.velocities[key];
        
        // Calculate raw velocity
        const dt = Math.max(deltaTime, 0.016); // Min 60fps equivalent
        const rawVelX = (rawPos.x - prev.x) / dt;
        const rawVelY = (rawPos.y - prev.y) / dt;
        
        // Smooth velocity with EMA
        vel.x = vel.x * 0.7 + rawVelX * 0.3;
        vel.y = vel.y * 0.7 + rawVelY * 0.3;
        
        // Apply EMA to position
        const alpha = sm.alpha;
        const smoothX = prev.x * (1 - alpha) + rawPos.x * alpha;
        const smoothY = prev.y * (1 - alpha) + rawPos.y * alpha;
        
        // Simple prediction (add small velocity component for responsiveness)
        const predictionFactor = 0.02; // Very small to avoid overshoot
        const predictedX = smoothX + vel.x * predictionFactor;
        const predictedY = smoothY + vel.y * predictionFactor;
        
        // Update stored values
        sm.landmarks[key] = { x: predictedX, y: predictedY };
        
        return { x: predictedX, y: predictedY };
    }
    
    // ========== SWIPE VELOCITY COMPUTATION ==========
    computeSwipeVelocity(indexTipX, currentTime) {
        const sw = this.carouselSwipe;
        
        if (sw.lastIndexX === null || sw.lastTime === 0) {
            sw.lastIndexX = indexTipX;
            sw.lastTime = currentTime;
            return 0;
        }
        
        const dt = currentTime - sw.lastTime;
        if (dt < 0.01) return sw.smoothVelocity; // Too fast, use cached
        
        // Raw velocity (normalized units per second)
        const rawVelocity = (indexTipX - sw.lastIndexX) / dt;
        
        // Smooth velocity with EMA
        sw.smoothVelocity = sw.smoothVelocity * 0.8 + rawVelocity * 0.2;
        
        // Clamp to reasonable range
        sw.velocity = Math.max(-5, Math.min(5, sw.smoothVelocity));
        
        // Update state
        sw.lastIndexX = indexTipX;
        sw.lastTime = currentTime;
        
        return sw.velocity;
    }
    
    // ========== UPDATE BRACELET SHADER UNIFORMS ==========
    updateBraceletShaderUniforms(time, swipeVelocity, handScale) {
        const u = this.braceletShaderUniforms;
        
        u.uTime.value = time;
        u.uSwipeVelocity.value = swipeVelocity;
        
        // Modulate glow based on velocity
        const baseGlow = 1.0;
        const velocityGlow = Math.abs(swipeVelocity) * 0.3;
        u.uGlowIntensity.value = baseGlow + velocityGlow;
        
        // Increase spark density with velocity
        u.uSparkDensity.value = 0.3 + Math.abs(swipeVelocity) * 0.2;
        
        // Speed up scanlines with velocity
        u.uScanlineSpeed.value = 2.0 + Math.abs(swipeVelocity) * 0.5;
    }
    
    // Render CAROUSEL hand FX - PREMIUM version with smoothing & velocity feedback
    // Uses SCREEN-SPACE PROJECTION for perfect visual alignment with video
    renderCarouselHandFX3D(hands) {
        // ========== STRICT ACTIVATION CHECK ==========
        if (!hands || !hands.landmarks || hands.landmarks.length === 0 || !hands.landmarks[0]) {
            this.hideCarouselHandFX();
            this.renderer3D.render(this.scene, this.camera3D);
            return;
        }
        
        const hand = hands.landmarks[0];
        if (!hand || hand.length < 21) {
            this.hideCarouselHandFX();
            this.renderer3D.render(this.scene, this.camera3D);
            return;
        }
        
        // Validate key landmarks
        if (!hand[0] || !hand[5] || !hand[6] || !hand[7] || !hand[8] || !hand[9]) {
            this.hideCarouselHandFX();
            this.renderer3D.render(this.scene, this.camera3D);
            return;
        }
        
        const currentTime = performance.now() * 0.001;
        const deltaTime = currentTime - (this.carouselSmoothing.lastTime || currentTime);
        this.carouselSmoothing.lastTime = currentTime;
        
        // ========== APPLY LANDMARK SMOOTHING (Anti-Jitter) ==========
        const smoothedLandmarks = {};
        const landmarkIndices = [0, 5, 6, 7, 8, 9];
        for (const idx of landmarkIndices) {
            const raw = hand[idx];
            smoothedLandmarks[idx] = this.applyLandmarkSmoothing(idx, raw, deltaTime);
        }
        
        // ========== COMPUTE SWIPE VELOCITY ==========
        const swipeVelocity = this.computeSwipeVelocity(smoothedLandmarks[8].x, currentTime);
        
        // ========== UPDATE SHADER UNIFORMS ==========
        this.updateBraceletShaderUniforms(currentTime, swipeVelocity, 1.0);
        
        // ========== SCREEN-SPACE PROJECTION ==========
        const FIXED_Z_PLANE = -5;
        
        const projectToScreenPlane = (smoothedLandmark) => {
            if (!smoothedLandmark) return new THREE.Vector3(0, 0, FIXED_Z_PLANE);
            
            // Mirror X for selfie camera
            const ndcX = (1 - smoothedLandmark.x) * 2 - 1;
            const ndcY = -(smoothedLandmark.y * 2 - 1);
            
            const vector = new THREE.Vector3(ndcX, ndcY, 0);
            vector.unproject(this.camera3D);
            
            const dir = vector.sub(this.camera3D.position).normalize();
            const distance = (FIXED_Z_PLANE - this.camera3D.position.z) / dir.z;
            
            return this.camera3D.position.clone().add(dir.multiplyScalar(distance));
        };
        
        // ========== PROJECT SMOOTHED LANDMARKS ==========
        const wrist3D = projectToScreenPlane(smoothedLandmarks[0]);
        const indexMCP3D = projectToScreenPlane(smoothedLandmarks[5]);
        const indexPIP3D = projectToScreenPlane(smoothedLandmarks[6]);
        const indexDIP3D = projectToScreenPlane(smoothedLandmarks[7]);
        const indexTip3D = projectToScreenPlane(smoothedLandmarks[8]);
        const middleMCP3D = projectToScreenPlane(smoothedLandmarks[9]);
        
        // ========== CALCULATE DYNAMIC SCALE ==========
        const wrist2D = smoothedLandmarks[0];
        const middle2D = smoothedLandmarks[9];
        const hand2DSize = Math.sqrt(
            Math.pow(middle2D.x - wrist2D.x, 2) + 
            Math.pow(middle2D.y - wrist2D.y, 2)
        );
        
        const baseScale = 1.0;
        const dynamicScale = baseScale * (hand2DSize / 0.18);
        const clampedScale = Math.max(0.5, Math.min(2.5, dynamicScale));
        
        // ========== MAKE EVERYTHING VISIBLE ==========
        this.carouselHandGroup.visible = true;
        this.fingerLine.visible = true;
        this.reticle.visible = true;
        this.reticleInner.visible = true;
        this.crosshairH.visible = true;
        this.crosshairV.visible = true;
        this.fingerJoints.forEach(j => j.visible = true);
        
        // ========== UPDATE BRACELET POSITION ==========
        this.carouselHandGroup.position.copy(wrist3D);
        
        // ========== CALCULATE ROTATION ==========
        const dirX = middle2D.x - wrist2D.x;
        const dirY = middle2D.y - wrist2D.y;
        const braceletRotation = Math.atan2(-dirY, -dirX);
        
        this.carouselHandGroup.rotation.set(0, 0, braceletRotation + Math.PI / 2);
        
        // ========== APPLY SCALE ==========
        this.carouselHandGroup.scale.setScalar(clampedScale);
        
        // ========== ANIMATE BRACELET RINGS ==========
        const ringSpeed = 0.5 + Math.abs(swipeVelocity) * 0.3;
        this.bracelet.rotation.y = currentTime * ringSpeed;
        this.braceletInner.rotation.y = -currentTime * ringSpeed * 1.4;
        this.braceletOuter.rotation.y = currentTime * ringSpeed * 0.6;
        
        // ========== BACK BRACELET OCCLUSION (10% when wrist rotates) ==========
        // Calculate wrist rotation indicator from hand spread
        const index2D = smoothedLandmarks[5];
        const pinky2D = hand[17]; // Pinky MCP
        if (pinky2D) {
            // If pinky and index are close in X, wrist is tilted (show back)
            const handSpread = Math.abs(index2D.x - pinky2D.x);
            const backOpacity = handSpread < 0.08 ? 0.1 * (1 - handSpread / 0.08) : 0;
            this.braceletBack.material.opacity = backOpacity;
        }
        
        // ========== UPDATE FINGER LINE ==========
        const fingerPositions = new Float32Array([
            wrist3D.x, wrist3D.y, wrist3D.z,
            indexMCP3D.x, indexMCP3D.y, indexMCP3D.z,
            indexPIP3D.x, indexPIP3D.y, indexPIP3D.z,
            indexDIP3D.x, indexDIP3D.y, indexDIP3D.z,
            indexTip3D.x, indexTip3D.y, indexTip3D.z
        ]);
        
        this.fingerLineGeometry.setAttribute('position', new THREE.BufferAttribute(fingerPositions, 3));
        this.fingerLineGeometry.attributes.position.needsUpdate = true;
        this.fingerLine.computeLineDistances();
        
        // Velocity-responsive dash animation
        const dashSpeed = 4 + Math.abs(swipeVelocity) * 2;
        this.fingerLineMaterial.dashSize = 0.08 + Math.sin(currentTime * dashSpeed) * 0.02;
        this.fingerLineMaterial.opacity = 0.5 + Math.abs(swipeVelocity) * 0.3;
        
        // ========== UPDATE JOINT SPHERES ==========
        const jointPositions = [indexPIP3D, indexDIP3D, indexTip3D];
        const jointBaseScale = clampedScale * 0.06;
        
        for (let i = 0; i < this.fingerJoints.length; i++) {
            const joint = this.fingerJoints[i];
            const pos = jointPositions[i];
            
            joint.position.copy(pos);
            
            // Velocity-enhanced pulsing
            const velocityBoost = 1 + Math.abs(swipeVelocity) * 0.2;
            const jointPulse = jointBaseScale * velocityBoost * (1 + Math.sin(currentTime * 5 + i) * 0.3);
            joint.scale.setScalar(jointPulse);
            
            joint.material.opacity = 0.6 + Math.abs(swipeVelocity) * 0.3 + Math.sin(currentTime * 3 + i) * 0.2;
        }
        
        // ========== UPDATE RETICLE ==========
        this.reticle.position.copy(indexTip3D);
        this.reticleInner.position.copy(indexTip3D);
        this.crosshairH.position.copy(indexTip3D);
        this.crosshairV.position.copy(indexTip3D);
        
        // Billboard
        this.reticle.quaternion.copy(this.camera3D.quaternion);
        this.reticleInner.quaternion.copy(this.camera3D.quaternion);
        this.crosshairH.quaternion.copy(this.camera3D.quaternion);
        this.crosshairV.quaternion.copy(this.camera3D.quaternion);
        
        // Velocity-enhanced rotation
        const reticleSpeed = 2 + Math.abs(swipeVelocity);
        this.reticle.rotateZ(currentTime * reticleSpeed);
        this.reticleInner.rotateZ(-currentTime * reticleSpeed * 1.5);
        
        // Velocity-enhanced scale
        const velocityScale = 1 + Math.abs(swipeVelocity) * 0.15;
        const reticlePulse = clampedScale * 0.12 * velocityScale * (1 + Math.sin(currentTime * 4) * 0.2);
        this.reticle.scale.setScalar(reticlePulse);
        this.reticleInner.scale.setScalar(reticlePulse * 0.6);
        this.crosshairH.scale.setScalar(reticlePulse);
        this.crosshairV.scale.setScalar(reticlePulse);
        
        // Velocity-enhanced opacity
        this.reticleMaterial.opacity = 0.4 + Math.abs(swipeVelocity) * 0.4 + Math.sin(currentTime * 5) * 0.2;
        
        // ========== RENDER ==========
        this.renderer3D.render(this.scene, this.camera3D);
    }
    
    // Hide CAROUSEL hand FX (called when leaving CAROUSEL mode or no hand detected)
    hideCarouselHandFX() {
        if (this.carouselHandGroup) this.carouselHandGroup.visible = false;
        if (this.fingerLine) this.fingerLine.visible = false;
        if (this.reticle) this.reticle.visible = false;
        if (this.reticleInner) this.reticleInner.visible = false;
        if (this.crosshairH) this.crosshairH.visible = false;
        if (this.crosshairV) this.crosshairV.visible = false;
        if (this.fingerJoints) this.fingerJoints.forEach(j => j.visible = false);
        
        // Reset smoothing state when hiding
        if (this.carouselSmoothing) {
            this.carouselSmoothing.landmarks = {};
            this.carouselSmoothing.velocities = {};
        }
        if (this.carouselSwipe) {
            this.carouselSwipe.lastIndexX = null;
            this.carouselSwipe.velocity = 0;
            this.carouselSwipe.smoothVelocity = 0;
        }
    }
    
    // Convert landmark to 3D with CORRECT mirroring for CAROUSEL mode (selfie camera)
    // This fixes the issue where hand movement is inverted on X axis
    carouselLandmarkTo3D(p, depth = 0, handSize = 1.0) {
        if (!p || typeof p.x !== 'number' || typeof p.y !== 'number') {
            return new THREE.Vector3(0, 0, depth);
        }
        
        // Estimate depth based on hand size (larger = closer, smaller = farther)
        const depthScale = Math.max(0.5, Math.min(2.0, 1.0 / handSize));
        const adjustedDepth = depth * depthScale;
        
        // ========== CORRECTED MIRRORING ==========
        // MediaPipe gives coordinates where x=0 is left of image, x=1 is right
        // But video is mirrored (selfie mode), so we need to flip X
        // The fix: use (1 - p.x) to mirror, then center at 0.5
        // This makes: left side of screen = negative X, right side = positive X
        const mirroredX = 1 - p.x; // Flip X to match mirrored video
        
        // Map normalized coords to 3D space
        // X: -5 to 5 (left to right, NOW correctly mirrored)
        // Y: -5 to 5 (top to bottom)
        // Z: depth with perspective
        return new THREE.Vector3(
            (mirroredX - 0.5) * 10 * depthScale,  // Mirrored and centered
            (p.y - 0.5) * -10 * depthScale,       // Y inverted (screen Y is down, 3D Y is up)
            adjustedDepth
        );
    }
    
    // ========== INTEL 3D BOUNDING BOX SYSTEM ==========
    initIntel3DSystem() {
        // Group to hold all 3D bounding boxes
        this.intel3DGroup = new THREE.Group();
        this.scene.add(this.intel3DGroup);
        this.intel3DGroup.visible = false;
        
        // Pool of reusable 3D boxes
        this.intel3DBoxPool = [];
        this.activeIntel3DBoxes = new Map();
        
        // Create container for HTML labels
        this.intel3DLabelsContainer = document.createElement('div');
        this.intel3DLabelsContainer.id = 'intel-3d-labels';
        this.intel3DLabelsContainer.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 15;
            overflow: hidden;
        `;
        document.getElementById('container').appendChild(this.intel3DLabelsContainer);
        
        // Hand anchor system for stabilization
        this.handAnchors = new Map();
        this.lastHandPositions = [];
        
        // Pre-create box pool for performance
        for (let i = 0; i < 10; i++) {
            this.intel3DBoxPool.push(this.createIntel3DBox());
        }
        
        log('INTEL 3D: Advanced tactical box system initialized');
    }
    
    createIntel3DBox() {
        const group = new THREE.Group();
        
        // ===== MAIN WIREFRAME (EdgesGeometry) =====
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const edges = new THREE.EdgesGeometry(geometry);
        
        // Green neon material with flicker capability
        const material = new THREE.LineBasicMaterial({
            color: 0x00ff88,
            transparent: true,
            opacity: 0.9
        });
        
        const wireframe = new THREE.LineSegments(edges, material);
        group.add(wireframe);
        group.wireframe = wireframe;
        group.material = material;
        
        // ===== TACTICAL BRACKETS (Corner L-shapes) =====
        const bracketLength = 0.15; // Length of bracket arms
        const bracketThickness = 0.02;
        const bracketMaterial = new THREE.LineBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 1.0
        });
        
        // Define 8 corners and their bracket directions
        const cornerDefs = [
            { pos: [-0.5, -0.5, -0.5], dirs: [[1,0,0], [0,1,0], [0,0,1]] },
            { pos: [0.5, -0.5, -0.5], dirs: [[-1,0,0], [0,1,0], [0,0,1]] },
            { pos: [0.5, 0.5, -0.5], dirs: [[-1,0,0], [0,-1,0], [0,0,1]] },
            { pos: [-0.5, 0.5, -0.5], dirs: [[1,0,0], [0,-1,0], [0,0,1]] },
            { pos: [-0.5, -0.5, 0.5], dirs: [[1,0,0], [0,1,0], [0,0,-1]] },
            { pos: [0.5, -0.5, 0.5], dirs: [[-1,0,0], [0,1,0], [0,0,-1]] },
            { pos: [0.5, 0.5, 0.5], dirs: [[-1,0,0], [0,-1,0], [0,0,-1]] },
            { pos: [-0.5, 0.5, 0.5], dirs: [[1,0,0], [0,-1,0], [0,0,-1]] }
        ];
        
        group.brackets = [];
        cornerDefs.forEach(corner => {
            const bracketVertices = [];
            const [px, py, pz] = corner.pos;
            
            // Create 3 bracket arms from each corner
            corner.dirs.forEach(dir => {
                bracketVertices.push(px, py, pz);
                bracketVertices.push(
                    px + dir[0] * bracketLength,
                    py + dir[1] * bracketLength,
                    pz + dir[2] * bracketLength
                );
            });
            
            const bracketGeometry = new THREE.BufferGeometry();
            bracketGeometry.setAttribute('position', new THREE.Float32BufferAttribute(bracketVertices, 3));
            const bracket = new THREE.LineSegments(bracketGeometry, bracketMaterial.clone());
            group.add(bracket);
            group.brackets.push(bracket);
        });
        
        // ===== INNER TARGETING GRID =====
        const gridVertices = [];
        // Cross pattern on front and back faces
        const gridSize = 0.3;
        // Front face cross
        gridVertices.push(-gridSize, 0, 0.5, gridSize, 0, 0.5);
        gridVertices.push(0, -gridSize, 0.5, 0, gridSize, 0.5);
        // Back face cross
        gridVertices.push(-gridSize, 0, -0.5, gridSize, 0, -0.5);
        gridVertices.push(0, -gridSize, -0.5, 0, gridSize, -0.5);
        // Side targeting lines
        gridVertices.push(-0.5, 0, -gridSize, -0.5, 0, gridSize);
        gridVertices.push(0.5, 0, -gridSize, 0.5, 0, gridSize);
        
        const gridGeometry = new THREE.BufferGeometry();
        gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(gridVertices, 3));
        const gridMaterial = new THREE.LineBasicMaterial({
            color: 0x00ff88,
            transparent: true,
            opacity: 0.4
        });
        const targetGrid = new THREE.LineSegments(gridGeometry, gridMaterial);
        group.add(targetGrid);
        group.targetGrid = targetGrid;
        
        // ===== SCANNING PLANE =====
        const scanPlaneGeometry = new THREE.PlaneGeometry(1, 1);
        const scanPlaneMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff88,
            transparent: true,
            opacity: 0.15,
            side: THREE.DoubleSide
        });
        const scanPlane = new THREE.Mesh(scanPlaneGeometry, scanPlaneMaterial);
        group.add(scanPlane);
        group.scanPlane = scanPlane;
        
        // ===== DISTANCE RING (at front of box) =====
        const ringGeometry = new THREE.RingGeometry(0.2, 0.25, 32);
        const ringMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide
        });
        const distanceRing = new THREE.Mesh(ringGeometry, ringMaterial);
        distanceRing.position.z = 0.51;
        group.add(distanceRing);
        group.distanceRing = distanceRing;
        
        // ===== HTML LABEL (created separately) =====
        const labelDiv = document.createElement('div');
        labelDiv.className = 'intel-3d-label';
        labelDiv.style.cssText = `
            position: absolute;
            background: rgba(0, 8, 16, 0.9);
            border: 1px solid #00ff88;
            border-radius: 4px;
            padding: 6px 10px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 10px;
            color: #00ff88;
            white-space: nowrap;
            pointer-events: none;
            transform: translate(-50%, -100%);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
            opacity: 0;
            transition: opacity 0.2s ease;
        `;
        labelDiv.innerHTML = `
            <div style="color: #00ffff; font-weight: bold; margin-bottom: 3px;">▣ TARGET LOCKED</div>
            <div style="color: #AAAAAA;">DIST: <span class="label-dist">0.0</span>m</div>
            <div style="color: #AAAAAA;">CONF: <span class="label-conf">0</span>%</div>
        `;
        group.labelDiv = labelDiv;
        
        // Metadata
        group.userData = {
            active: false,
            objectId: null,
            category: '',
            flickerPhase: Math.random() * Math.PI * 2,
            scanOffset: 0,
            fadeOut: false,
            fadeProgress: 0,
            glitchActive: false,
            targetLocked: false,
            lockProgress: 0,
            lastPosition: new THREE.Vector3(),
            velocity: new THREE.Vector3(),
            orientation: new THREE.Quaternion(),
            nearHand: false,
            anchorStrength: 0
        };
        
        group.visible = false;
        this.intel3DGroup.add(group);
        
        return group;
    }
    
    getIntel3DBox() {
        // Find inactive box from pool
        for (const box of this.intel3DBoxPool) {
            if (!box.userData.active) {
                return box;
            }
        }
        
        // Create new box if pool exhausted
        const newBox = this.createIntel3DBox();
        this.intel3DBoxPool.push(newBox);
        return newBox;
    }
    
    // Update hand positions for anchor system
    updateHandAnchors(hands) {
        this.lastHandPositions = [];
        
        if (!hands || !hands.landmarks) return;
        
        hands.landmarks.forEach((hand, idx) => {
            if (hand && hand.length >= 21) {
                // Get palm center (average of wrist, index MCP, pinky MCP)
                const palmCenter = {
                    x: (hand[0].x + hand[5].x + hand[17].x) / 3,
                    y: (hand[0].y + hand[5].y + hand[17].y) / 3,
                    z: ((hand[0].z || 0) + (hand[5].z || 0) + (hand[17].z || 0)) / 3
                };
                
                // Calculate hand orientation from landmarks
                const wrist = hand[0];
                const indexMCP = hand[5];
                const pinkyMCP = hand[17];
                const middleTip = hand[12];
                
                // Direction vector from wrist to middle finger
                const handDir = {
                    x: middleTip.x - wrist.x,
                    y: middleTip.y - wrist.y,
                    z: (middleTip.z || 0) - (wrist.z || 0)
                };
                
                // Palm normal (cross product approximation)
                const palmWidth = {
                    x: pinkyMCP.x - indexMCP.x,
                    y: pinkyMCP.y - indexMCP.y,
                    z: (pinkyMCP.z || 0) - (indexMCP.z || 0)
                };
                
                this.lastHandPositions.push({
                    center: palmCenter,
                    direction: handDir,
                    width: palmWidth,
                    landmarks: hand
                });
            }
        });
    }
    
    // Check if object is near a hand for anchor stabilization
    checkHandProximity(objCenter) {
        let nearestHand = null;
        let minDistance = 0.15; // Threshold for "near hand"
        
        this.lastHandPositions.forEach(hand => {
            const dx = objCenter.x - hand.center.x;
            const dy = objCenter.y - hand.center.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < minDistance) {
                nearestHand = hand;
                minDistance = distance;
            }
        });
        
        return nearestHand;
    }
    
    // Calculate object orientation based on nearby hand
    calculateObjectOrientation(obj3D, nearHand) {
        if (!nearHand) {
            // Default orientation based on object position on screen
            const screenCenterX = 0.5;
            const objCenterX = obj3D.center?.x || 0.5;
            const yRotation = (objCenterX - screenCenterX) * 0.5;
            
            return {
                x: 0,
                y: yRotation,
                z: 0
            };
        }
        
        // Use hand direction to orient object
        const handDir = nearHand.direction;
        
        // Calculate rotation angles from hand direction
        const yaw = Math.atan2(handDir.x, -handDir.z || 0.1);
        const pitch = Math.atan2(handDir.y, Math.sqrt(handDir.x * handDir.x + (handDir.z || 0.1) * (handDir.z || 0.1)));
        
        // Calculate roll from palm width
        const roll = Math.atan2(nearHand.width.y, nearHand.width.x);
        
        return {
            x: pitch * 0.5,
            y: yaw,
            z: roll * 0.3
        };
    }
    
    updateIntel3DBoxes(objects3D, video, hands) {
        if (!objects3D || objects3D.length === 0) {
            // Immediately hide all boxes and labels (no fade)
            this.activeIntel3DBoxes.forEach((box, id) => {
                box.visible = false;
                box.userData.active = false;
                if (box.labelDiv) {
                    box.labelDiv.style.opacity = '0';
                }
            });
            return;
        }
        
        // Update hand anchors
        this.updateHandAnchors(hands);
        
        const time = performance.now() * 0.001;
        const currentIds = new Set();
        
        // First pass: update existing boxes or create new ones
        objects3D.forEach(obj3D => {
            currentIds.add(obj3D.id);
            
            let box = this.activeIntel3DBoxes.get(obj3D.id);
            
            if (!box) {
                // Get or create box
                box = this.getIntel3DBox();
                box.userData.active = true;
                box.userData.objectId = obj3D.id;
                box.userData.category = obj3D.category;
                box.userData.fadeOut = false;
                box.userData.fadeProgress = 0;
                box.userData.lockProgress = 0;
                box.visible = true;
                this.activeIntel3DBoxes.set(obj3D.id, box);
                
                // Add label to container (only if not already added)
                if (box.labelDiv && this.intel3DLabelsContainer && !box.labelDiv.parentNode) {
                    this.intel3DLabelsContainer.appendChild(box.labelDiv);
                }
            } else {
                // Ensure existing box is visible and not fading
                box.visible = true;
                box.userData.fadeOut = false;
            }
            
            // Check hand proximity for stabilization
            const nearHand = this.checkHandProximity(obj3D.center);
            box.userData.nearHand = !!nearHand;
            box.userData.anchorStrength = nearHand ? Math.min(1, box.userData.anchorStrength + 0.1) : Math.max(0, box.userData.anchorStrength - 0.05);
            
            // Calculate orientation
            const orientation = this.calculateObjectOrientation(obj3D, nearHand);
            
            // Update box transform with orientation
            this.updateIntel3DBoxTransform(box, obj3D, video, orientation);
            
            // Animate box
            this.animateIntel3DBox(box, time, obj3D);
            
            // Update HTML label position
            this.updateIntel3DLabel(box, obj3D, video);
        });
        
        // Second pass: immediately remove boxes that are no longer detected
        const toRemove = [];
        this.activeIntel3DBoxes.forEach((box, id) => {
            if (!currentIds.has(id)) {
                // Immediately hide (no fade for cleaner tracking)
                box.visible = false;
                box.userData.active = false;
                box.userData.lockProgress = 0;
                box.userData.anchorStrength = 0;
                
                if (box.labelDiv) {
                    box.labelDiv.style.opacity = '0';
                    if (box.labelDiv.parentNode) {
                        box.labelDiv.parentNode.removeChild(box.labelDiv);
                    }
                }
                
                toRemove.push(id);
            }
        });
        
        // Clean up removed boxes
        toRemove.forEach(id => this.activeIntel3DBoxes.delete(id));
    }
    
    updateIntel3DBoxTransform(box, obj3D, video, orientation) {
        const vw = video.videoWidth || 640;
        const vh = video.videoHeight || 480;
        
        // Convert normalized coordinates to 3D space
        const aspectRatio = vw / vh;
        const fov = this.camera3D.fov * (Math.PI / 180);
        const baseDistance = 3;
        
        const visibleHeight = 2 * Math.tan(fov / 2) * baseDistance;
        const visibleWidth = visibleHeight * aspectRatio;
        
        let targetPos = new THREE.Vector3();
        let targetScale = new THREE.Vector3(1, 1, 0.3);
        
        if (obj3D.vertices && obj3D.vertices.length >= 8) {
            // Use 3D vertices for position
            const center = obj3D.center;
            const depth = Math.max(0.5, Math.min(5, (center.z || 0.5) * 5));
            
            targetPos.set(
                (center.x - 0.5) * visibleWidth,
                -(center.y - 0.5) * visibleHeight,
                -baseDistance + depth * 0.5
            );
            
            const scale = obj3D.scale;
            targetScale.set(
                scale.x * visibleWidth * 0.9,
                scale.y * visibleHeight * 0.9,
                Math.max(0.2, scale.z * 2.5)
            );
        } else if (obj3D.bbox2D) {
            const [bx, by, bw, bh] = obj3D.bbox2D;
            
            const nx = (bx + bw / 2) / vw;
            const ny = (by + bh / 2) / vh;
            
            // Estimate depth from size (larger objects = closer)
            const objSize = Math.sqrt(bw * bh);
            const estimatedDepth = Math.max(0.5, Math.min(4, 300 / objSize));
            
            targetPos.set(
                (nx - 0.5) * visibleWidth,
                -(ny - 0.5) * visibleHeight,
                -baseDistance + estimatedDepth * 0.3
            );
            
            targetScale.set(
                (bw / vw) * visibleWidth * 1.1,
                (bh / vh) * visibleHeight * 1.1,
                Math.max(0.15, (bw / vw) * 0.5)
            );
        }
        
        // Smooth position interpolation (stronger when anchored to hand)
        const posLerp = box.userData.nearHand ? 0.3 : 0.15;
        box.position.lerp(targetPos, posLerp);
        
        // Smooth scale
        box.scale.lerp(targetScale, 0.1);
        
        // Apply orientation with smooth interpolation
        const targetQuat = new THREE.Quaternion();
        targetQuat.setFromEuler(new THREE.Euler(orientation.x, orientation.y, orientation.z, 'YXZ'));
        box.quaternion.slerp(targetQuat, 0.1);
        
        // Store position for velocity calculation
        box.userData.velocity.subVectors(box.position, box.userData.lastPosition);
        box.userData.lastPosition.copy(box.position);
    }
    
    updateIntel3DLabel(box, obj3D, video) {
        if (!box.labelDiv) return;
        
        // Project 3D position to screen
        const pos = box.position.clone();
        pos.y += box.scale.y * 0.6; // Position above box
        pos.project(this.camera3D);
        
        // Convert to screen coordinates
        const screenX = (pos.x * 0.5 + 0.5) * this.canvas.width;
        const screenY = (-pos.y * 0.5 + 0.5) * this.canvas.height;
        
        // Check if in front of camera
        if (pos.z > 1) {
            box.labelDiv.style.opacity = '0';
            return;
        }
        
        // Update label position
        box.labelDiv.style.left = `${screenX}px`;
        box.labelDiv.style.top = `${screenY}px`;
        box.labelDiv.style.opacity = box.userData.fadeOut ? '0' : '1';
        
        // Update label content
        const depth = Math.abs(box.position.z).toFixed(1);
        const conf = Math.round((obj3D.confidence || 0.8) * 100);
        const locked = box.userData.lockProgress >= 1;
        
        const distSpan = box.labelDiv.querySelector('.label-dist');
        const confSpan = box.labelDiv.querySelector('.label-conf');
        const titleDiv = box.labelDiv.querySelector('div');
        
        if (distSpan) distSpan.textContent = depth;
        if (confSpan) confSpan.textContent = conf;
        if (titleDiv) {
            if (box.userData.nearHand) {
                titleDiv.textContent = '◈ HAND ANCHORED';
                titleDiv.style.color = '#00ff88';
            } else if (locked) {
                titleDiv.textContent = '▣ TARGET LOCKED';
                titleDiv.style.color = '#00ffff';
            } else {
                titleDiv.textContent = '◇ TRACKING...';
                titleDiv.style.color = '#ffff00';
            }
        }
        
        // Update lock progress
        if (obj3D.scanProgress >= 100) {
            box.userData.lockProgress = Math.min(1, box.userData.lockProgress + 0.02);
        }
    }
    
    animateIntel3DBox(box, time, obj3D) {
        const flicker = Math.sin(time * 8 + box.userData.flickerPhase) * 0.1 + 0.9;
        const baseOpacity = obj3D.confidence || 0.8;
        const anchorBoost = box.userData.anchorStrength * 0.2;
        
        box.material.opacity = (baseOpacity + anchorBoost) * flicker;
        
        // Color based on state
        const scanProgress = obj3D.scanProgress || 0;
        if (box.userData.nearHand) {
            // Green when anchored to hand
            box.material.color.setHex(0x00ff88);
        } else if (scanProgress < 100) {
            // Cyan while scanning
            box.material.color.setHex(0x00ffff);
        } else {
            // Bright green when complete
            box.material.color.setHex(0x00ff88);
        }
        
        // Animate brackets
        const bracketPulse = Math.sin(time * 6) * 0.2 + 0.8;
        box.brackets.forEach(bracket => {
            bracket.material.opacity = bracketPulse;
            if (box.userData.nearHand) {
                bracket.material.color.setHex(0x00ff88);
            } else {
                bracket.material.color.setHex(0x00ffff);
            }
        });
        
        // Animate scan plane
        box.userData.scanOffset = (box.userData.scanOffset + 0.015) % 1;
        box.scanPlane.position.y = -0.5 + box.userData.scanOffset;
        box.scanPlane.material.opacity = 0.2 * Math.sin(box.userData.scanOffset * Math.PI);
        
        // Animate target grid
        box.targetGrid.material.opacity = 0.3 + Math.sin(time * 4) * 0.1;
        
        // Animate distance ring
        box.distanceRing.rotation.z = time * 2;
        box.distanceRing.material.opacity = 0.4 + Math.sin(time * 3) * 0.2;
        
        // Scale ring based on lock progress
        const ringScale = 1 - box.userData.lockProgress * 0.3;
        box.distanceRing.scale.set(ringScale, ringScale, 1);
    }
    
    processIntel3DFadeouts() {
        const toRemove = [];
        
        this.activeIntel3DBoxes.forEach((box, id) => {
            if (box.userData.fadeOut) {
                box.userData.fadeProgress += 0.04;
                
                // Glitch effect during fadeout
                if (box.userData.glitchActive) {
                    box.position.x += (Math.random() - 0.5) * 0.08;
                    box.position.y += (Math.random() - 0.5) * 0.08;
                    box.material.opacity = Math.random() * 0.4;
                    
                    // Color glitch
                    if (Math.random() > 0.6) {
                        box.material.color.setHex(0xff0055);
                        box.brackets.forEach(b => b.material.color.setHex(0xff0055));
                    }
                }
                
                // Fade label
                if (box.labelDiv) {
                    box.labelDiv.style.opacity = String(1 - box.userData.fadeProgress);
                }
                
                if (box.userData.fadeProgress >= 1) {
                    // Reset and return to pool
                    box.visible = false;
                    box.userData.active = false;
                    box.userData.fadeOut = false;
                    box.userData.glitchActive = false;
                    box.userData.lockProgress = 0;
                    box.userData.anchorStrength = 0;
                    box.material.color.setHex(0x00ff88);
                    box.brackets.forEach(b => b.material.color.setHex(0x00ffff));
                    
                    // Remove label from DOM
                    if (box.labelDiv && box.labelDiv.parentNode) {
                        box.labelDiv.parentNode.removeChild(box.labelDiv);
                    }
                    
                    toRemove.push(id);
                }
            }
        });
        
        toRemove.forEach(id => this.activeIntel3DBoxes.delete(id));
    }
    
    // Render INTEL mode with 3D boxes (now receives hands for orientation)
    renderIntel3D(objects3D, video, hands) {
        this.intel3DGroup.visible = true;
        this.updateIntel3DBoxes(objects3D, video, hands);
        
        // Sync Three.js camera with webcam intrinsics
        if (video.videoWidth && video.videoHeight) {
            cameraSync.applyToCamera(this.camera3D, video);
        }
        
        // Render the 3D scene
        this.renderer3D.render(this.scene, this.camera3D);
    }
    
    hideIntel3D() {
        this.intel3DGroup.visible = false;
        
        // Clear all active boxes and remove labels
        this.activeIntel3DBoxes.forEach(box => {
            box.visible = false;
            box.userData.active = false;
            box.userData.lockProgress = 0;
            box.userData.anchorStrength = 0;
            
            // Remove label from DOM
            if (box.labelDiv && box.labelDiv.parentNode) {
                box.labelDiv.parentNode.removeChild(box.labelDiv);
            }
        });
        this.activeIntel3DBoxes.clear();
        
        // Clear hand anchors
        this.lastHandPositions = [];
    }

    initTouchEffects() {
        // Create a holographic plane for touch interactions
        const planeGeometry = new THREE.PlaneGeometry(16, 9, 32, 18);
        const planeMaterial = new THREE.ShaderMaterial({
            transparent: true,
            side: THREE.DoubleSide,
            uniforms: {
                time: { value: 0.0 },
                touchCenter: { value: new THREE.Vector2(0, 0) },
                touchIntensity: { value: 0.0 },
                touchRadius: { value: 0.0 },
                gridOpacity: { value: 0.3 }
            },
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vPosition;

                void main() {
                    vUv = uv;
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec2 touchCenter;
                uniform float touchIntensity;
                uniform float touchRadius;
                uniform float gridOpacity;

                varying vec2 vUv;
                varying vec3 vPosition;

                // Noise function for subtle texture
                float noise(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                void main() {
                    vec2 center = vec2(0.5, 0.5);
                    vec2 pos = vUv;

                    // Grid pattern
                    float grid = step(0.98, sin(pos.x * 50.0) * sin(pos.y * 28.0));

                    // Single touch effect
                    float touchEffect = 0.0;
                    if(touchIntensity > 0.0) {
                        float dist = distance(pos, touchCenter);
                        if(dist < touchRadius) {
                            float wave = sin(dist * 20.0 - time * 8.0) * 0.5 + 0.5;
                            float falloff = exp(-dist * 3.0);
                            touchEffect = touchIntensity * wave * falloff;
                        }
                    }

                    // Combine effects
                    vec3 color = vec3(0.0, 0.8, 1.0) * (grid * gridOpacity + touchEffect * 2.0);

                    // Add subtle noise
                    float n = noise(pos + time * 0.1) * 0.1;
                    color += vec3(n);

                    gl_FragColor = vec4(color, grid * gridOpacity + touchEffect * 0.5);
                }
            `
        });

        this.touchPlane = new THREE.Mesh(planeGeometry, planeMaterial);
        this.touchPlane.position.z = -2;
        // REMOVED: Grid dots were showing in cube mode
        // this.scene.add(this.touchPlane);

        // Create simple particle system using standard Three.js Points
        this.touchParticles = [];
        this.particleGeometry = new THREE.BufferGeometry();
        this.particlePositions = new Float32Array(300); // 100 particles * 3 coordinates
        this.particleColors = new Float32Array(300);   // 100 particles * 3 colors

        // Initialize with zero positions
        for (let i = 0; i < 100; i++) {
            const i3 = i * 3;
            this.particlePositions[i3] = 0;
            this.particlePositions[i3 + 1] = 0;
            this.particlePositions[i3 + 2] = 0;

            this.particleColors[i3] = 0.5;
            this.particleColors[i3 + 1] = 0.8;
            this.particleColors[i3 + 2] = 1.0;
        }

        this.particleGeometry.setAttribute('position', new THREE.BufferAttribute(this.particlePositions, 3));
        this.particleGeometry.setAttribute('color', new THREE.BufferAttribute(this.particleColors, 3));

        // Simple particle material
        const particleMaterial = new THREE.PointsMaterial({
            size: 0.05,
            transparent: true,
            opacity: 0.8,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        this.particleSystem = new THREE.Points(this.particleGeometry, particleMaterial);
        // REMOVED: Particle dots were showing in cube mode
        // this.scene.add(this.particleSystem);
    }

    updateTouchMode(hands) {
        const currentTime = performance.now() * 0.001;

        // Update holographic plane
        if (this.touchPlane && this.touchPlane.material.uniforms) {
            this.touchPlane.material.uniforms.time.value = currentTime;
        }

        // Detect touch gestures
        this.detectTouchGestures(hands, currentTime);

        // Update touch effects
        this.updateTouchEffects(currentTime);

        // Update particle system
        this.updateTouchParticles(currentTime);
    }

    detectTouchGestures(hands, currentTime) {
        if (!hands || !hands.landmarks) return;

        hands.landmarks.forEach((hand, handIndex) => {
            if (!hand || hand.length < 21) return;

            // Check index finger tip (landmark 8)
            const fingerTip = hand[8];
            if (!fingerTip) return;

            const fingerId = `hand${handIndex}_finger8`;
            const lastPos = this.lastFingerPositions.get(fingerId);

            if (lastPos) {
                // Calculate velocity and distance from "touch plane"
                const velocity = Math.sqrt(
                    Math.pow(fingerTip.x - lastPos.x, 2) +
                    Math.pow(fingerTip.y - lastPos.y, 2) +
                    Math.pow((fingerTip.z || 0) - (lastPos.z || 0), 2)
                );

                // Detect "poke" gesture - finger moving toward camera (decreasing Z)
                const depthThreshold = this.touchThreshold;
                const isApproaching = (lastPos.z || 0) - (fingerTip.z || 0) > 0.05;
                const isClose = (fingerTip.z || 0) < depthThreshold;

                if (isApproaching && isClose && velocity > 0.1) {
                    // Create touch effect at the intersection point
                    const touchPoint = {
                        x: fingerTip.x,
                        y: fingerTip.y,
                        z: fingerTip.z || 0,
                        timestamp: currentTime,
                        strength: Math.min(velocity * 2.0, 1.0)
                    };

                    this.createTouchEffect(touchPoint);
                }
            }

            // Update position tracking
            this.lastFingerPositions.set(fingerId, {
                x: fingerTip.x,
                y: fingerTip.y,
                z: fingerTip.z || 0,
                timestamp: currentTime
            });
        });
    }

    createTouchEffect(touchPoint) {
        // Create shockwave effect
        const shockwave = {
            center: new THREE.Vector2(touchPoint.x, touchPoint.y),
            startTime: touchPoint.timestamp,
            strength: touchPoint.strength,
            radius: 0,
            maxRadius: 2.0,
            duration: 1.2
        };

        this.touchEffects.push(shockwave);

        // Create particle burst
        this.createParticleBurst(touchPoint);

        // Add chromatic aberration effect temporarily
        if (this.chromaticAberrationPass) {
            this.chromaticAberrationPass.uniforms.aberrationStrength.value = 0.01;
            setTimeout(() => {
                if (this.chromaticAberrationPass) {
                    this.chromaticAberrationPass.uniforms.aberrationStrength.value = 0.003;
                }
            }, 300);
        }

        log(`TOUCH: Air tap detected at (${touchPoint.x.toFixed(2)}, ${touchPoint.y.toFixed(2)})`);
    }

    createParticleBurst(touchPoint) {
        const particleCount = 20; // Reduced for simpler system

        for (let i = 0; i < particleCount; i++) {
            const angle = (i / particleCount) * Math.PI * 2;
            const speed = 0.3 + Math.random() * 0.8;
            const life = 0.8 + Math.random() * 0.7;

            const particle = {
                position: new THREE.Vector3(
                    touchPoint.x + Math.cos(angle) * 0.05,
                    touchPoint.y + Math.sin(angle) * 0.05,
                    -1 + Math.random() * 0.2
                ),
                velocity: new THREE.Vector3(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    Math.random() * 0.2 - 0.1
                ),
                life: life,
                maxLife: life,
                color: new THREE.Color().setHSL(0.6 + Math.random() * 0.2, 1.0, 0.6 + Math.random() * 0.4)
            };

            this.touchParticles.push(particle);
        }
    }

    updateTouchEffects(currentTime) {
        // Update shockwaves
        this.touchEffects = this.touchEffects.filter(effect => {
            const age = currentTime - effect.startTime;
            const progress = age / effect.duration;

            if (progress >= 1.0) return false;

            // Update radius with easing
            const easeOutProgress = 1 - Math.pow(1 - progress, 3);
            effect.radius = effect.maxRadius * easeOutProgress;

            return true;
        });

        // Update holographic plane uniforms (single touch effect for simplicity)
        if (this.touchPlane && this.touchPlane.material.uniforms) {
            // Use the first/most recent touch effect
            if (this.touchEffects.length > 0) {
                const effect = this.touchEffects[0]; // Use primary effect
                this.touchPlane.material.uniforms.touchCenter.value.copy(effect.center);

                const age = currentTime - effect.startTime;
                const intensity = Math.max(0, 1 - age / effect.duration);
                this.touchPlane.material.uniforms.touchIntensity.value = intensity * effect.strength;
                this.touchPlane.material.uniforms.touchRadius.value = effect.radius;
            } else {
                // No active touch effects
                this.touchPlane.material.uniforms.touchCenter.value.set(0, 0);
                this.touchPlane.material.uniforms.touchIntensity.value = 0.0;
                this.touchPlane.material.uniforms.touchRadius.value = 0.0;
            }
        }
    }

    updateTouchParticles(currentTime) {
        // Update particles with simple physics
        this.touchParticles = this.touchParticles.filter(particle => {
            particle.life -= 0.016; // Assume 60fps
            if (particle.life <= 0) return false;

            // Update position with simple movement
            particle.position.x += particle.velocity.x * 0.016;
            particle.position.y += particle.velocity.y * 0.016;
            particle.position.z += particle.velocity.z * 0.016;

            // Apply friction
            particle.velocity.x *= 0.95;
            particle.velocity.y *= 0.95;
            particle.velocity.z *= 0.95;

            return true;
        });

        // Update particle geometry
        const positions = this.particleGeometry.attributes.position.array;
        const colors = this.particleGeometry.attributes.color.array;

        // Clear all positions first
        for (let i = 0; i < 300; i++) {
            positions[i] = 0;
            if (i % 3 === 0) {
                colors[i] = 0.5;
                colors[i + 1] = 0.8;
                colors[i + 2] = 1.0;
            }
        }

        // Update active particles
        this.touchParticles.forEach((particle, index) => {
            if (index < 100) {
                const i = index * 3;
                positions[i] = particle.position.x;
                positions[i + 1] = particle.position.y;
                positions[i + 2] = particle.position.z;

                // Fade color based on life
                const lifeRatio = particle.life / particle.maxLife;
                colors[i] = particle.color.r * lifeRatio;
                colors[i + 1] = particle.color.g * lifeRatio;
                colors[i + 2] = particle.color.b * lifeRatio;
            }
        });

        this.particleGeometry.attributes.position.needsUpdate = true;
        this.particleGeometry.attributes.color.needsUpdate = true;

        // Update visible particle count
        this.particleGeometry.setDrawRange(0, Math.min(this.touchParticles.length, 100));
    }

    initSandtable() {
        this.sandtableGroup = new THREE.Group();

        // Create plane geometry with optimized detail for deformation (performance vs quality balance)
        const geometry = new THREE.PlaneGeometry(35, 35, 64, 64);
        geometry.rotateX(-Math.PI / 2); // Rotate to horizontal

        // Store original positions for deformation
        this.originalPositions = geometry.attributes.position.array.slice();

        // X-Ray Hologram Vertex Shader
        const vertexShader = `
            uniform float time;
            uniform float scaleHeight;
            uniform float scalePlane;
            uniform float deformationStrength;
            uniform float hologramOpacity;

            varying vec3 vPosition;
            varying vec3 vNormal;
            varying vec2 vUv;
            varying float vFresnel;

            void main() {
                vec3 pos = position;

                // Subtle deformation for holographic effect
                float wave = sin(pos.x * 0.02 + time) * cos(pos.z * 0.02 + time) * 0.1;
                pos.y += wave * scaleHeight;

                // Pass variables to fragment shader
                vPosition = pos;
                vNormal = normalize(normalMatrix * normal);
                vUv = uv;

                // Fresnel effect for edge glow
                vec3 viewDirection = normalize(cameraPosition - (modelViewMatrix * vec4(pos, 1.0)).xyz);
                vFresnel = pow(1.0 - abs(dot(viewDirection, vNormal)), 2.0);

                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        // X-Ray Hologram Fragment Shader (Cian, transparente, wireframe-like effect)
        const fragmentShader = `
            uniform float hologramOpacity;

            varying vec3 vPosition;
            varying vec3 vNormal;
            varying vec2 vUv;
            varying float vFresnel;

            void main() {
                // Base cian color for hologram
                vec3 hologramColor = vec3(0.0, 1.0, 1.0); // Cian

                // Fresnel glow effect on edges
                float fresnelGlow = vFresnel * 0.8;

                // Create grid-like wireframe effect
                float grid = sin(vPosition.x * 20.0) * sin(vPosition.z * 20.0);
                grid = smoothstep(0.8, 1.0, abs(grid));

                // Combine effects
                vec3 finalColor = hologramColor + vec3(fresnelGlow);
                finalColor += grid * 0.3; // Subtle grid lines

                gl_FragColor = vec4(finalColor, hologramOpacity * (0.3 + fresnelGlow * 0.7));
            }
        `;

        // Create shader material
        // Create X-Ray hologram shader material
        let material;
        try {
            material = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: {
                    time: { value: 0.0 },
                    scaleHeight: { value: 0.1 },
                    scalePlane: { value: 1.0 },
                    deformationStrength: { value: 1.0 },
                    hologramOpacity: { value: 0.4 }
                },
                transparent: true,
                wireframe: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending // For hologram glow effect
            });
        } catch (error) {
            console.warn('HOLOGRAM: Shader compilation failed, using fallback material');
            material = new THREE.MeshBasicMaterial({
                color: 0x00FFFF,
                transparent: true,
                opacity: 0.4,
                wireframe: true
            });
        }

        this.sandtableMesh = new THREE.Mesh(geometry, material);
        this.sandtableGroup.add(this.sandtableMesh);

        // Create brush ring (initially hidden) - improved visibility
        const ringGeometry = new THREE.RingGeometry(0.3, 0.8, 32); // More segments for smoother ring
        const ringMaterial = new THREE.MeshBasicMaterial({
            color: 0x00FFFF,
            transparent: true,
            opacity: 0.9,
            side: THREE.DoubleSide
        });
        this.brushRing = new THREE.Mesh(ringGeometry, ringMaterial);
        this.brushRing.rotation.x = -Math.PI / 2;
        this.brushRing.visible = false;
        this.sandtableGroup.add(this.brushRing);

        // Add inner highlight ring for better visibility
        const innerRingGeometry = new THREE.RingGeometry(0.2, 0.4, 16);
        const innerRingMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFFFF,
            transparent: true,
            opacity: 0.6,
            side: THREE.DoubleSide
        });
        this.innerBrushRing = new THREE.Mesh(innerRingGeometry, innerRingMaterial);
        this.innerBrushRing.rotation.x = -Math.PI / 2;
        this.innerBrushRing.visible = false;
        this.sandtableGroup.add(this.innerBrushRing);

        this.scene.add(this.sandtableGroup);
        this.sandtableGroup.position.set(0, -1, -2); // Default position in front of camera
        this.sandtableGroup.visible = false;

        // Initialize hologram opacity control
        this.targetHologramOpacity = 0.0;

        // Sandtable state with improved controls and tracking persistence
        this.sandtableState = {
            lastLeftWristY: 0,
            lastRightWristY: 0,
            sculpting: false,
            brushRadius: 2.0,
            manualBrushSize: false, // Allow manual brush size control
            brushSizeMultiplier: 1.0,
            lastBrushSizeChange: 0,

            // Tracking persistence for blink/grace period handling
            trackingGraceFrames: 0,
            maxGraceFrames: 20, // ~0.67 seconds at 30fps - allow brief tracking loss
            lastValidLeftHand: null,
            lastValidRightHand: null,
            hologramLocked: false, // Once hologram is established, keep it until mode exit
            lockThresholdFrames: 30, // Require 30 frames of stable tracking to "lock" hologram

            // Prediction system for smoother tracking during brief losses
            positionHistory: [],
            maxHistoryLength: 5,
            predictedPosition: null,
            predictedRotation: null
        };

        // Function to reset terrain deformations
        this.resetTerrainDeformations = () => {
            if (this.sandtableMesh && this.originalPositions) {
                const geometry = this.sandtableMesh.geometry;
                const positions = geometry.attributes.position.array;

                // Restore original positions
                for (let i = 0; i < this.originalPositions.length; i++) {
                    positions[i] = this.originalPositions[i];
                }

                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();
                log('SANDTABLE: Terrain deformations reset');
            }
        };

        // Function to reset sandtable state completely
        this.resetSandtableState = () => {
            if (this.sandtableState) {
                this.sandtableState.sculpting = false;
                this.sandtableState.brushRadius = 2.0;
                this.sandtableState.brushSizeMultiplier = 1.0;
                this.sandtableState.lastLeftWristY = 0;
                this.sandtableState.lastRightWristY = 0;

                // Reset persistence state
                this.sandtableState.trackingGraceFrames = 0;
                this.sandtableState.lastValidLeftHand = null;
                this.sandtableState.lastValidRightHand = null;
                this.sandtableState.hologramLocked = false;
                this.sandtableState.lockThresholdFrames = 30;

                // Clear pinch history
                if (this.sandtableState.pinchHistory) {
                    this.sandtableState.pinchHistory.left = [0.2, 0.2];
                    this.sandtableState.pinchHistory.right = [0.2, 0.2];
                }
            }

            // Hide brush rings
            if (this.brushRing) this.brushRing.visible = false;
            if (this.innerBrushRing) this.innerBrushRing.visible = false;

            // Reset terrain
            this.resetTerrainDeformations();

            // Clear any pending geometry updates
            this.geometryUpdatePending = false;
            this.lastSculptTime = 0;

            // Reset hologram opacity
            this.targetHologramOpacity = 0.0;
            if (this.sandtableMesh && this.sandtableMesh.material.uniforms) {
                this.sandtableMesh.material.uniforms.hologramOpacity.value = 0.0;
            }
        };
    }

    initMatrix() {
        const columns = Math.floor(window.innerWidth / 20);
        for(let i=0; i<columns; i++) {
            this.matrixDrops[i] = Math.random() * window.innerHeight; // Random Start Y
        }
    }

    // --- DRAWING HELPERS ---
    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    drawVideo(video, filterType) {
        this.ctx.save();

        // High-quality rendering settings for iPhone camera
        this.ctx.imageSmoothingEnabled = CONFIG.videoQuality.smoothingQuality !== 'pixelated';
        this.ctx.imageSmoothingQuality = CONFIG.videoQuality.smoothingQuality;

        // Mirror the video horizontally (natural webcam view)
        this.ctx.translate(this.canvas.width, 0);
        this.ctx.scale(-1, 1);
        
        // Filters
        if (filterType === 'XRAY') {
            this.ctx.filter = 'invert(1) hue-rotate(180deg) contrast(1.2)';
        } else if (filterType === 'VOID') {
            this.ctx.fillStyle = '#000';
            this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);
            this.ctx.restore();
            return; // Don't draw video in VOID
        } else if (filterType === 'DRONE') {
             // Fake fish-eye via scaling? Hard in 2D context cheaply.
             // We'll simulate via vignette overlay mostly.
             this.ctx.filter = 'sepia(0.5) contrast(1.1)';
        }
        
        // Draw centered and cover - maintains aspect ratio by cropping
        // Optimized for high-resolution iPhone camera input
        const videoAspect = video.videoWidth / video.videoHeight;
        const canvasAspect = this.canvas.width / this.canvas.height;

        let drawWidth, drawHeight, x, y;

        if (canvasAspect > videoAspect) {
            // Canvas is wider - fit to width, crop top/bottom
            drawWidth = this.canvas.width;
            drawHeight = this.canvas.width / videoAspect;
            x = 0;
            y = (this.canvas.height - drawHeight) / 2;
        } else {
            // Canvas is taller - fit to height, crop sides
            drawHeight = this.canvas.height;
            drawWidth = this.canvas.height * videoAspect;
            x = (this.canvas.width - drawWidth) / 2;
            y = 0;
        }

        // High-quality scaling optimizations for iPhone camera
        if (video.videoWidth >= 1920) {
            // For 1080p+ sources, ensure optimal rendering
            this.ctx.globalCompositeOperation = 'source-over';

            // Apply quality boosts from CONFIG
            if (CONFIG.videoQuality.contrastBoost > 1.0) {
                this.ctx.filter = `contrast(${CONFIG.videoQuality.contrastBoost}) brightness(${CONFIG.videoQuality.brightnessBoost}) saturate(${CONFIG.videoQuality.saturationBoost})`;
            }
        } else {
            // Reset filter for lower resolution sources
            this.ctx.filter = 'none';
        }
        
        // Draw with high-quality scaling
        try {
            this.ctx.drawImage(video, x, y, drawWidth, drawHeight);
        } catch (error) {
            console.warn('Video draw failed, attempting fallback:', error);
            // Fallback to simpler drawing if high-res fails
            this.ctx.imageSmoothingEnabled = false;
            this.ctx.drawImage(video, 0, 0, this.canvas.width, this.canvas.height);
            this.ctx.imageSmoothingEnabled = true;
        }
        
        // Store video transform info for landmark mapping
        this.videoTransform = { x, y, width: drawWidth, height: drawHeight };

        // Store video quality info for debugging/display
        this.videoQuality = {
            width: video.videoWidth,
            height: video.videoHeight,
            frameRate: 'unknown', // Will be estimated
            lastFrameTime: performance.now(),
            frameCount: 0
        };

        // Estimate frame rate
        this.videoQuality.frameCount++;
        const now = performance.now();
        const timeDiff = now - this.videoQuality.lastFrameTime;

        if (timeDiff >= 1000) { // Update every second
            const fps = Math.round((this.videoQuality.frameCount * 1000) / timeDiff);
            this.videoQuality.frameRate = fps;
            this.videoQuality.frameCount = 0;
            this.videoQuality.lastFrameTime = now;

            // Log high-quality video achievement
            if (fps >= 50 && video.videoWidth >= 1920) {
                console.log(`🎥 High-quality video: ${video.videoWidth}x${video.videoHeight} @ ${fps}fps`);
            }
        }
        
        // Scanlines overlay helper drawn in CSS, but we can darken here
        if(filterType === 'DRONE') {
            const grad = this.ctx.createRadialGradient(this.canvas.width/2, this.canvas.height/2, 100, this.canvas.width/2, this.canvas.height/2, this.canvas.width);
            grad.addColorStop(0, "rgba(0,0,0,0)");
            grad.addColorStop(1, "rgba(0,0,0,0.8)");
            this.ctx.fillStyle = grad;
            this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);
        }

        this.ctx.restore();
    }

    // Transform normalized landmark coordinates to canvas coordinates
    // accounting for video cropping/positioning
    transformLandmark(p) {
        if (!this.videoTransform) {
            // Fallback if no transform info
            return {
                x: (1 - p.x) * this.canvas.width,
                y: p.y * this.canvas.height
            };
        }

        const vt = this.videoTransform;
        // Map normalized coords (0-1) to the actual video draw area
        return {
            x: vt.x + (1 - p.x) * vt.width,  // Mirrored X
            y: vt.y + p.y * vt.height
        };
    }

    // Convert normalized landmark coordinates to 3D world space with depth estimation
    landmarkTo3D(p, depth = 0, handSize = 1.0) {
        if (!p || typeof p.x !== 'number' || typeof p.y !== 'number') {
            console.warn('SANDTABLE: Invalid landmark data for 3D conversion');
            return new THREE.Vector3(0, 0, depth);
        }

        // Estimate depth based on hand size (larger = closer, smaller = farther)
        // This gives rough depth perception without actual depth sensing
        const depthScale = Math.max(0.5, Math.min(2.0, 1.0 / handSize));
        const adjustedDepth = depth * depthScale;

        // Map normalized coords to 3D space with perspective correction
        // X: -5 to 5 (left to right, mirrored)
        // Y: -5 to 5 (top to bottom)
        // Z: depth with perspective
        return new THREE.Vector3(
            (p.x - 0.5) * 10 * depthScale,  // Scale X with depth for perspective
            (p.y - 0.5) * -10 * depthScale, // Scale Y with depth for perspective
            adjustedDepth
        );
    }

    estimateHandDepth(hand) {
        if (!hand || hand.length < 21) return 1.0;

        // Estimate hand size by measuring distance between wrist and middle finger tip
        const wrist = hand[0];
        const middleTip = hand[12];

        if (!wrist || !middleTip) return 1.0;

        const handLength = Math.sqrt(
            Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2)
        );

        // Normalize hand size (typical range: 0.15-0.25 in normalized coords)
        // Smaller hands appear farther, larger hands appear closer
        return Math.max(0.5, Math.min(2.0, 0.2 / handLength));
    }

    drawSkeleton(hands, style = 'TACTICAL') {
        if (!hands || !hands.landmarks) return;

        this.ctx.lineWidth = 2;
        this.ctx.lineCap = 'round';

        for (const landmarks of hands.landmarks) {
            // Transform landmarks to canvas coordinates (already mirrored in transformLandmark)
            const transformedLandmarks = landmarks.map(p => {
                if (!p) return null;
                return this.transformLandmark(p);
            });

            // Draw Connections
            this.ctx.strokeStyle = style === 'MATRIX' ? '#00FF00' : '#00FFFF';
            this.connectTransformed(transformedLandmarks, HAND_CONNECTIONS);

            // Draw Nodes
            this.ctx.fillStyle = style === 'MATRIX' ? '#003300' : 'rgba(0,255,255,0.5)';
            for (const p of transformedLandmarks) {
                if (!p) continue;
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, 4, 0, 2 * Math.PI);
                this.ctx.fill();
            }

            // Hex Grid on Palm (0, 1, 5, 9, 13, 17 are palm base/knuckles)
            if(style === 'TACTICAL') {
                this.drawHexTransformed(transformedLandmarks[0], transformedLandmarks[5], transformedLandmarks[17]);
            }
        }
    }

    // Connect using already transformed coordinates
    connectTransformed(landmarks, connector) {
        for (const c of connector) {
            const p1 = landmarks[c[0]];
            const p2 = landmarks[c[1]];
            // Safety check: ensure both points exist
            if (!p1 || !p2) continue;
            this.ctx.beginPath();
            this.ctx.moveTo(p1.x, p1.y);
            this.ctx.lineTo(p2.x, p2.y);
            this.ctx.stroke();
        }
    }

    // Draw hex using already transformed coordinates
    drawHexTransformed(p0, p5, p17) {
        if (!p0 || !p5 || !p17) return;
        // Simple approximate center of palm
        const cx = (p0.x + p5.x + p17.x) / 3;
        const cy = (p0.y + p5.y + p17.y) / 3;
        const size = 30;

        this.ctx.strokeStyle = 'rgba(255, 0, 85, 0.6)';
        this.ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = 2 * Math.PI / 6 * i;
            const x = cx + size * Math.cos(angle);
            const y = cy + size * Math.sin(angle);
            if (i === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.closePath();
        this.ctx.stroke();
    }

    // --- MODE SPECIFIC RENDERERS ---

    renderLidar(video, hands, face) {
        if (!video) return;

        const time = Date.now() * 0.001;

        // Draw the video feed as base layer (slightly darkened for contrast)
        this.ctx.save();
        this.ctx.globalAlpha = 0.9;
        this.drawVideo(video, null);
        this.ctx.restore();

        // Generate pseudo-LiDAR point cloud overlay (depth simulation based on landmarks)
        this.drawLidarPointCloud(hands, face, time);

        // Add LiDAR scanning effects
        this.drawLidarScanningEffects(time);

        // Add technical HUD elements
        this.drawLidarHUD(time, hands, face);
    }

    drawLidarPointCloud(hands, face, time) {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        // Check if we have any landmarks detected
        const hasHands = hands && hands.landmarks && hands.landmarks.length > 0;
        const hasFace = face && face.faceLandmarks && face.faceLandmarks.length > 0;

        // Generate dense point cloud following body contours
        this.generateBodyPointCloud(hands, face, centerX, centerY, time);

        // Add ambient LIDAR returns (scattered points)
        // Generate more ambient points when no landmarks are detected
        const ambientMultiplier = (!hasHands && !hasFace) ? 3 : 1;
        this.generateAmbientLidarPoints(centerX, centerY, time, ambientMultiplier);

        // If no landmarks detected, add some central scanning points
        if (!hasHands && !hasFace) {
            this.drawCentralScanningPoints(centerX, centerY, time);
        }
    }

    generateBodyPointCloud(hands, face, centerX, centerY, time) {
        // Dense pseudo-LiDAR point cloud following detected body parts
        // Note: This is a visual simulation, not real depth sensing

        // Face point cloud
        if (face && face.faceLandmarks && face.faceLandmarks.length > 0) {
            const faceLandmarks = face.faceLandmarks[0];
            this.drawLidarPointCloudForLandmarks(faceLandmarks, centerX, centerY, 0.2, time, '#FF6B35'); // Orange-red for close face
        }

        // Hands point cloud
        if (hands && hands.landmarks) {
            hands.landmarks.forEach((hand, handIndex) => {
                if (!hand) return;
                const handColor = handIndex === 0 ? '#00FFFF' : '#FF00FF'; // Cyan for left, magenta for right
                this.drawLidarPointCloudForLandmarks(hand, centerX, centerY, 0.4, time, handColor);
            });
        }

        // Generate interpolated points between landmarks for denser cloud
        this.generateInterpolatedPointCloud(hands, face, centerX, centerY, time);
    }

    drawLidarPointCloudForLandmarks(landmarks, centerX, centerY, depthFactor, time, baseColor) {
        landmarks.forEach((landmark, index) => {
            if (!landmark) return;

            const screenPos = this.transformLandmark(landmark);

            // Pseudo-depth calculation: distance from screen center (not real depth)
            // This simulates depth perception but is not based on actual distance to camera
            const distanceFromCenter = Math.hypot(screenPos.x - centerX, screenPos.y - centerY);
            const maxDistance = Math.hypot(centerX, centerY);
            const pseudoDepth = (distanceFromCenter / maxDistance) * depthFactor;

            // Pseudo-depth-based color mapping (simulated depth perception)
            let r, g, b;
            if (pseudoDepth < 0.3) {
                // Close: Red to orange
                r = Math.floor(255 * (1 - pseudoDepth * 2));
                g = Math.floor(100 + 155 * pseudoDepth * 2);
                b = Math.floor(50 * pseudoDepth);
            } else if (pseudoDepth < 0.7) {
                // Medium: Orange to green
                r = Math.floor(200 * (1 - pseudoDepth));
                g = Math.floor(150 + 105 * (pseudoDepth - 0.3) / 0.4);
                b = Math.floor(50 * (pseudoDepth - 0.3) / 0.4);
            } else {
                // Far: Green to blue
                r = Math.floor(100 * (1 - pseudoDepth));
                g = Math.floor(200 * (1 - pseudoDepth));
                b = Math.floor(100 + 155 * (pseudoDepth - 0.7) / 0.3);
            }

            // Add time-based variation for scanning effect
            const scanPulse = Math.sin(time * 6 + index * 0.5) * 0.3 + 0.7;
            const alpha = 0.8 * scanPulse;

            // Draw main point
            this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
            this.ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
            this.ctx.shadowBlur = 3;

            const pointSize = 3 + Math.sin(time * 4 + index) * 1;
            this.ctx.beginPath();
            this.ctx.arc(screenPos.x, screenPos.y, pointSize, 0, Math.PI * 2);
            this.ctx.fill();

            // Add secondary points around main landmark for denser cloud
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2 + time;
                const radius = 8 + Math.random() * 6;
                const offsetX = Math.cos(angle) * radius;
                const offsetY = Math.sin(angle) * radius;

                const secondaryAlpha = alpha * 0.4;
                this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${secondaryAlpha})`;
                this.ctx.beginPath();
                this.ctx.arc(screenPos.x + offsetX, screenPos.y + offsetY, 1.5, 0, Math.PI * 2);
                this.ctx.fill();
            }

            this.ctx.shadowBlur = 0;
        });
    }

    generateInterpolatedPointCloud(hands, face, centerX, centerY, time) {
        // Generate interpolated points between landmarks for smoother contours

        // Face contour interpolation
        if (face && face.faceLandmarks && face.faceLandmarks.length > 0) {
            const faceOutline = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109, 10];
            this.interpolateLandmarkCloud(face.faceLandmarks[0], faceOutline, centerX, centerY, time, 0.25, '#FF8C42');
        }

        // Hand contours
        if (hands && hands.landmarks) {
            hands.landmarks.forEach((hand, handIndex) => {
                if (!hand) return;
                const handColor = handIndex === 0 ? '#00FFFF' : '#FF00FF';
                this.interpolateLandmarkCloud(hand, HAND_CONNECTIONS.flat(), centerX, centerY, time, 0.35, handColor);
            });
        }
    }

    interpolateLandmarkCloud(landmarks, connections, centerX, centerY, time, depthFactor, baseColor) {
        // Create interpolated points along connections for denser cloud
        for (let i = 0; i < connections.length; i += 2) {
            const idx1 = connections[i];
            const idx2 = connections[i + 1];

            if (!landmarks[idx1] || !landmarks[idx2]) continue;

            const p1 = this.transformLandmark(landmarks[idx1]);
            const p2 = this.transformLandmark(landmarks[idx2]);

            // Interpolate points between landmarks
            const steps = 8;
            for (let step = 1; step < steps; step++) {
                const t = step / steps;
                const x = p1.x + (p2.x - p1.x) * t;
                const y = p1.y + (p2.y - p1.y) * t;

                const distanceFromCenter = Math.hypot(x - centerX, y - centerY);
                const maxDistance = Math.hypot(centerX, centerY);
                const pseudoDepth = (distanceFromCenter / maxDistance) * depthFactor;

                // Pseudo-depth color mapping (simplified)
                let r, g, b;
                if (pseudoDepth < 0.4) {
                    r = 255; g = Math.floor(100 + 155 * pseudoDepth); b = 50;
                } else if (pseudoDepth < 0.8) {
                    r = Math.floor(200 * (1 - pseudoDepth)); g = 200; b = 50;
                } else {
                    r = 50; g = Math.floor(200 * (1 - pseudoDepth)); b = 255;
                }

                const alpha = 0.3 + Math.sin(time * 3 + step) * 0.2;
                this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;

                const pointSize = 1 + Math.random() * 1.5;
                this.ctx.beginPath();
                this.ctx.arc(x, y, pointSize, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    generateAmbientLidarPoints(centerX, centerY, time, multiplier = 1) {
        // Generate scattered ambient LIDAR returns for realism
        const numAmbientPoints = 150 * multiplier;

        for (let i = 0; i < numAmbientPoints; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * Math.min(this.canvas.width, this.canvas.height) * 0.4;
            const x = centerX + Math.cos(angle) * distance;
            const y = centerY + Math.sin(angle) * distance;

            const pseudoDepth = distance / (Math.min(this.canvas.width, this.canvas.height) * 0.4);

            // Ambient points are mostly green-blue (background)
            let r, g, b;
            if (pseudoDepth < 0.5) {
                r = Math.floor(100 * pseudoDepth * 2);
                g = Math.floor(150 + 105 * pseudoDepth);
                b = Math.floor(200 * pseudoDepth);
            } else {
                r = Math.floor(50 * (pseudoDepth - 0.5) * 2);
                g = Math.floor(200 * (1 - pseudoDepth));
                b = Math.floor(150 + 105 * (pseudoDepth - 0.5));
            }

            const alpha = 0.1 + Math.sin(time * 2 + i * 0.1) * 0.05;
            this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;

            const pointSize = 0.5 + Math.random() * 1.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, pointSize, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    drawLidarScanningEffects(time) {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const maxDistance = Math.min(this.canvas.width, this.canvas.height) * 0.4;

        // Rotating scan line
        const sweepAngle = time * 1.5;
        this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.4)';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(centerX, centerY);
        this.ctx.lineTo(
            centerX + Math.cos(sweepAngle) * maxDistance,
            centerY + Math.sin(sweepAngle) * maxDistance
        );
        this.ctx.stroke();

        // Scan arc
        this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.1)';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, maxDistance * 0.7, sweepAngle - 0.2, sweepAngle);
        this.ctx.stroke();

        // Pulsing center indicator
        const pulse = Math.sin(time * 4) * 0.3 + 0.7;
        this.ctx.strokeStyle = `rgba(0, 255, 0, ${pulse * 0.5})`;
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
        this.ctx.stroke();
    }

    drawLidarHUD(time, hands, face) {
        // Technical HUD overlay (LiDAR simulation)
        this.ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
        this.ctx.font = '12px Share Tech Mono';

        // Top-left status
        this.ctx.fillText('LiDAR SIMULATION', 20, 30);
        this.ctx.fillText('PSEUDO-DEPTH ACTIVE', 20, 45);
        this.ctx.fillText(`SCAN: ${Math.floor(time * 57) % 360}°`, 20, 60);

        // Detection status
        const handsDetected = hands && hands.landmarks ? hands.landmarks.length : 0;
        const faceDetected = face && face.faceLandmarks && face.faceLandmarks.length > 0 ? 1 : 0;
        const totalDetections = handsDetected + faceDetected;

        this.ctx.fillText(`HANDS: ${handsDetected}`, 20, 80);
        this.ctx.fillText(`FACE: ${faceDetected}`, 20, 95);

        // Show ambient scanning status when no detections
        if (totalDetections === 0) {
            this.ctx.fillText('AMBIENT SCAN: ACTIVE', 20, 110);
            this.ctx.fillText('SCANNING ENVIRONMENT', 20, 125);
        }

        // Distance indicators around the person
        this.drawDistanceLabels(hands, face);

        // Fine grid overlay
        this.drawFineGrid();
    }

    drawDistanceLabels(hands, face) {
        this.ctx.fillStyle = 'rgba(0, 255, 0, 0.6)';
        this.ctx.font = '10px Share Tech Mono';

        // Face distance
        if (face && face.faceLandmarks && face.faceLandmarks.length > 0) {
            const nose = face.faceLandmarks[0][1]; // Nose tip
            if (nose) {
                const nosePos = this.transformLandmark(nose);
                this.ctx.fillText('0.8m', nosePos.x - 20, nosePos.y - 30);
            }
        }

        // Hand distances
        if (hands && hands.landmarks) {
            hands.landmarks.forEach((hand, index) => {
                if (!hand) return;
                const wrist = hand[0]; // Wrist
                if (wrist) {
                    const wristPos = this.transformLandmark(wrist);
                    const distance = index === 0 ? '1.2m' : '1.1m';
                    this.ctx.fillText(distance, wristPos.x - 15, wristPos.y - 20);
                }
            });
        }
    }

    drawFineGrid() {
        // Subtle fine grid for technical look
        this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.1)';
        this.ctx.lineWidth = 1;

        const gridSize = 40;

        // Vertical lines
        for (let x = 0; x < this.canvas.width; x += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.canvas.height);
            this.ctx.stroke();
        }

        // Horizontal lines
        for (let y = 0; y < this.canvas.height; y += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }
    }

    renderAirDraw(hands) {
        // Track Index Finger Tip (8) - transformed
        if(hands && hands.landmarks.length > 0 && hands.landmarks[0] && hands.landmarks[0][8]) {
            const tip = hands.landmarks[0][8];
            const transformed = this.transformLandmark(tip);
            this.drawPath.push({x: transformed.x, y: transformed.y});
        }

        // Draw Path
        if(this.drawPath.length > 0) {
            this.ctx.shadowBlur = 10;
            this.ctx.shadowColor = CONFIG.colors.primary;
            this.ctx.strokeStyle = CONFIG.colors.primary;
            this.ctx.lineWidth = 4;
            this.ctx.lineJoin = 'round';
            this.ctx.beginPath();
            this.ctx.moveTo(this.drawPath[0].x, this.drawPath[0].y);
            for(let i=1; i<this.drawPath.length; i++) {
                this.ctx.lineTo(this.drawPath[i].x, this.drawPath[i].y);
            }
            this.ctx.stroke();
            this.ctx.shadowBlur = 0; // Reset
        }
    }

    // Map video coordinates to canvas coordinates (accounting for cropping/mirroring)
    mapVideoRectToCanvas(bbox, video, vt) {
        const [vx, vy, vw, vh] = bbox; // bbox coordinates in video pixels

        // Scale factors from video to drawn area
        const sx = vt.width / video.videoWidth;
        const sy = vt.height / video.videoHeight;

        // Apply scale + offset of the drawn area in canvas
        let cx = vt.x + vx * sx;
        let cy = vt.y + vy * sy;
        let cw = vw * sx;
        let ch = vh * sy;

        // Video is mirrored (scaleX(-1)), so mirror X coordinates
        // Mirror around the center of the drawn area
        cx = vt.x + (vt.width - (vx + vw) * sx);

        return { x: cx, y: cy, w: cw, h: ch };
    }

    renderIntel(objects, video) {
        if(!objects || !video) return;

        // Objects are already filtered by TacticalOS.filterIntelObjects
        // Just use them directly to avoid double filtering
        objects.forEach(obj => {
            const [objX, objY, objWidth, objHeight] = obj.bbox;

            // Map video coordinates to canvas coordinates correctly
            const vt = this.videoTransform;
            let r;
            if (!vt) {
                // Fallback if no transform info available
                const scaleX = this.canvas.width / video.videoWidth;
                const scaleY = this.canvas.height / video.videoHeight;
                r = {
                    x: objX * scaleX,
                    y: objY * scaleY,
                    w: objWidth * scaleX,
                    h: objHeight * scaleY
                };
            } else {
                // Use proper coordinate mapping
                r = this.mapVideoRectToCanvas([objX, objY, objWidth, objHeight], video, vt);
            }

            // Get object threat level and color
            const threatLevel = this.getObjectThreatLevel(obj.class);
            const objColor = this.getObjectColor(obj.class, threatLevel);

            // Draw enhanced tactical bounding box
            this.drawTacticalBoundingBox(r, objColor, threatLevel, obj.score);

            // Draw object info panel
            this.drawObjectInfoPanel(r, obj, objColor, threatLevel);

            // Draw targeting system
            this.drawTargetingSystem(r, objColor, threatLevel);

            // Draw corner markers
            this.drawCornerMarkers(r, objColor);
        });
        // Note: HUD is drawn in the main loop to avoid duplication
    }

    updateHologram(results) {
        if (!this.sandtableGroup || !this.sandtableMesh) return;

        const hands = results.hands;
        const time = performance.now() * 0.001;

        // Update shader uniforms
        if (this.sandtableMesh.material.uniforms) {
            this.sandtableMesh.material.uniforms.time.value = time;
        }

        let leftHand = null;
        let rightHand = null;
        let hasValidTracking = false;

        // Identify left and right hands based on wrist X position
        if (hands && hands.length > 0) {
            hands.forEach(hand => {
                if (!leftHand || hand[0].x < leftHand[0].x) leftHand = hand;
                if (!rightHand || hand[0].x > rightHand[0].x) rightHand = hand;
            });

            // Check if we have valid hand data
            hasValidTracking = (leftHand && leftHand.length >= 18) || (rightHand && rightHand.length >= 18);
        }

        // Tracking persistence logic
        if (hasValidTracking) {
            // Update last valid hands when we have good tracking
            if (leftHand && leftHand.length >= 18) {
                this.sandtableState.lastValidLeftHand = [...leftHand]; // Deep copy
            }
            if (rightHand && rightHand.length >= 18) {
                this.sandtableState.lastValidRightHand = [...rightHand]; // Deep copy
            }

            // Reset grace period
            this.sandtableState.trackingGraceFrames = this.sandtableState.maxGraceFrames;

            // Lock hologram after stable tracking
            if (!this.sandtableState.hologramLocked) {
                this.sandtableState.lockThresholdFrames--;
                if (this.sandtableState.lockThresholdFrames <= 0) {
                    this.sandtableState.hologramLocked = true;
                    console.log('HOLOGRAM: Locked - stable tracking achieved');
                }
            }
        } else {
            // Use last valid hands during grace period
            if (this.sandtableState.trackingGraceFrames > 0) {
                leftHand = this.sandtableState.lastValidLeftHand;
                rightHand = this.sandtableState.lastValidRightHand;
                this.sandtableState.trackingGraceFrames--;

                // Use position prediction if available and hologram is locked
                if (this.sandtableState.hologramLocked && this.sandtableState.positionHistory.length >= 2) {
                    const predictedPose = this.predictHologramPose(time);
                    if (predictedPose) {
                        this.sandtableGroup.position.copy(predictedPose.position);
                        this.sandtableGroup.setRotationFromMatrix(predictedPose.rotation);
                        console.log(`HOLOGRAM: Using predicted pose (${this.sandtableState.trackingGraceFrames} frames left)`);
                        // Skip to fade logic to avoid updating with old hand data
                        // Smooth opacity transitions with adaptive speed
                        const currentOpacity = this.sandtableMesh.material.uniforms.hologramOpacity.value;
                        const lerpSpeed = 0.05; // Slower fade during prediction
                        const newOpacity = THREE.MathUtils.lerp(currentOpacity, this.targetHologramOpacity, lerpSpeed);
                        this.sandtableMesh.material.uniforms.hologramOpacity.value = newOpacity;
                        this.sandtableGroup.visible = newOpacity > 0.01;
                        return; // Exit early, don't try to update with invalid hand data
                    }
                }

                console.log(`HOLOGRAM: Using cached tracking (${this.sandtableState.trackingGraceFrames} frames left)`);
            } else {
                // Grace period expired, unlock hologram
                this.sandtableState.hologramLocked = false;
                this.sandtableState.lockThresholdFrames = 30; // Reset for next lock attempt
                this.sandtableState.positionHistory = []; // Clear prediction history
            }
        }

        // Hologram Anchor System: Follow left hand palm with persistence
        if (leftHand && leftHand.length >= 18) {
            // Calculate palm rotation using wrist (0), index MCP (5), and pinky MCP (17)
            const wrist = this.landmarkTo3D(leftHand[0]);
            const indexMCP = this.landmarkTo3D(leftHand[5]);
            const pinkyMCP = this.landmarkTo3D(leftHand[17]);

            // Create palm coordinate system
            const palmForward = new THREE.Vector3().subVectors(indexMCP, wrist).normalize();
            const palmRight = new THREE.Vector3().subVectors(pinkyMCP, indexMCP).normalize();
            const palmUp = new THREE.Vector3().crossVectors(palmForward, palmRight).normalize();

            // Recalculate right vector to ensure orthogonality
            palmRight.crossVectors(palmUp, palmForward).normalize();

            // Create rotation matrix from palm vectors
            const palmMatrix = new THREE.Matrix4();
            palmMatrix.makeBasis(palmRight, palmUp, palmForward.negate());

            // Position hologram 5cm above palm center
            const palmCenter = new THREE.Vector3(
                (wrist.x + indexMCP.x + pinkyMCP.x) / 3,
                (wrist.y + indexMCP.y + pinkyMCP.y) / 3,
                (wrist.z + indexMCP.z + pinkyMCP.z) / 3
            );

            const hologramOffset = new THREE.Vector3(0, 0.05, 0); // 5cm up
            hologramOffset.applyMatrix4(palmMatrix);

            const targetPosition = palmCenter.clone().add(hologramOffset);

            // Store position history for prediction
            this.sandtableState.positionHistory.push({
                position: targetPosition.clone(),
                rotation: palmMatrix.clone(),
                timestamp: time
            });

            // Keep only recent history
            if (this.sandtableState.positionHistory.length > this.sandtableState.maxHistoryLength) {
                this.sandtableState.positionHistory.shift();
            }

            // Smooth position interpolation
            this.sandtableGroup.position.lerp(targetPosition, 0.1);

            // Apply palm rotation to hologram
            this.sandtableGroup.setRotationFromMatrix(palmMatrix);

            // Pinch-to-Zoom: Scale based on left hand pinch distance
            if (leftHand[4] && leftHand[8]) {
                const thumbTip = this.landmarkTo3D(leftHand[4]);
                const indexTip = this.landmarkTo3D(leftHand[8]);
                const pinchDistance = thumbTip.distanceTo(indexTip);

                // Map distance 2cm-15cm to scale 0.1x-2.0x
                const minDistance = 0.02;
                const maxDistance = 0.15;
                const minScale = 0.1;
                const maxScale = 2.0;

                let targetScale = minScale;
                if (pinchDistance >= minDistance && pinchDistance <= maxDistance) {
                    const t = (pinchDistance - minDistance) / (maxDistance - minDistance);
                    targetScale = minScale + t * (maxScale - minScale);
                } else if (pinchDistance > maxDistance) {
                    targetScale = maxScale;
                }

                // Smooth scale interpolation
                const currentScale = this.sandtableGroup.scale.x;
                const newScale = THREE.MathUtils.lerp(currentScale, targetScale, 0.1);
                this.sandtableGroup.scale.setScalar(newScale);
            }

            // Finger Sculpting: Use right hand index tip as brush
            if (rightHand && rightHand[8]) {
                const brushTip3D = this.landmarkTo3D(rightHand[8]);

                // Check if brush is within hologram bounding box
                const hologramBounds = new THREE.Box3().setFromObject(this.sandtableGroup);
                const isInBounds = hologramBounds.containsPoint(brushTip3D);

                if (isInBounds) {
                    // Calculate deformation based on brush movement
                    const heightDelta = this.calculateBrushDelta(rightHand[8]);

                    // Position brush visual feedback
                    if (this.brushRing) {
                        this.brushRing.position.copy(brushTip3D);
                        this.brushRing.position.y += 0.02;
                        this.brushRing.visible = true;
                    }

                    // Sculpt terrain
                    this.sculptTerrain(brushTip3D.x, brushTip3D.z, heightDelta);
                } else {
                    if (this.brushRing) this.brushRing.visible = false;
                }
            } else {
                if (this.brushRing) this.brushRing.visible = false;
            }

            // Fade in hologram
            this.targetHologramOpacity = 1.0;

            // Calculate average wrist Y for height scaling
            const avgWristY = (leftHand[0].y + rightHand[0].y) / 2;

            // Scale height based on wrist Y movement (0.05-0.5 range)
            const heightDelta = this.sandtableState.lastLeftWristY - avgWristY;
            let newScaleHeight = this.sandtableMesh.material.uniforms.scaleHeight.value;
            newScaleHeight = Math.max(0.05, Math.min(0.5, newScaleHeight + heightDelta * 2.0));
            this.sandtableMesh.material.uniforms.scaleHeight.value = newScaleHeight;

            // Calculate distance between wrists for plane scaling (0.5-2.0 range)
            const wristDistance = Math.sqrt(
                Math.pow(leftHand[0].x - rightHand[0].x, 2) +
                Math.pow(leftHand[0].y - rightHand[0].y, 2)
            );
            const scalePlane = Math.max(0.5, Math.min(2.0, wristDistance * 4.0));
            this.sandtableMesh.material.uniforms.scalePlane.value = scalePlane;

            // Update state for next frame
            this.sandtableState.lastLeftWristY = leftHand[0].y;
            this.sandtableState.lastRightWristY = rightHand[0].y;

            // Check for sculpting mode (double pinch) - robust detection with smoothing
            const leftPinchDistance = this.getPinchDistance(leftHand[4], leftHand[8]);
            const rightPinchDistance = this.getPinchDistance(rightHand[4], rightHand[8]);

            // Add validation for pinch detection
            const leftHandValid = leftHand && leftHand[4] && leftHand[8];
            const rightHandValid = rightHand && rightHand[4] && rightHand[8];

            // Smooth pinch distances to reduce jitter
            if (!this.sandtableState.pinchHistory) {
                this.sandtableState.pinchHistory = {
                    left: [leftPinchDistance, leftPinchDistance],
                    right: [rightPinchDistance, rightPinchDistance]
                };
            }

            // Update history with exponential smoothing
            this.sandtableState.pinchHistory.left[1] = this.sandtableState.pinchHistory.left[0];
            this.sandtableState.pinchHistory.left[0] =
                this.sandtableState.pinchHistory.left[0] * 0.7 + leftPinchDistance * 0.3;

            this.sandtableState.pinchHistory.right[1] = this.sandtableState.pinchHistory.right[0];
            this.sandtableState.pinchHistory.right[0] =
                this.sandtableState.pinchHistory.right[0] * 0.7 + rightPinchDistance * 0.3;

            const smoothedLeftPinch = this.sandtableState.pinchHistory.left[0];
            const smoothedRightPinch = this.sandtableState.pinchHistory.right[0];

            // Pinch detection with hysteresis to prevent flickering
            const pinchThresholdEnter = 0.08; // Tighter threshold to enter sculpt mode
            const pinchThresholdExit = 0.15;  // Looser threshold to exit (prevents flickering)

            const currentPinchTight = leftHandValid && rightHandValid &&
                                     smoothedLeftPinch < pinchThresholdEnter &&
                                     smoothedRightPinch < pinchThresholdEnter;

            const currentPinchLoose = (!leftHandValid || !rightHandValid) ||
                                     smoothedLeftPinch > pinchThresholdExit ||
                                     smoothedRightPinch > pinchThresholdExit;

            // Use hysteresis: different thresholds for enter/exit
            let isSculpting = this.sandtableState.sculpting; // Default to current state

            if (currentPinchTight && !this.sandtableState.sculpting) {
                isSculpting = true; // Enter sculpt mode
            } else if (currentPinchLoose && this.sandtableState.sculpting) {
                isSculpting = false; // Exit sculpt mode
            }

            if (isSculpting && !this.sandtableState.sculpting) {
                // Start sculpting
                this.sandtableState.sculpting = true;
                if (this.brushRing) this.brushRing.visible = true;
                if (this.innerBrushRing) this.innerBrushRing.visible = true;
                log('SANDTABLE: SCULPT MODE ACTIVATED');
            } else if (!isSculpting && this.sandtableState.sculpting) {
                // Stop sculpting
                this.sandtableState.sculpting = false;
                if (this.brushRing) this.brushRing.visible = false;
                if (this.innerBrushRing) this.innerBrushRing.visible = false;
                log('SANDTABLE: SCULPT MODE DEACTIVATED');
            }

            if (this.sandtableState.sculpting) {
                // Calculate brush position (midpoint of both pinches)
                const leftPinch3D = this.landmarkTo3D(leftHand[8], -0.8); // Index finger tip
                const rightPinch3D = this.landmarkTo3D(rightHand[8], -0.8);

                const brushX = (leftPinch3D.x + rightPinch3D.x) / 2;
                const brushZ = (leftPinch3D.z + rightPinch3D.z) / 2;

                // Position brush rings
                const brushY = 0.15; // Slightly above terrain
                this.brushRing.position.set(brushX, brushY, brushZ);
                this.innerBrushRing.position.set(brushX, brushY + 0.02, brushZ); // Slightly higher

                // Calculate brush radius based on pinch distance with manual multiplier
                const avgPinchDistance = (leftPinchDistance + rightPinchDistance) / 2;
                const baseRadius = Math.max(0.5, Math.min(3.0, avgPinchDistance * 30));
                this.sandtableState.brushRadius = baseRadius * this.sandtableState.brushSizeMultiplier;

                // Scale brush rings
                const scale = this.sandtableState.brushRadius;
                this.brushRing.scale.setScalar(scale);
                this.innerBrushRing.scale.setScalar(scale * 0.6); // Inner ring smaller

                // Animate brush rings with different phases for visual interest
                const pulse1 = Math.sin(time * 0.015) * 0.15 + 0.85;
                const pulse2 = Math.sin(time * 0.02 + Math.PI) * 0.1 + 0.9;

                this.brushRing.scale.multiplyScalar(pulse1);
                this.innerBrushRing.scale.multiplyScalar(pulse2);

                // Sculpt terrain
                this.sculptTerrain(brushX, brushZ, heightDelta);
            }
        } else {
            // Fade out hologram when left hand is lost
            // If hologram is locked, fade more slowly to maintain presence
            const fadeSpeed = this.sandtableState.hologramLocked ? 0.02 : 0.08;
            this.targetHologramOpacity = Math.max(0, this.targetHologramOpacity - fadeSpeed);

            // If hologram was locked and we still have some opacity, keep it visible longer
            if (this.sandtableState.hologramLocked && this.targetHologramOpacity < 0.1) {
                this.targetHologramOpacity = 0.1; // Minimum visibility when locked
            }
        }

        // Smooth opacity transitions with adaptive speed
        const currentOpacity = this.sandtableMesh.material.uniforms.hologramOpacity.value;
        const lerpSpeed = hasValidTracking ? 0.1 : 0.03; // Faster fade-in, slower fade-out
        const newOpacity = THREE.MathUtils.lerp(currentOpacity, this.targetHologramOpacity, lerpSpeed);
        this.sandtableMesh.material.uniforms.hologramOpacity.value = newOpacity;

        // Hide completely when very transparent and not locked
        if (this.sandtableState.hologramLocked) {
            this.sandtableGroup.visible = newOpacity > 0.05; // Keep visible longer when locked
        } else {
            this.sandtableGroup.visible = newOpacity > 0.01;
        }
    }

    calculateBrushDelta(indexTip) {
        if (!this.lastBrushY) {
            this.lastBrushY = indexTip.y;
            return 0;
        }

        const delta = this.lastBrushY - indexTip.y;
        this.lastBrushY = indexTip.y;

        return delta * 5.0;
    }

    predictHologramPose(currentTime) {
        if (this.sandtableState.positionHistory.length < 2) return null;

        const history = this.sandtableState.positionHistory;
        const newest = history[history.length - 1];
        const oldest = history[0];

        // Calculate velocity (position change over time)
        const timeDiff = newest.timestamp - oldest.timestamp;
        if (timeDiff === 0) return newest; // Avoid division by zero

        const velocity = new THREE.Vector3()
            .subVectors(newest.position, oldest.position)
            .divideScalar(timeDiff);

        // Predict next position based on velocity
        const predictionTime = currentTime - newest.timestamp;
        const predictedPosition = newest.position.clone().add(
            velocity.clone().multiplyScalar(predictionTime)
        );

        // For rotation, just use the last known rotation (rotation prediction is complex)
        const predictedRotation = newest.rotation.clone();

        return {
            position: predictedPosition,
            rotation: predictedRotation
        };
    }

    getPinchDistance(thumbTip, indexTip) {
        return Math.sqrt(
            Math.pow(thumbTip.x - indexTip.x, 2) +
            Math.pow(thumbTip.y - indexTip.y, 2)
        );
    }

    sculptTerrain(brushX, brushZ, heightDelta) {
        if (!this.sandtableMesh || !this.originalPositions || !this.sandtableState) return;

        const geometry = this.sandtableMesh.geometry;
        const positions = geometry.attributes.position.array;
        const brushRadius = this.sandtableState.brushRadius || 2.0;

        // Performance optimization: reduce update frequency
        if (!this.lastSculptTime) this.lastSculptTime = 0;
        const now = performance.now();
        if (now - this.lastSculptTime < 16) return; // Limit to ~60fps max for sculpting
        this.lastSculptTime = now;

        // Limit deformation rate to prevent extreme changes
        const maxDeformation = 0.03; // Reduced for smoother performance
        const clampedHeightDelta = Math.max(-maxDeformation, Math.min(maxDeformation, heightDelta));

        // Pre-calculate brush bounds for performance (avoid checking every vertex)
        const brushRadiusSquared = brushRadius * brushRadius;
        const minX = brushX - brushRadius;
        const maxX = brushX + brushRadius;
        const minZ = brushZ - brushRadius;
        const maxZ = brushZ + brushRadius;

        // Get grid dimensions for spatial optimization
        const gridSize = Math.sqrt(positions.length / 3); // Assuming square grid
        const verticesPerRow = gridSize;

        let verticesModified = 0;

        // Spatial optimization: only check vertices in bounding box
        for (let i = 0; i < positions.length; i += 3) {
            const vx = positions[i];
            const vz = positions[i + 2];

            // Quick bounds check before expensive distance calculation
            if (vx < minX || vx > maxX || vz < minZ || vz > maxZ) continue;

            const distanceSquared = (vx - brushX) * (vx - brushX) + (vz - brushZ) * (vz - brushZ);

            if (distanceSquared <= brushRadiusSquared) {
                const distance = Math.sqrt(distanceSquared);

                // Gaussian falloff for smoother deformation (more natural than linear)
                const sigma = brushRadius * 0.3;
                const falloff = Math.exp(-(distance * distance) / (2 * sigma * sigma));

                const deformation = clampedHeightDelta * falloff * 6.0;

                // Apply deformation with limits
                const originalY = this.originalPositions[i + 1];
                const newY = positions[i + 1] + deformation;

                // Limit deformation range with softer clamping
                const maxHeight = originalY + 1.5;
                const minHeight = originalY - 1.5;
                positions[i + 1] = Math.max(minHeight, Math.min(maxHeight, newY));

                verticesModified++;
            }
        }

        if (verticesModified > 0) {
            // Batch updates to reduce GPU uploads
            if (!this.geometryUpdatePending) {
                this.geometryUpdatePending = true;
                requestAnimationFrame(() => {
                    geometry.attributes.position.needsUpdate = true;
                    geometry.computeVertexNormals();
                    this.geometryUpdatePending = false;
                });
            }
        }
    }

    filterIntelObjects(objects) {
        // Filter objects by score and expand detection classes
        const minScore = 0.3; // Lower threshold for more detections
        const priorityClasses = [
            'person', 'car', 'truck', 'bus', 'motorcycle', 'bicycle',
            'cell phone', 'laptop', 'mouse', 'keyboard', 'remote', 'book',
            'bottle', 'cup', 'bowl', 'chair', 'couch', 'bed', 'dining table',
            'tv', 'refrigerator', 'microwave', 'toaster', 'sink', 'toilet',
            'backpack', 'umbrella', 'handbag', 'tie', 'suitcase',
            'frisbee', 'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat',
            'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
            'banana', 'apple', 'orange', 'broccoli', 'carrot', 'pizza',
            'donut', 'cake', 'chair', 'sofa', 'pottedplant', 'bed', 'diningtable',
            'toilet', 'tvmonitor', 'laptop', 'mouse', 'remote', 'keyboard',
            'cell phone', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator',
            'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier',
            'toothbrush', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl',
            'banana', 'apple', 'sandwich', 'orange', 'broccoli', 'carrot',
            'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant',
            'bed', 'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote',
            'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink',
            'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear',
            'hair drier', 'toothbrush'
        ];

        return objects
            .filter(obj => obj.score >= minScore)
            .filter(obj => {
                const className = obj.class.toLowerCase();
                // Include all priority classes plus specific items
                return priorityClasses.includes(className) ||
                       className.includes('phone') || className.includes('cell') ||
                       className.includes('shoe') || className.includes('boot') || className.includes('sneaker') ||
                       className.includes('shirt') || className.includes('pants') || className.includes('trouser') ||
                       className.includes('jacket') || className.includes('coat') || className.includes('sweater') ||
                       className.includes('hat') || className.includes('cap') || className.includes('helmet') ||
                       className.includes('bag') || className.includes('backpack') || className.includes('handbag') ||
                       className.includes('watch') || className.includes('glasses') || className.includes('jewelry') ||
                       className.includes('wallet') || className.includes('keys') || className.includes('remote');
            })
            .sort((a, b) => b.score - a.score) // Sort by confidence
            .slice(0, 20); // Increased limit to 20 objects for more detections
    }

    getObjectThreatLevel(objClass) {
        const threatClasses = {
            high: ['person', 'car', 'truck', 'motorcycle'],
            medium: ['cell phone', 'laptop', 'backpack', 'handbag'],
            low: ['bottle', 'cup', 'chair', 'book']
        };

        const className = objClass.toLowerCase();
        if (threatClasses.high.some(cls => className.includes(cls))) return 'HIGH';
        if (threatClasses.medium.some(cls => className.includes(cls))) return 'MEDIUM';
        return 'LOW';
    }

    getObjectColor(objClass, threatLevel) {
        // Color based on object type and threat level
        const className = objClass.toLowerCase();

        if (className.includes('person')) return '#FF0055'; // Red for people
        if (className.includes('phone') || className.includes('cell')) return '#00FFFF'; // Cyan for electronics
        if (className.includes('car') || className.includes('vehicle')) return '#FFFF00'; // Yellow for vehicles
        if (className.includes('bottle') || className.includes('cup')) return '#00FF00'; // Green for containers
        if (className.includes('bag') || className.includes('backpack')) return '#FF00FF'; // Magenta for bags

        // Threat level colors
        switch(threatLevel) {
            case 'HIGH': return '#FF0055';
            case 'MEDIUM': return '#FFFF00';
            case 'LOW': return '#00FF00';
            default: return '#FFFFFF';
        }
    }

    drawTacticalBoundingBox(rect, color, threatLevel, score) {
        const { x, y, w, h } = rect;
        const time = performance.now() * 0.001;
        
        // Calculate 3D depth based on object size (larger = closer = more depth)
        const depthFactor = Math.min(0.3, Math.max(0.1, (w * h) / 50000));
        const depth = Math.max(15, Math.min(50, w * depthFactor));
        
        // Animated pulse for scanning effect
        const pulse = Math.sin(time * 3) * 0.3 + 0.7;
        const scanOffset = (time * 50) % h;
        
        // === 3D WIREFRAME BOUNDING BOX ===
        
        // Calculate 3D perspective offset (simulates rotation based on position)
        const centerScreenX = this.canvas.width / 2;
        const objectCenterX = x + w / 2;
        const perspectiveAngle = (objectCenterX - centerScreenX) / centerScreenX * 0.3;
        const depthOffsetX = depth * perspectiveAngle;
        const depthOffsetY = -depth * 0.5; // Slight upward perspective
        
        // Back face (darker, offset)
        this.ctx.strokeStyle = this.adjustColorAlpha(color, 0.3);
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(x + depthOffsetX, y + depthOffsetY, w, h);
        
        // Connecting edges (depth lines)
        this.ctx.strokeStyle = this.adjustColorAlpha(color, 0.5);
        this.ctx.lineWidth = 1;
        
        // Top-left depth line
        this.ctx.beginPath();
        this.ctx.moveTo(x, y);
        this.ctx.lineTo(x + depthOffsetX, y + depthOffsetY);
        this.ctx.stroke();
        
        // Top-right depth line
        this.ctx.beginPath();
        this.ctx.moveTo(x + w, y);
        this.ctx.lineTo(x + w + depthOffsetX, y + depthOffsetY);
        this.ctx.stroke();
        
        // Bottom-left depth line
        this.ctx.beginPath();
        this.ctx.moveTo(x, y + h);
        this.ctx.lineTo(x + depthOffsetX, y + h + depthOffsetY);
        this.ctx.stroke();
        
        // Bottom-right depth line
        this.ctx.beginPath();
        this.ctx.moveTo(x + w, y + h);
        this.ctx.lineTo(x + w + depthOffsetX, y + h + depthOffsetY);
        this.ctx.stroke();
        
        // Front face (main bounding box) with glow
        this.ctx.shadowColor = color;
        this.ctx.shadowBlur = threatLevel === 'HIGH' ? 20 : 10;
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = threatLevel === 'HIGH' ? 3 : 2;
        this.ctx.strokeRect(x, y, w, h);
        this.ctx.shadowBlur = 0;
        
        // Scanning line effect
        this.ctx.strokeStyle = this.adjustColorAlpha(color, 0.6 * pulse);
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(x, y + scanOffset);
        this.ctx.lineTo(x + w, y + scanOffset);
        this.ctx.stroke();
        
        // Inner wireframe grid (3x3)
        this.ctx.strokeStyle = this.adjustColorAlpha(color, 0.2);
        this.ctx.lineWidth = 1;
        for (let i = 1; i < 3; i++) {
            // Vertical lines
            this.ctx.beginPath();
            this.ctx.moveTo(x + (w / 3) * i, y);
            this.ctx.lineTo(x + (w / 3) * i, y + h);
            this.ctx.stroke();
            // Horizontal lines
            this.ctx.beginPath();
            this.ctx.moveTo(x, y + (h / 3) * i);
            this.ctx.lineTo(x + w, y + (h / 3) * i);
            this.ctx.stroke();
        }
        
        // Dashed line for low confidence
        if (score < 0.5) {
            this.ctx.setLineDash([5, 5]);
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            this.ctx.lineWidth = 1;
            this.ctx.strokeRect(x, y, w, h);
            this.ctx.setLineDash([]);
        }
    }
    
    // Helper to adjust color alpha
    adjustColorAlpha(color, alpha) {
        if (color.startsWith('#')) {
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        return color;
    }

    drawObjectInfoPanel(rect, obj, color, threatLevel) {
        const { x: rectX, y: rectY, w, h } = rect;
        const time = performance.now() * 0.001;
        
        // Generate deterministic "technical data" based on object class hash
        const techData = this.generateTechnicalData(obj.class, obj.bbox);
        
        // Calculate panel size
        const panelWidth = 180;
        const panelHeight = 95;
        const panelX = rectX + w + 10; // Position to the right of object
        const panelY = rectY;
        
        // Check if panel would go off screen, flip to left side
        const actualPanelX = (panelX + panelWidth > this.canvas.width) ? rectX - panelWidth - 10 : panelX;
        const actualPanelY = Math.max(5, Math.min(panelY, this.canvas.height - panelHeight - 5));
        
        // Animated connection line from object to panel
        const pulse = Math.sin(time * 4) * 0.3 + 0.7;
        this.ctx.strokeStyle = this.adjustColorAlpha(color, 0.5 * pulse);
        this.ctx.lineWidth = 1;
        this.ctx.setLineDash([3, 3]);
        this.ctx.beginPath();
        if (actualPanelX > rectX) {
            this.ctx.moveTo(rectX + w, rectY + h / 2);
            this.ctx.lineTo(actualPanelX, actualPanelY + panelHeight / 2);
        } else {
            this.ctx.moveTo(rectX, rectY + h / 2);
            this.ctx.lineTo(actualPanelX + panelWidth, actualPanelY + panelHeight / 2);
        }
        this.ctx.stroke();
        this.ctx.setLineDash([]);
        
        // Panel background with glass effect
        this.ctx.fillStyle = 'rgba(0, 5, 10, 0.9)';
        this.ctx.fillRect(actualPanelX, actualPanelY, panelWidth, panelHeight);
        
        // Panel border with glow
        this.ctx.shadowColor = color;
        this.ctx.shadowBlur = 5;
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 1.5;
        this.ctx.strokeRect(actualPanelX, actualPanelY, panelWidth, panelHeight);
        this.ctx.shadowBlur = 0;
        
        // Corner accents
        const cornerSize = 8;
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 2;
        // Top-left
        this.ctx.beginPath();
        this.ctx.moveTo(actualPanelX, actualPanelY + cornerSize);
        this.ctx.lineTo(actualPanelX, actualPanelY);
        this.ctx.lineTo(actualPanelX + cornerSize, actualPanelY);
        this.ctx.stroke();
        // Top-right
        this.ctx.beginPath();
        this.ctx.moveTo(actualPanelX + panelWidth - cornerSize, actualPanelY);
        this.ctx.lineTo(actualPanelX + panelWidth, actualPanelY);
        this.ctx.lineTo(actualPanelX + panelWidth, actualPanelY + cornerSize);
        this.ctx.stroke();
        
        // Header with object class
        const classText = obj.class.toUpperCase();
        const confidenceText = `${Math.round(obj.score * 100)}%`;
        
        this.ctx.fillStyle = color;
        this.ctx.font = 'bold 11px Share Tech Mono';
        this.ctx.textAlign = 'left';
        this.ctx.fillText(`◆ ${classText}`, actualPanelX + 8, actualPanelY + 14);
        
        // Confidence bar
        const barWidth = 40;
        const barX = actualPanelX + panelWidth - barWidth - 8;
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        this.ctx.fillRect(barX, actualPanelY + 6, barWidth, 6);
        this.ctx.fillStyle = color;
        this.ctx.fillRect(barX, actualPanelY + 6, barWidth * obj.score, 6);
        
        // Divider line
        this.ctx.strokeStyle = this.adjustColorAlpha(color, 0.3);
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.moveTo(actualPanelX + 5, actualPanelY + 20);
        this.ctx.lineTo(actualPanelX + panelWidth - 5, actualPanelY + 20);
        this.ctx.stroke();
        
        // Technical data rows
        this.ctx.font = '9px Share Tech Mono';
        this.ctx.fillStyle = '#AAAAAA';
        
        const dataRows = [
            `MATERIAL: ${techData.material}`,
            `ORIGIN: ${techData.origin}`,
            `SERIAL: ${techData.serial}`,
            `STATUS: ${techData.status}`,
            `THREAT: ${threatLevel} | DIST: ${techData.distance}cm`
        ];
        
        dataRows.forEach((row, index) => {
            const rowY = actualPanelY + 32 + (index * 12);
            
            // Highlight certain values
            if (row.includes('THREAT:')) {
                this.ctx.fillStyle = threatLevel === 'HIGH' ? '#FF0055' : 
                                     threatLevel === 'MEDIUM' ? '#FFFF00' : '#00FF00';
            } else if (row.includes('STATUS:') && techData.status !== 'NOMINAL') {
                this.ctx.fillStyle = '#FFAA00';
            } else {
                this.ctx.fillStyle = '#AAAAAA';
            }
            
            this.ctx.fillText(row, actualPanelX + 8, rowY);
        });
        
        // Scanning indicator animation
        const scanY = actualPanelY + 20 + ((time * 30) % (panelHeight - 25));
        this.ctx.strokeStyle = this.adjustColorAlpha(color, 0.3 * pulse);
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.moveTo(actualPanelX, scanY);
        this.ctx.lineTo(actualPanelX + panelWidth, scanY);
        this.ctx.stroke();
    }
    
    // Draw 3D scan overlay panel for detected objects
    draw3DScanPanel(obj3D, video) {
        if (!obj3D || !obj3D.center) return;
        
        const time = performance.now() * 0.001;
        const vw = video.videoWidth || 640;
        const vh = video.videoHeight || 480;
        
        // Convert 3D center to screen coordinates
        const screenX = obj3D.center.x * this.canvas.width;
        const screenY = obj3D.center.y * this.canvas.height;
        
        // Panel dimensions
        const panelWidth = 160;
        const panelHeight = 85;
        let panelX = screenX + 60;
        let panelY = screenY - panelHeight / 2;
        
        // Ensure panel stays on screen
        panelX = Math.max(5, Math.min(panelX, this.canvas.width - panelWidth - 5));
        panelY = Math.max(5, Math.min(panelY, this.canvas.height - panelHeight - 5));
        
        // Color based on scan progress
        const scanProgress = obj3D.scanProgress || 0;
        const baseColor = scanProgress >= 100 ? '#00ff88' : '#00ffff';
        const pulse = Math.sin(time * 4) * 0.2 + 0.8;
        
        // Connection line to object center
        this.ctx.strokeStyle = `rgba(0, 255, 136, ${0.5 * pulse})`;
        this.ctx.lineWidth = 1;
        this.ctx.setLineDash([4, 4]);
        this.ctx.beginPath();
        this.ctx.moveTo(screenX, screenY);
        this.ctx.lineTo(panelX, panelY + panelHeight / 2);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
        
        // Panel background
        this.ctx.fillStyle = 'rgba(0, 8, 16, 0.92)';
        this.ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
        
        // Panel border
        this.ctx.shadowColor = baseColor;
        this.ctx.shadowBlur = 8;
        this.ctx.strokeStyle = baseColor;
        this.ctx.lineWidth = 1.5;
        this.ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);
        this.ctx.shadowBlur = 0;
        
        // Corner brackets
        const cornerLen = 10;
        this.ctx.strokeStyle = baseColor;
        this.ctx.lineWidth = 2;
        
        // Top-left
        this.ctx.beginPath();
        this.ctx.moveTo(panelX, panelY + cornerLen);
        this.ctx.lineTo(panelX, panelY);
        this.ctx.lineTo(panelX + cornerLen, panelY);
        this.ctx.stroke();
        
        // Bottom-right
        this.ctx.beginPath();
        this.ctx.moveTo(panelX + panelWidth - cornerLen, panelY + panelHeight);
        this.ctx.lineTo(panelX + panelWidth, panelY + panelHeight);
        this.ctx.lineTo(panelX + panelWidth, panelY + panelHeight - cornerLen);
        this.ctx.stroke();
        
        // Header - Object label
        this.ctx.fillStyle = baseColor;
        this.ctx.font = 'bold 11px Share Tech Mono';
        this.ctx.textAlign = 'left';
        this.ctx.fillText(`▸ ${obj3D.category.toUpperCase()}`, panelX + 8, panelY + 14);
        
        // 3D badge
        this.ctx.fillStyle = 'rgba(0, 255, 136, 0.2)';
        this.ctx.fillRect(panelX + panelWidth - 28, panelY + 4, 22, 12);
        this.ctx.fillStyle = '#00ff88';
        this.ctx.font = 'bold 8px Share Tech Mono';
        this.ctx.fillText('3D', panelX + panelWidth - 22, panelY + 12);
        
        // Divider
        this.ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.moveTo(panelX + 5, panelY + 20);
        this.ctx.lineTo(panelX + panelWidth - 5, panelY + 20);
        this.ctx.stroke();
        
        // Z-Depth information
        const estimatedDepth = obj3D.depth || (obj3D.center.z * 3).toFixed(2);
        this.ctx.font = '9px Share Tech Mono';
        this.ctx.fillStyle = '#00ffff';
        this.ctx.fillText(`Z-DEPTH: ${estimatedDepth}m`, panelX + 8, panelY + 33);
        
        // Confidence
        this.ctx.fillStyle = '#AAAAAA';
        this.ctx.fillText(`CONF: ${Math.round(obj3D.confidence * 100)}%`, panelX + 8, panelY + 46);
        
        // Scan progress bar
        const barX = panelX + 8;
        const barY = panelY + 54;
        const barWidth = panelWidth - 16;
        const barHeight = 8;
        
        // Bar background
        this.ctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
        this.ctx.fillRect(barX, barY, barWidth, barHeight);
        
        // Bar fill
        const fillWidth = (scanProgress / 100) * barWidth;
        const gradient = this.ctx.createLinearGradient(barX, 0, barX + fillWidth, 0);
        gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
        gradient.addColorStop(1, 'rgba(0, 255, 136, 1)');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(barX, barY, fillWidth, barHeight);
        
        // Bar border
        this.ctx.strokeStyle = baseColor;
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(barX, barY, barWidth, barHeight);
        
        // Scan status text
        const statusText = scanProgress >= 100 ? 'SCAN COMPLETE ✓' : `SCANNING... ${scanProgress}%`;
        this.ctx.fillStyle = scanProgress >= 100 ? '#00ff88' : '#00ffff';
        this.ctx.font = '8px Share Tech Mono';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(statusText, panelX + panelWidth / 2, panelY + 76);
        this.ctx.textAlign = 'left';
        
        // Animated scan line on the bar
        if (scanProgress < 100) {
            const scanLineX = barX + ((time * 50) % barWidth);
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(scanLineX, barY);
            this.ctx.lineTo(scanLineX, barY + barHeight);
            this.ctx.stroke();
        }
        
        // Glitch effect if simulated
        if (obj3D.isSimulated && Math.random() > 0.95) {
            this.ctx.fillStyle = 'rgba(255, 0, 85, 0.3)';
            this.ctx.fillRect(panelX + Math.random() * panelWidth * 0.8, 
                             panelY + Math.random() * panelHeight, 
                             Math.random() * 30 + 10, 2);
        }
    }
    
    // Render 3D scan overlays for all detected 3D objects
    render3DScanOverlays(objects3D, video) {
        if (!objects3D || objects3D.length === 0) return;
        
        objects3D.forEach(obj3D => {
            this.draw3DScanPanel(obj3D, video);
        });
    }
    
    // Generate fictional technical data based on object class
    generateTechnicalData(objClass, bbox) {
        const className = objClass.toLowerCase();
        const [x, y, width, height] = bbox;
        
        // Use object properties to generate deterministic "random" data
        const hash = (className.charCodeAt(0) || 0) + (className.charCodeAt(1) || 0) * 2 + Math.floor(width * height / 1000);
        
        // Material database
        const materials = {
            'cell phone': ['Gorilla Glass 7', 'Aluminum 7075', 'Carbon Composite', 'Titanium Alloy'],
            'laptop': ['Magnesium Alloy', 'Carbon Fiber', 'Aluminum 6061', 'Polymer Matrix'],
            'mouse': ['ABS Plastic', 'Polycarbonate', 'Soft-Touch Rubber', 'Recycled PETG'],
            'keyboard': ['PBT Keycaps', 'Aluminum Plate', 'ABS Frame', 'Steel Backplate'],
            'remote': ['ABS Plastic', 'Soft-Touch Coating', 'IR Transmitter', 'Recycled Polymer'],
            'bottle': ['PET Polymer', 'Glass Composite', 'Aluminum Can', 'BPA-Free Plastic'],
            'cup': ['Ceramic Glaze', 'Borosilicate Glass', 'Stainless Steel', 'Melamine Resin'],
            'book': ['Recycled Paper', 'Acid-Free Stock', 'Vegan Leather', 'Cloth Binding'],
            'backpack': ['Ballistic Nylon', 'Cordura 1000D', 'Ripstop Fabric', 'UHMWPE Fiber'],
            'handbag': ['Full-Grain Leather', 'Vegan Leather', 'Canvas Twill', 'Nylon 420D'],
            'shoe': ['EVA Foam Midsole', 'Carbon Plate', 'Flyknit Mesh', 'Rubber Outsole'],
            'person': ['Organic Tissue', 'Carbon-Based', 'Unknown Composition', 'Biological'],
            'default': ['Unknown Alloy', 'Composite Material', 'Synthetic Polymer', 'Mixed Materials']
        };
        
        // Origins database
        const origins = {
            'cell phone': ['Shenzhen, CN', 'Seoul, KR', 'Cupertino, US', 'Tokyo, JP'],
            'laptop': ['Taipei, TW', 'Shanghai, CN', 'San Jose, US', 'Unknown'],
            'person': ['CLASSIFIED', 'REDACTED', 'UNKNOWN', 'N/A'],
            'default': ['Unknown', 'CLASSIFIED', 'Multiple Origins', 'Unverified']
        };
        
        // Status options
        const statuses = ['NOMINAL', 'ACTIVE', 'STANDBY', 'UNKNOWN', 'SCANNING...', 'ANALYZED'];
        
        // Get material
        const materialList = materials[className] || materials['default'];
        const material = materialList[hash % materialList.length];
        
        // Get origin
        const originList = origins[className] || origins['default'];
        const origin = originList[hash % originList.length];
        
        // Generate serial number
        const serial = `${className.substring(0, 2).toUpperCase()}${hash.toString(16).toUpperCase().padStart(4, '0')}-${Math.floor(width).toString(16).toUpperCase()}`;
        
        // Status
        const status = statuses[(hash + Math.floor(performance.now() / 2000)) % statuses.length];
        
        // Distance estimation
        const distance = Math.max(10, Math.round(8000 / Math.sqrt(width * height)));
        
        return { material, origin, serial, status, distance };
    }

    drawTargetingSystem(rect, color, threatLevel) {
        if (threatLevel !== 'HIGH') return;

        const { x: targetX, y: targetY, w, h } = rect;
        const centerX = targetX + w/2;
        const centerY = targetY + h/2;

        // Crosshair for high threat objects
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 1;

        // Horizontal line
        this.ctx.beginPath();
        this.ctx.moveTo(centerX - 15, centerY);
        this.ctx.lineTo(centerX + 15, centerY);
        this.ctx.stroke();

        // Vertical line
        this.ctx.beginPath();
        this.ctx.moveTo(centerX, centerY - 15);
        this.ctx.lineTo(centerX, centerY + 15);
        this.ctx.stroke();

        // Corner brackets
        const bracketSize = 8;
        this.ctx.strokeRect(x - bracketSize, y - bracketSize, bracketSize, bracketSize);
        this.ctx.strokeRect(x + w, y - bracketSize, bracketSize, bracketSize);
        this.ctx.strokeRect(x - bracketSize, y + h, bracketSize, bracketSize);
        this.ctx.strokeRect(x + w, y + h, bracketSize, bracketSize);
    }

    drawCornerMarkers(rect, color) {
        const { x: cornerX, y: cornerY, w, h } = rect;
        const markerSize = 12;
        const innerMarkerSize = 6;
        const time = performance.now() * 0.001;
        const pulse = Math.sin(time * 5) * 0.3 + 0.7;

        // Outer brackets with glow
        this.ctx.shadowColor = color;
        this.ctx.shadowBlur = 8;
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 2;

        // Top-left corner (L-shape)
        this.ctx.beginPath();
        this.ctx.moveTo(cornerX, cornerY + markerSize);
        this.ctx.lineTo(cornerX, cornerY);
        this.ctx.lineTo(cornerX + markerSize, cornerY);
        this.ctx.stroke();

        // Top-right corner
        this.ctx.beginPath();
        this.ctx.moveTo(cornerX + w - markerSize, cornerY);
        this.ctx.lineTo(cornerX + w, cornerY);
        this.ctx.lineTo(cornerX + w, cornerY + markerSize);
        this.ctx.stroke();

        // Bottom-left corner
        this.ctx.beginPath();
        this.ctx.moveTo(cornerX, cornerY + h - markerSize);
        this.ctx.lineTo(cornerX, cornerY + h);
        this.ctx.lineTo(cornerX + markerSize, cornerY + h);
        this.ctx.stroke();

        // Bottom-right corner
        this.ctx.beginPath();
        this.ctx.moveTo(cornerX + w - markerSize, cornerY + h);
        this.ctx.lineTo(cornerX + w, cornerY + h);
        this.ctx.lineTo(cornerX + w, cornerY + h - markerSize);
        this.ctx.stroke();
        
        this.ctx.shadowBlur = 0;
        
        // Animated corner dots (targeting indicators)
        this.ctx.fillStyle = this.adjustColorAlpha(color, pulse);
        const dotSize = 3;
        
        // Pulsing dots at corners
        this.ctx.beginPath();
        this.ctx.arc(cornerX, cornerY, dotSize, 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.beginPath();
        this.ctx.arc(cornerX + w, cornerY, dotSize, 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.beginPath();
        this.ctx.arc(cornerX, cornerY + h, dotSize, 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.beginPath();
        this.ctx.arc(cornerX + w, cornerY + h, dotSize, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Center crosshair
        const centerX = cornerX + w / 2;
        const centerY = cornerY + h / 2;
        const crossSize = Math.min(15, w / 6, h / 6);
        
        this.ctx.strokeStyle = this.adjustColorAlpha(color, 0.6);
        this.ctx.lineWidth = 1;
        
        // Horizontal line with gap
        this.ctx.beginPath();
        this.ctx.moveTo(centerX - crossSize, centerY);
        this.ctx.lineTo(centerX - 3, centerY);
        this.ctx.moveTo(centerX + 3, centerY);
        this.ctx.lineTo(centerX + crossSize, centerY);
        this.ctx.stroke();
        
        // Vertical line with gap
        this.ctx.beginPath();
        this.ctx.moveTo(centerX, centerY - crossSize);
        this.ctx.lineTo(centerX, centerY - 3);
        this.ctx.moveTo(centerX, centerY + 3);
        this.ctx.lineTo(centerX, centerY + crossSize);
        this.ctx.stroke();
        
        // Rotating targeting ring
        const ringRadius = Math.min(20, w / 4, h / 4);
        this.ctx.strokeStyle = this.adjustColorAlpha(color, 0.3);
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, ringRadius, time * 2, time * 2 + Math.PI * 1.5);
        this.ctx.stroke();
    }

    drawIntelHUD(objects) {
        const objectCount = objects.length;
        const time = performance.now() * 0.001;
        const pulse = Math.sin(time * 3) * 0.2 + 0.8;
        
        // === TOP-LEFT: SYSTEM STATUS PANEL ===
        const panelX = 15;
        const panelY = 30;
        const panelWidth = 200;
        const panelHeight = 130;
        
        // Panel background
        this.ctx.fillStyle = 'rgba(0, 10, 15, 0.85)';
        this.ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
        
        // Panel border with glow
        this.ctx.shadowColor = '#00FFFF';
        this.ctx.shadowBlur = 10;
        this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);
        this.ctx.shadowBlur = 0;
        
        // Header
        this.ctx.fillStyle = '#00FFFF';
        this.ctx.font = 'bold 11px Share Tech Mono';
        this.ctx.textAlign = 'left';
        this.ctx.fillText('◆ INTEL RECONNAISSANCE', panelX + 10, panelY + 15);
        
        // Divider
        this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
        this.ctx.beginPath();
        this.ctx.moveTo(panelX + 5, panelY + 22);
        this.ctx.lineTo(panelX + panelWidth - 5, panelY + 22);
        this.ctx.stroke();
        
        // System status
        this.ctx.font = '10px Share Tech Mono';
        this.ctx.fillStyle = '#00FF00';
        this.ctx.fillText(`STATUS: ACTIVE`, panelX + 10, panelY + 38);
        
        this.ctx.fillStyle = '#AAAAAA';
        this.ctx.fillText(`ENGINE: 3D TACTICAL BOXES`, panelX + 10, panelY + 52);
        
        // 3D detection info with anchor status
        const hasAnchored = this.activeIntel3DBoxes ? 
            Array.from(this.activeIntel3DBoxes.values()).some(b => b.userData.nearHand) : false;
        
        if (hasAnchored) {
            this.ctx.fillStyle = '#00FF88';
            this.ctx.fillText(`⚓ HAND ANCHOR: ACTIVE`, panelX + 10, panelY + 66);
        } else {
            this.ctx.fillStyle = '#00FFFF';
            this.ctx.fillText(`3D BOXES: TRACKING`, panelX + 10, panelY + 66);
        }
        
        // Scanning animation
        const scanText = ['SCANNING', 'SCANNING.', 'SCANNING..', 'SCANNING...'][Math.floor(time * 2) % 4];
        this.ctx.fillStyle = `rgba(0, 255, 255, ${pulse})`;
        this.ctx.fillText(scanText, panelX + 10, panelY + 80);
        
        // Object count with visual
        this.ctx.fillStyle = '#FFFFFF';
        this.ctx.font = 'bold 18px Share Tech Mono';
        this.ctx.fillText(`${objectCount}`, panelX + 10, panelY + 105);
        this.ctx.font = '10px Share Tech Mono';
        this.ctx.fillStyle = '#AAAAAA';
        this.ctx.fillText(`OBJECTS DETECTED`, panelX + 35, panelY + 105);
        
        // Mini progress bar (scanning progress)
        const barWidth = panelWidth - 20;
        const scanProgress = ((time * 50) % 100) / 100;
        this.ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
        this.ctx.fillRect(panelX + 10, panelY + 115, barWidth, 4);
        this.ctx.fillStyle = '#00FFFF';
        this.ctx.fillRect(panelX + 10, panelY + 115, barWidth * scanProgress, 4);
        
        // === THREAT SUMMARY (Top-right corner) ===
        const threatPanelX = this.canvas.width - 160;
        const threatPanelY = 30;
        const threatPanelWidth = 145;
        const threatPanelHeight = 80;

        // Threat level summary
        const highThreat = objects.filter(obj => this.getObjectThreatLevel(obj.class) === 'HIGH').length;
        const mediumThreat = objects.filter(obj => this.getObjectThreatLevel(obj.class) === 'MEDIUM').length;
        const lowThreat = objects.filter(obj => this.getObjectThreatLevel(obj.class) === 'LOW').length;
        
        // Panel background
        this.ctx.fillStyle = 'rgba(0, 10, 15, 0.85)';
        this.ctx.fillRect(threatPanelX, threatPanelY, threatPanelWidth, threatPanelHeight);
        
        // Border color based on threat level
        const borderColor = highThreat > 0 ? '#FF0055' : mediumThreat > 0 ? '#FFFF00' : '#00FF00';
        this.ctx.shadowColor = borderColor;
        this.ctx.shadowBlur = highThreat > 0 ? 15 : 5;
        this.ctx.strokeStyle = borderColor;
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(threatPanelX, threatPanelY, threatPanelWidth, threatPanelHeight);
        this.ctx.shadowBlur = 0;
        
        // Header
        this.ctx.fillStyle = borderColor;
        this.ctx.font = 'bold 10px Share Tech Mono';
        this.ctx.textAlign = 'left';
        this.ctx.fillText('◆ THREAT ANALYSIS', threatPanelX + 8, threatPanelY + 14);
        
        // Threat counts
        this.ctx.font = '10px Share Tech Mono';
        
        this.ctx.fillStyle = '#FF0055';
        this.ctx.fillText(`● HIGH:   ${highThreat}`, threatPanelX + 10, threatPanelY + 35);
        this.ctx.fillStyle = '#FFFF00';
        this.ctx.fillText(`● MEDIUM: ${mediumThreat}`, threatPanelX + 10, threatPanelY + 50);
        this.ctx.fillStyle = '#00FF00';
        this.ctx.fillText(`● LOW:    ${lowThreat}`, threatPanelX + 10, threatPanelY + 65);
        
        // === BOTTOM: SCANNING INFO BAR ===
        const bottomBarY = this.canvas.height - 35;
        const bottomBarHeight = 25;
        
        // Background
        this.ctx.fillStyle = 'rgba(0, 10, 15, 0.7)';
        this.ctx.fillRect(0, bottomBarY, this.canvas.width, bottomBarHeight);
        
        // Top border
        this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.moveTo(0, bottomBarY);
        this.ctx.lineTo(this.canvas.width, bottomBarY);
        this.ctx.stroke();
        
        // Scanning categories
        this.ctx.fillStyle = '#00FFFF';
        this.ctx.font = '10px Share Tech Mono';
        this.ctx.textAlign = 'center';
        
        const categories = ['OBJECTS', 'DEVICES', 'CLOTHING', 'FURNITURE', 'VEHICLES'];
        const catWidth = this.canvas.width / categories.length;
        
        categories.forEach((cat, i) => {
            const catX = catWidth * i + catWidth / 2;
            const isActive = Math.floor(time * 2) % categories.length === i;
            
            if (isActive) {
                this.ctx.fillStyle = `rgba(0, 255, 255, ${pulse})`;
                this.ctx.font = 'bold 10px Share Tech Mono';
            } else {
                this.ctx.fillStyle = 'rgba(0, 255, 255, 0.4)';
                this.ctx.font = '10px Share Tech Mono';
            }
            
            this.ctx.fillText(cat, catX, bottomBarY + 16);
        });
        
        // Reset text align
        this.ctx.textAlign = 'left';
    }

    drawIntelCrosshair(handLandmarks) {
        if (!handLandmarks || !handLandmarks[8]) return; // Index finger tip

        // Get index finger position
        const indexTip = this.transformLandmark(handLandmarks[8]);
        const centerX = indexTip.x;
        const centerY = indexTip.y;

        // Draw tactical crosshair
        this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
        this.ctx.lineWidth = 1;

        // Main cross
        this.ctx.beginPath();
        this.ctx.moveTo(centerX - 20, centerY);
        this.ctx.lineTo(centerX + 20, centerY);
        this.ctx.moveTo(centerX, centerY - 20);
        this.ctx.lineTo(centerX, centerY + 20);
        this.ctx.stroke();

        // Corner ticks
        const tickSize = 5;
        this.ctx.beginPath();
        this.ctx.moveTo(centerX - 15, centerY - 15);
        this.ctx.lineTo(centerX - 15 + tickSize, centerY - 15);
        this.ctx.moveTo(centerX + 15 - tickSize, centerY - 15);
        this.ctx.lineTo(centerX + 15, centerY - 15);
        this.ctx.moveTo(centerX - 15, centerY + 15 - tickSize);
        this.ctx.lineTo(centerX - 15, centerY + 15);
        this.ctx.moveTo(centerX + 15, centerY + 15 - tickSize);
        this.ctx.lineTo(centerX + 15, centerY + 15);
        this.ctx.stroke();

        // Center dot with glow
        this.ctx.fillStyle = '#00FFFF';
        this.ctx.shadowColor = '#00FFFF';
        this.ctx.shadowBlur = 6;
        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
    }

    renderCube(hands) {
        this.cubeGroup.visible = true;
        
        // Hide sandtable when cube is active
        if (this.sandtableGroup) {
            this.sandtableGroup.visible = false;
        }
        
        // Default slow rotation (only when not interacting)
        let isInteracting = false;
        
        // Check if we have both hands for pinch gesture
        if(hands && hands.landmarks && hands.landmarks.length >= 2 &&
            hands.landmarks[0] && hands.landmarks[0][8] &&
            hands.landmarks[1] && hands.landmarks[1][8]) {
            // Get index finger tips (landmark 8) from both hands
            const indexTip1 = hands.landmarks[0][8];
            const indexTip2 = hands.landmarks[1][8];

            // Transform to canvas coordinates
            const tip1Transformed = this.transformLandmark(indexTip1);
            const tip2Transformed = this.transformLandmark(indexTip2);
            
            // Calculate distance between index fingers (pinch distance)
            const pinchDistance = Math.hypot(
                tip2Transformed.x - tip1Transformed.x,
                tip2Transformed.y - tip1Transformed.y
            );
            
            // Calculate center point between both index fingers
            const centerX = (tip1Transformed.x + tip2Transformed.x) / 2;
            const centerY = (tip1Transformed.y + tip2Transformed.y) / 2;
            
            // Convert 2D screen coordinates to 3D world coordinates
            // Normalize to -1 to 1 range
            const normalizedX = (centerX / this.canvas.width) * 2 - 1;
            const normalizedY = -((centerY / this.canvas.height) * 2 - 1); // Invert Y
            
            // Map to 3D space (adjust range as needed)
            const worldX = normalizedX * 4; // Range: -4 to 4
            const worldY = normalizedY * 3; // Range: -3 to 3
            const worldZ = 0; // Keep on same plane
            
            // Update cube position (smooth interpolation for better feel)
            this.cubeBasePosition.x += (worldX - this.cubeBasePosition.x) * 0.1;
            this.cubeBasePosition.y += (worldY - this.cubeBasePosition.y) * 0.1;
            this.cubeBasePosition.z += (worldZ - this.cubeBasePosition.z) * 0.1;
            
            // Scale based on pinch distance
            // Base distance reference (adjust based on your screen size)
            const baseDistance = Math.min(this.canvas.width, this.canvas.height) * 0.2;
            
            if(this.lastPinchDistance === null) {
                this.lastPinchDistance = pinchDistance;
            }
            
            // Calculate scale factor based on current pinch distance relative to base
            // When fingers are closer together, scale down; when farther, scale up
            const scaleFactor = Math.max(0.3, Math.min(3.0, pinchDistance / baseDistance));
            
            // Smooth scaling interpolation
            this.cubeBaseScale += (scaleFactor - this.cubeBaseScale) * 0.2;
            
            // Update reference distance for smooth transitions
            this.lastPinchDistance = pinchDistance;
            isInteracting = true;
            
            // Apply position and scale
            this.cubeGroup.position.set(
                this.cubeBasePosition.x,
                this.cubeBasePosition.y,
                this.cubeBasePosition.z
            );
            this.cubeGroup.scale.set(
                this.cubeBaseScale,
                this.cubeBaseScale,
                this.cubeBaseScale
            );
            
            // Optional: Add rotation based on hand orientation
            // Use middle finger knuckle from first hand for rotation
            const middleKnuckle = hands.landmarks[0][9];
            if (middleKnuckle) {
                this.cubeGroup.rotation.x = middleKnuckle.y * Math.PI * 2;
                this.cubeGroup.rotation.y = (1 - middleKnuckle.x) * Math.PI * 2;
            }
            
        } else if(hands && hands.landmarks && hands.landmarks.length === 1 &&
                   hands.landmarks[0] && hands.landmarks[0][0] && hands.landmarks[0][9]) {
            // Single hand: use palm center (landmark 0) to drag from center
            const palmCenter = hands.landmarks[0][0]; // Wrist/base of palm
            const transformed = this.transformLandmark(palmCenter);
            
            // Convert to 3D coordinates
            const normalizedX = (transformed.x / this.canvas.width) * 2 - 1;
            const normalizedY = -((transformed.y / this.canvas.height) * 2 - 1);
            
            const worldX = normalizedX * 4;
            const worldY = normalizedY * 3;
            
            // Smooth position update (more responsive for dragging)
            this.cubeBasePosition.x += (worldX - this.cubeBasePosition.x) * 0.2;
            this.cubeBasePosition.y += (worldY - this.cubeBasePosition.y) * 0.2;
            
            this.cubeGroup.position.set(
                this.cubeBasePosition.x,
                this.cubeBasePosition.y,
                this.cubeBasePosition.z
            );
            
            // Use middle finger knuckle for rotation
            const middleKnuckle = hands.landmarks[0][9];
            if (middleKnuckle) {
                this.cubeGroup.rotation.x = middleKnuckle.y * Math.PI * 2;
                this.cubeGroup.rotation.y = (1 - middleKnuckle.x) * Math.PI * 2;
            }
            
            isInteracting = true;
        } else {
            // No hands detected: reset pinch distance reference
            this.lastPinchDistance = null;
        }
        
        // Default rotation when not interacting
        if(!isInteracting) {
            this.cubeGroup.rotation.x += 0.005;
            this.cubeGroup.rotation.y += 0.008;
        }
        
        // Animate lights orbiting around cube for dynamic reflections
        const time = Date.now() * 0.001;
        this.lights[0].position.x = Math.sin(time) * 6;
        this.lights[0].position.z = Math.cos(time) * 6;
        this.lights[1].position.x = Math.sin(time * 0.7 + 2) * 5;
        this.lights[1].position.y = Math.cos(time * 0.7) * 5;
        this.lights[2].position.z = Math.sin(time * 0.5 + 4) * 6;
        
        // Pulse edge glow
        const pulse = Math.sin(time * 3) * 0.3 + 0.7;
        this.cubeEdges.material.opacity = pulse;
        
        // Animar partículas de energía dentro del cubo
        if (this.cubeEnergyParticles && this.cubeEnergyParticles.length > 0) {
            const cubeSize = 0.9; // Límite dentro del cubo (el cubo es 2x2x2, así que -0.9 a 0.9)
            
            this.cubeEnergyParticles.forEach((particle, index) => {
                const velocity = this.cubeParticleVelocities[index];
                const userData = particle.userData;
                
                // Mover partícula según su velocidad
                particle.position.x += velocity.x;
                particle.position.y += velocity.y;
                particle.position.z += velocity.z;
                
                // Rebote en los límites del cubo (con un poco de amortiguación)
                if (Math.abs(particle.position.x) > cubeSize) {
                    velocity.x *= -0.8; // Rebote con pérdida de energía
                    particle.position.x = Math.sign(particle.position.x) * cubeSize;
                }
                if (Math.abs(particle.position.y) > cubeSize) {
                    velocity.y *= -0.8;
                    particle.position.y = Math.sign(particle.position.y) * cubeSize;
                }
                if (Math.abs(particle.position.z) > cubeSize) {
                    velocity.z *= -0.8;
                    particle.position.z = Math.sign(particle.position.z) * cubeSize;
                }
                
                // Efecto de movimiento orbital adicional basado en la rotación del cubo
                const orbitRadius = 0.3;
                const orbitSpeed = userData.speed * 0.01;
                const orbitX = Math.cos(time * orbitSpeed + userData.phase) * orbitRadius;
                const orbitY = Math.sin(time * orbitSpeed + userData.phase) * orbitRadius;
                const orbitZ = Math.sin(time * orbitSpeed * 0.7 + userData.phase) * orbitRadius;
                
                // Aplicar movimiento orbital relativo a la posición base
                particle.position.x = userData.basePosition.x + orbitX;
                particle.position.y = userData.basePosition.y + orbitY;
                particle.position.z = userData.basePosition.z + orbitZ;
                
                // Mantener dentro de los límites
                particle.position.x = Math.max(-cubeSize, Math.min(cubeSize, particle.position.x));
                particle.position.y = Math.max(-cubeSize, Math.min(cubeSize, particle.position.y));
                particle.position.z = Math.max(-cubeSize, Math.min(cubeSize, particle.position.z));
                
                // Pulso de opacidad y brillo
                const particlePulse = Math.sin(time * 4 + userData.phase) * 0.3 + 0.7;
                particle.material.opacity = particlePulse * 0.8;
                particle.material.emissiveIntensity = particlePulse * 1.5;
                
                // Escala pulsante
                const scale = 0.8 + particlePulse * 0.4;
                particle.scale.set(scale, scale, scale);
                
                // Las partículas se mueven con el cubo automáticamente porque están en cubeGroup
            });
        }

        this.renderer3D.render(this.scene, this.camera3D);
    }

    // === MINI-CANVAS RENDERING FUNCTIONS ===

    // Helper: Draw video to canvas preserving aspect ratio (cover mode, no stretch)
    drawVideoCoverToCanvas(ctx, video, canvas, mirror = true) {
        if (!video || !video.videoWidth || !video.videoHeight) return;
        
        const videoAspect = video.videoWidth / video.videoHeight;
        const canvasAspect = canvas.width / canvas.height;
        
        let sx, sy, sw, sh;
        
        if (videoAspect > canvasAspect) {
            // Video is wider - crop sides
            sh = video.videoHeight;
            sw = video.videoHeight * canvasAspect;
            sx = (video.videoWidth - sw) / 2;
            sy = 0;
        } else {
            // Video is taller - crop top/bottom
            sw = video.videoWidth;
            sh = video.videoWidth / canvasAspect;
            sx = 0;
            sy = (video.videoHeight - sh) / 2;
        }
        
        ctx.save();
        if (mirror) {
            ctx.scale(-1, 1);
            ctx.drawImage(video, sx, sy, sw, sh, -canvas.width, 0, canvas.width, canvas.height);
        } else {
            ctx.drawImage(video, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);
        }
        ctx.restore();
    }
    
    renderThermal(video) {
        if (!this.thermalCtx || !video) return;

        // Clear canvas first
        this.thermalCtx.clearRect(0, 0, this.thermalCanvas.width, this.thermalCanvas.height);

        // Draw video to thermal canvas with aspect ratio preservation on mobile
        const isMobile = window.innerWidth <= 768;
        
        if (isMobile) {
            // Mobile: use cover mode to prevent stretching
            this.drawVideoCoverToCanvas(this.thermalCtx, video, this.thermalCanvas, true);
        } else {
            // Desktop: keep original behavior
            this.thermalCtx.save();
            this.thermalCtx.scale(-1, 1);
            this.thermalCtx.drawImage(video, -this.thermalCanvas.width, 0, this.thermalCanvas.width, this.thermalCanvas.height);
            this.thermalCtx.restore();
        }

        // Apply thermal vision effect
        const imageData = this.thermalCtx.getImageData(0, 0, this.thermalCanvas.width, this.thermalCanvas.height);
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];

            // Convert to grayscale intensity
            const intensity = (r + g + b) / 3;

            // Apply thermal color mapping (blue -> red)
            if (intensity < 85) {
                // Cool (blue)
                data[i] = 0;
                data[i + 1] = Math.min(255, intensity * 3);
                data[i + 2] = Math.min(255, intensity * 4);
            } else if (intensity < 170) {
                // Warm (yellow-green)
                data[i] = Math.min(255, (intensity - 85) * 3);
                data[i + 1] = Math.min(255, 128 + (intensity - 85) * 2);
                data[i + 2] = 0;
            } else {
                // Hot (red)
                data[i] = Math.min(255, 128 + (intensity - 170) * 2);
                data[i + 1] = 0;
                data[i + 2] = 0;
            }
        }

        this.thermalCtx.putImageData(imageData, 0, 0);
    }

    renderMoCap(hands, face) {
        if (!this.mocapCtx) return;

        // Clear to pure black background
        this.mocapCtx.clearRect(0, 0, this.mocapCanvas.width, this.mocapCanvas.height);

        // Add glow border if cube is active
        if (window.app && window.app.cubeActive) {
            this.mocapCtx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
            this.mocapCtx.lineWidth = 2;
            this.mocapCtx.strokeRect(1, 1, this.mocapCanvas.width - 2, this.mocapCanvas.height - 2);
        }

        // Calculate viewport for aspect-ratio preservation (mobile-only)
        const isMobile = window.innerWidth <= 768;
        let viewportX = 0, viewportY = 0, viewportW = this.mocapCanvas.width, viewportH = this.mocapCanvas.height;
        
        if (isMobile && this.mainCanvasAspect) {
            const canvasAspect = this.mocapCanvas.width / this.mocapCanvas.height;
            
            if (this.mainCanvasAspect > canvasAspect) {
                // Main is wider - letterbox top/bottom
                viewportW = this.mocapCanvas.width;
                viewportH = this.mocapCanvas.width / this.mainCanvasAspect;
                viewportX = 0;
                viewportY = (this.mocapCanvas.height - viewportH) / 2;
            } else {
                // Main is taller - pillarbox left/right
                viewportH = this.mocapCanvas.height;
                viewportW = this.mocapCanvas.height * this.mainCanvasAspect;
                viewportY = 0;
                viewportX = (this.mocapCanvas.width - viewportW) / 2;
            }
        }

        // Draw hands
        if (hands && hands.landmarks) {
            for (const landmarks of hands.landmarks) {
                if (!landmarks) continue;

                // Draw connections
                this.mocapCtx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
                this.mocapCtx.lineWidth = 1.5;

                for (const connection of HAND_CONNECTIONS) {
                    const p1 = landmarks[connection[0]];
                    const p2 = landmarks[connection[1]];

                    if (p1 && p2) {
                        // Mirror correction + viewport mapping
                        const x1 = viewportX + (1 - p1.x) * viewportW;
                        const y1 = viewportY + p1.y * viewportH;
                        const x2 = viewportX + (1 - p2.x) * viewportW;
                        const y2 = viewportY + p2.y * viewportH;

                        this.mocapCtx.beginPath();
                        this.mocapCtx.moveTo(x1, y1);
                        this.mocapCtx.lineTo(x2, y2);
                        this.mocapCtx.stroke();
                    }
                }

                // Draw landmarks as dots
                this.mocapCtx.fillStyle = 'rgba(0, 255, 255, 0.9)';
                for (const landmark of landmarks) {
                    if (landmark) {
                        // Mirror correction + viewport mapping
                        const x = viewportX + (1 - landmark.x) * viewportW;
                        const y = viewportY + landmark.y * viewportH;

                        this.mocapCtx.beginPath();
                        this.mocapCtx.arc(x, y, 2, 0, 2 * Math.PI);
                        this.mocapCtx.fill();
                    }
                }
            }
        }

        // Draw face as dots (same as main render)
        if (face && face.faceLandmarks && face.faceLandmarks.length > 0) {
            const landmarks = face.faceLandmarks[0];

            // Same face contours as main render
            const FACE_OVAL = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109, 10];
            const LEFT_EYE = [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398, 362];
            const RIGHT_EYE = [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246, 33];
            const LIPS_OUTER = [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291, 409, 270, 269, 267, 0, 37, 39, 40, 185, 61];
            const LIPS_INNER = [78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308, 415, 310, 311, 312, 13, 82, 81, 80, 191, 78];
            const LEFT_EYEBROW = [276, 283, 282, 295, 285, 300, 293, 334, 296, 336];
            const RIGHT_EYEBROW = [46, 53, 52, 65, 55, 70, 63, 105, 66, 107];
            const NOSE_BRIDGE = [168, 6, 197, 195, 5, 4, 1, 19, 94, 2];

            // Same colors as main render
            const colors = {
                oval: '#00FFFF',
                eyes: '#00FF00',
                lips: '#888888',
                eyebrows: '#00FFFF',
                nose: '#00FFFF',
                points: '#FFFFFF'
            };

            // Function to draw dots for contour points (same as main)
            const drawContourDots = (indices, color, dotSize = 1.5) => {
                this.mocapCtx.fillStyle = color;
                for (const idx of indices) {
                    const landmark = landmarks[idx];
                    if (landmark) {
                        // Mirror correction + viewport mapping
                        const x = viewportX + (1 - landmark.x) * viewportW;
                        const y = viewportY + landmark.y * viewportH;

                        // Add subtle glow effect
                        this.mocapCtx.shadowColor = color;
                        this.mocapCtx.shadowBlur = 2;
                        this.mocapCtx.beginPath();
                        this.mocapCtx.arc(x, y, dotSize, 0, 2 * Math.PI);
                        this.mocapCtx.fill();
                        this.mocapCtx.shadowBlur = 0; // Reset shadow
                    }
                }
            };

            // Draw all face contours as dots (same as main render)
            drawContourDots(FACE_OVAL, colors.oval, 1.5);
            drawContourDots(LEFT_EYE, colors.eyes, 1.5);
            drawContourDots(RIGHT_EYE, colors.eyes, 1.5);
            drawContourDots(LIPS_OUTER, colors.lips, 1.5);
            drawContourDots(LIPS_INNER, colors.lips, 1.5);
            drawContourDots(LEFT_EYEBROW, colors.eyebrows, 1.5);
            drawContourDots(RIGHT_EYEBROW, colors.eyebrows, 1.5);
            drawContourDots(NOSE_BRIDGE, colors.nose, 1.5);

            // Draw key landmark points (same as main)
            this.mocapCtx.fillStyle = colors.points;
            const keyPoints = [1, 4, 5, 6, 168, 197, 195, 5, 4, 1, 2, 98, 327, 33, 133, 362, 263, 61, 291, 199];

            for (const idx of keyPoints) {
                const landmark = landmarks[idx];
                if (landmark) {
                    const x = (1 - landmark.x) * this.mocapCanvas.width;
                    const y = landmark.y * this.mocapCanvas.height;

                    // Add glow effect for key points
                    this.mocapCtx.shadowColor = colors.points;
                    this.mocapCtx.shadowBlur = 3;
                    this.mocapCtx.beginPath();
                    this.mocapCtx.arc(x, y, 1.5, 0, 2 * Math.PI);
                    this.mocapCtx.fill();
                    this.mocapCtx.shadowBlur = 0; // Reset shadow
                }
            }
        }

        // Draw carousel points if CAROUSEL mode is active
        if (window.app && window.app.mode === 'CAROUSEL' && window.app.carouselSystem && window.app.carouselSystem.isInitialized) {
            this.renderCarouselInMoCap();
        }

        // Draw intel indicators if INTEL mode is active
        if (window.app && window.app.mode === 'INTEL' && hands && hands.landmarks) {
            this.renderIntelInMoCap(hands);
        }

        // Render 3D cube as 2D particles if active
        this.renderCubeParticles();
    }

    renderCarouselInMoCap() {
        if (!window.app || !window.app.carouselSystem || !window.app.carouselSystem.isInitialized) return;

        const carousel = window.app.carouselSystem;
        const centerX = this.mocapCanvas.width / 2;
        const centerY = this.mocapCanvas.height / 2;

        // Draw carousel border indicator
        const maxRadius = Math.min(this.mocapCanvas.width, this.mocapCanvas.height) * 0.35;
        this.mocapCtx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
        this.mocapCtx.lineWidth = 2;
        this.mocapCtx.beginPath();
        this.mocapCtx.arc(centerX, centerY, maxRadius, 0, Math.PI * 2);
        this.mocapCtx.stroke();

        // Get carousel rotation and current image
        const rotation = carousel.rotation;
        const currentIndex = carousel.currentIndex;
        const numImages = carousel.images.length;

        // Draw carousel points in a circle (inside the border)
        const radius = Math.min(this.mocapCanvas.width, this.mocapCanvas.height) * 0.25;

        // Draw all carousel points
        for (let i = 0; i < numImages; i++) {
            const angle = (i / numImages) * Math.PI * 2 - rotation;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;

            // Different color for current image
            const isCurrent = i === currentIndex;
            const color = isCurrent ? '#00FFFF' : '#FF00FF'; // Cyan for current, magenta for others
            const size = isCurrent ? 3 : 2;

            this.mocapCtx.fillStyle = color;
            this.mocapCtx.shadowColor = color;
            this.mocapCtx.shadowBlur = isCurrent ? 6 : 3;

            this.mocapCtx.beginPath();
            this.mocapCtx.arc(x, y, size, 0, Math.PI * 2);
            this.mocapCtx.fill();

            this.mocapCtx.shadowBlur = 0; // Reset shadow
        }

        // Draw center indicator
        this.mocapCtx.strokeStyle = '#00FF00';
        this.mocapCtx.lineWidth = 1;
        this.mocapCtx.beginPath();
        this.mocapCtx.arc(centerX, centerY, 8, 0, Math.PI * 2);
        this.mocapCtx.stroke();

        // Add rotation indicator line (shorter to stay within border)
        const indicatorAngle = -rotation;
        const indicatorLength = radius * 0.6;
        this.mocapCtx.strokeStyle = '#FFFF00';
        this.mocapCtx.lineWidth = 2;
        this.mocapCtx.beginPath();
        this.mocapCtx.moveTo(centerX, centerY);
        this.mocapCtx.lineTo(
            centerX + Math.cos(indicatorAngle) * indicatorLength,
            centerY + Math.sin(indicatorAngle) * indicatorLength
        );
        this.mocapCtx.stroke();

        // Add CAROUSEL label
        this.mocapCtx.fillStyle = '#00FFFF';
        this.mocapCtx.font = '8px Share Tech Mono';
        this.mocapCtx.textAlign = 'center';
        this.mocapCtx.fillText('CAROUSEL', centerX, centerY - radius - 15);

        // Add current image indicator
        const imageNames = ['ACORRALADO', 'CUERVO', 'DEMONIO', 'DIAMANTE', 'IMPERIO', 'NADIE', 'REY'];
        const currentName = imageNames[currentIndex] || `IMG${currentIndex + 1}`;
        this.mocapCtx.fillStyle = '#FFFF00';
        this.mocapCtx.font = '6px Share Tech Mono';
        this.mocapCtx.fillText(currentName, centerX, centerY + radius + 10);
    }

    renderIntelInMoCap(hands) {
        if (!window.app || !window.app.vision || !window.app.vision.results.objects) return;

        const objects = window.app.vision.results.objects;
        const centerX = this.mocapCanvas.width / 2;
        const centerY = this.mocapCanvas.height / 2;

        // Draw INTEL border indicator
        this.mocapCtx.strokeStyle = 'rgba(255, 0, 85, 0.5)';
        this.mocapCtx.lineWidth = 2;
        this.mocapCtx.strokeRect(5, 5, this.mocapCanvas.width - 10, this.mocapCanvas.height - 10);

        // Draw object detection indicators
        objects.slice(0, 8).forEach((obj, index) => { // Limit to 8 for clarity
            const threatLevel = window.app.engine.getObjectThreatLevel(obj.class);
            const color = window.app.engine.getObjectColor(obj.class, threatLevel);

            // Position indicators around the border
            const angle = (index / 8) * Math.PI * 2;
            const radius = Math.min(this.mocapCanvas.width, this.mocapCanvas.height) * 0.45;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;

            // Draw threat indicator
            this.mocapCtx.fillStyle = color;
            this.mocapCtx.shadowColor = color;
            this.mocapCtx.shadowBlur = 4;
            this.mocapCtx.beginPath();
            this.mocapCtx.arc(x, y, threatLevel === 'HIGH' ? 5 : 3, 0, Math.PI * 2);
            this.mocapCtx.fill();
            this.mocapCtx.shadowBlur = 0;
        });

        // Add INTEL status
        this.mocapCtx.fillStyle = '#FF0055';
        this.mocapCtx.font = '8px Share Tech Mono';
        this.mocapCtx.textAlign = 'center';
        this.mocapCtx.fillText('INTEL ACTIVE', centerX, 15);

        if (objects.length > 0) {
            this.mocapCtx.fillText(`${objects.length} OBJECTS`, centerX, this.mocapCanvas.height - 10);
        } else {
            this.mocapCtx.fillStyle = '#666666';
            this.mocapCtx.fillText('NO TARGETS', centerX, this.mocapCanvas.height - 10);
        }

        // Add threat level summary
        const highThreat = objects.filter(obj => window.app.engine.getObjectThreatLevel(obj.class) === 'HIGH').length;
        const mediumThreat = objects.filter(obj => window.app.engine.getObjectThreatLevel(obj.class) === 'MEDIUM').length;

        if (highThreat > 0) {
            this.mocapCtx.fillStyle = '#FF0055';
            this.mocapCtx.fillText(`${highThreat} HIGH`, centerX - 30, 30);
        }
        if (mediumThreat > 0) {
            this.mocapCtx.fillStyle = '#FFFF00';
            this.mocapCtx.fillText(`${mediumThreat} MEDIUM`, centerX + 30, 30);
        }
    }

    renderCubeParticles() {
        // Check if cube is active (from TacticalOS instance)
        if (!window.app || !window.app.engine || !window.app.cubeActive) return;

        const cubePos = window.app.engine.cubeBasePosition;
        const cubeScale = window.app.engine.cubeBaseScale || 1.0;

        if (!cubePos) return;

        // Map 3D cube position to 2D mini-canvas coordinates
        // Cube moves in range approximately: X: -4 to 4, Y: -3 to 3
        const canvasX = ((cubePos.x + 4) / 8) * this.mocapCanvas.width;  // Map -4..4 to 0..width
        // Invertir Y para que coincida con el movimiento (Y positivo en 3D = arriba, pero en canvas Y positivo = abajo)
        const canvasY = (1 - (cubePos.y + 3) / 6) * this.mocapCanvas.height; // Map -3..3 a height..0 (invertido)

        const time = Date.now() * 0.005;

        // Calculate particle size based on cube scale
        const baseSize = Math.max(1.5, Math.min(6, cubeScale * 3));
        const pulse = Math.sin(time * 2) * 0.3 + 0.7;

        // Draw cube as dynamic particle system
        this.mocapCtx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
        this.mocapCtx.lineWidth = 0.5;

        // Cube vertices in 3D space (simplified cube)
        const vertices = [
            [-0.5, -0.5, -0.5], [0.5, -0.5, -0.5], [0.5, 0.5, -0.5], [-0.5, 0.5, -0.5], // Front face
            [-0.5, -0.5, 0.5], [0.5, -0.5, 0.5], [0.5, 0.5, 0.5], [-0.5, 0.5, 0.5]    // Back face
        ];

        // Simple rotation animation
        const rotX = time * 0.5;
        const rotY = time * 0.3;
        const rotZ = time * 0.2;

        // Project 3D vertices to 2D and draw particles
        vertices.forEach((vertex, index) => {
            let [x, y, z] = vertex;

            // Apply rotation
            const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
            const cosY = Math.cos(rotY), sinY = Math.sin(rotY);
            const cosZ = Math.cos(rotZ), sinZ = Math.sin(rotZ);

            // Rotate around Y axis
            let tempX = x * cosY - z * sinY;
            let tempZ = x * sinY + z * cosY;
            x = tempX;
            z = tempZ;

            // Rotate around X axis
            let tempY = y * cosX - z * sinX;
            tempZ = y * sinX + z * cosX;
            y = tempY;
            z = tempZ;

            // Simple perspective projection
            const scale = 2 / (2 + z);
            const screenX = canvasX + x * scale * 20;
            const screenY = canvasY + y * scale * 20;

            // Keep within bounds
            const clampedX = Math.max(baseSize, Math.min(this.mocapCanvas.width - baseSize, screenX));
            const clampedY = Math.max(baseSize, Math.min(this.mocapCanvas.height - baseSize, screenY));

            // Particle color based on depth
            const alpha = Math.max(0.3, scale * 0.8);
            const size = baseSize * scale * pulse;

            this.mocapCtx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
            this.mocapCtx.beginPath();
            this.mocapCtx.arc(clampedX, clampedY, size, 0, 2 * Math.PI);
            this.mocapCtx.fill();

            // Add glow for front-facing particles
            if (z > -0.3) {
                this.mocapCtx.shadowColor = 'rgba(0, 255, 255, 0.6)';
                this.mocapCtx.shadowBlur = 3;
                this.mocapCtx.beginPath();
                this.mocapCtx.arc(clampedX, clampedY, size * 1.2, 0, 2 * Math.PI);
                this.mocapCtx.fill();
                this.mocapCtx.shadowBlur = 0;
            }
        });

        // Draw connecting lines between nearby particles
        this.mocapCtx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
        this.mocapCtx.lineWidth = 0.5;

        // Simple cube edges (connect vertices that should be connected)
        const edges = [
            [0, 1], [1, 2], [2, 3], [3, 0], // Front face
            [4, 5], [5, 6], [6, 7], [7, 4], // Back face
            [0, 4], [1, 5], [2, 6], [3, 7]  // Connecting edges
        ];

        // Apply same rotation and projection to edges
        edges.forEach(([i1, i2]) => {
            let [x1, y1, z1] = vertices[i1];
            let [x2, y2, z2] = vertices[i2];

            // Apply same rotations
            const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
            const cosY = Math.cos(rotY), sinY = Math.sin(rotY);

            // Rotate point 1
            let tempX1 = x1 * cosY - z1 * sinY;
            let tempZ1 = x1 * sinY + z1 * cosY;
            x1 = tempX1;
            z1 = tempZ1;
            let tempY1 = y1 * cosX - z1 * sinX;
            tempZ1 = y1 * sinX + z1 * cosX;
            y1 = tempY1;
            z1 = tempZ1;

            // Rotate point 2
            let tempX2 = x2 * cosY - z2 * sinY;
            let tempZ2 = x2 * sinY + z2 * cosY;
            x2 = tempX2;
            z2 = tempZ2;
            let tempY2 = y2 * cosX - z2 * sinX;
            tempZ2 = y2 * sinX + z2 * cosX;
            y2 = tempY2;
            z2 = tempZ2;

            // Perspective projection
            const scale1 = 2 / (2 + z1);
            const scale2 = 2 / (2 + z2);
            const screenX1 = canvasX + x1 * scale1 * 20;
            const screenY1 = canvasY + y1 * scale1 * 20;
            const screenX2 = canvasX + x2 * scale2 * 20;
            const screenY2 = canvasY + y2 * scale2 * 20;

            // Only draw edges that are somewhat visible
            if (z1 > -1 && z2 > -1) {
                this.mocapCtx.beginPath();
                this.mocapCtx.moveTo(screenX1, screenY1);
                this.mocapCtx.lineTo(screenX2, screenY2);
                this.mocapCtx.stroke();
            }
        });

        // Add central energy core
        this.mocapCtx.fillStyle = `rgba(255, 255, 255, ${0.6 + Math.sin(time * 3) * 0.4})`;
        this.mocapCtx.beginPath();
        this.mocapCtx.arc(canvasX, canvasY, baseSize * 0.8, 0, 2 * Math.PI);
        this.mocapCtx.fill();

        // Energy pulse effect
        if (Math.sin(time * 4) > 0.8) {
            this.mocapCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            this.mocapCtx.lineWidth = 2;
            this.mocapCtx.beginPath();
            this.mocapCtx.arc(canvasX, canvasY, baseSize * 2, 0, 2 * Math.PI);
            this.mocapCtx.stroke();
        }
    }

    drawCentralScanningPoints(centerX, centerY, time) {
        // Draw scanning points around center when no landmarks detected
        // Creates a "scanning" effect even without detected features

        const numPoints = 20;
        const scanRadius = Math.min(this.canvas.width, this.canvas.height) * 0.3;
        const pulse = Math.sin(time * 3) * 0.5 + 0.5;

        for (let i = 0; i < numPoints; i++) {
            const angle = (i / numPoints) * Math.PI * 2 + time * 0.5;
            const distance = scanRadius * (0.5 + pulse * 0.5);
            const x = centerX + Math.cos(angle) * distance;
            const y = centerY + Math.sin(angle) * distance;

            // Color based on angle and time
            const hue = (angle / (Math.PI * 2) * 360 + time * 50) % 360;
            const saturation = 80;
            const lightness = 50 + Math.sin(time * 4 + i) * 20;

            this.ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.7)`;
            this.ctx.shadowColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            this.ctx.shadowBlur = 5;

            const pointSize = 3 + Math.sin(time * 2 + i * 0.5) * 2;
            this.ctx.beginPath();
            this.ctx.arc(x, y, pointSize, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.shadowBlur = 0;
    }

    renderRadar() {
        if (!this.radarCtx) return;

        const centerX = this.radarCanvas.width / 2;
        const centerY = this.radarCanvas.height / 2;
        const radius = Math.max(20, Math.min(centerX, centerY) - 15); // Ensure minimum radius of 20

        // Clear canvas
        this.radarCtx.clearRect(0, 0, this.radarCanvas.width, this.radarCanvas.height);

        // Draw radar circles
        this.radarCtx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
        this.radarCtx.lineWidth = 1;
        for (let i = 1; i <= 3; i++) {
            this.radarCtx.beginPath();
            this.radarCtx.arc(centerX, centerY, (radius * i) / 3, 0, 2 * Math.PI);
            this.radarCtx.stroke();
        }

        // Draw radar grid lines
        this.radarCtx.beginPath();
        this.radarCtx.moveTo(centerX - radius, centerY);
        this.radarCtx.lineTo(centerX + radius, centerY);
        this.radarCtx.moveTo(centerX, centerY - radius);
        this.radarCtx.lineTo(centerX, centerY + radius);
        this.radarCtx.stroke();

        // Draw sweep line
        this.radarCtx.beginPath();
        this.radarCtx.moveTo(centerX, centerY);
        this.radarCtx.lineTo(
            centerX + Math.cos(this.radarAngle) * radius,
            centerY + Math.sin(this.radarAngle) * radius
        );
        this.radarCtx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
        this.radarCtx.lineWidth = 2;
        this.radarCtx.stroke();

        // Draw sweep arc
        this.radarCtx.beginPath();
        this.radarCtx.arc(centerX, centerY, radius, this.radarAngle - 0.2, this.radarAngle);
        this.radarCtx.strokeStyle = 'rgba(0, 255, 0, 0.4)';
        this.radarCtx.stroke();

        // Draw random targets
        for (let i = 0; i < 4; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * radius * 0.8;
            const x = centerX + Math.cos(angle) * distance;
            const y = centerY + Math.sin(angle) * distance;

            const isHostile = Math.random() > 0.7;
            this.radarCtx.fillStyle = isHostile ? 'rgba(255, 0, 85, 0.8)' : 'rgba(0, 255, 0, 0.8)';
            this.radarCtx.beginPath();
            this.radarCtx.arc(x, y, 3, 0, 2 * Math.PI);
            this.radarCtx.fill();
        }

        this.radarAngle += 0.015;
    }

    updateHexMatrix() {
        const now = Date.now();
        if (now - this.lastHexUpdate > 1500) { // Update every 1.5 seconds
            this.lastHexUpdate = now;

            const hexMatrix = document.getElementById('hex-matrix');
            if (hexMatrix) {
                const lines = hexMatrix.children;
                for (let line of lines) {
                    let hex = '';
                    for (let i = 0; i < 8; i++) {
                        hex += '0123456789ABCDEF'[Math.floor(Math.random() * 16)];
                    }
                    hex += ' ';
                    for (let i = 0; i < 8; i++) {
                        hex += '0123456789ABCDEF'[Math.floor(Math.random() * 16)];
                    }
                    line.textContent = hex;
                }
            }
        }
    }

    renderFaceMesh(face, style = 'TACTICAL') {
        if (!face || !face.faceLandmarks || face.faceLandmarks.length === 0) return;

        const landmarks = face.faceLandmarks[0];
        
        // Transform landmarks to canvas coordinates (includes mirroring)
        const transformedLandmarks = landmarks.map(p => this.transformLandmark(p));

        // Face mesh connections (simplified - key contours)
        const FACE_OVAL = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109, 10];
        const LEFT_EYE = [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398, 362];
        const RIGHT_EYE = [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246, 33];
        const LIPS_OUTER = [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291, 409, 270, 269, 267, 0, 37, 39, 40, 185, 61];
        const LIPS_INNER = [78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308, 415, 310, 311, 312, 13, 82, 81, 80, 191, 78];
        const LEFT_EYEBROW = [276, 283, 282, 295, 285, 300, 293, 334, 296, 336];
        const RIGHT_EYEBROW = [46, 53, 52, 65, 55, 70, 63, 105, 66, 107];
        const NOSE_BRIDGE = [168, 6, 197, 195, 5, 4, 1, 19, 94, 2];

        // Colors based on style - brighter for dots
        const colors = {
            oval: style === 'TACTICAL' ? '#00FFFF' : '#FF0055',
            eyes: style === 'TACTICAL' ? '#00FF00' : '#00FFFF',
            lips: '#888888', // Gris para labios
            eyebrows: style === 'TACTICAL' ? '#00FFFF' : '#00FF00',
            nose: style === 'TACTICAL' ? '#00FFFF' : '#00FFFF',
            points: style === 'TACTICAL' ? '#FFFFFF' : '#FFFFFF'
        };

        // Function to draw dots for contour points
        const drawContourDots = (indices, color, dotSize = 3) => {
            this.ctx.fillStyle = color;
            for (const idx of indices) {
                const p = transformedLandmarks[idx];
                if (p) {
                    // Add subtle glow effect
                    this.ctx.shadowColor = color;
                    this.ctx.shadowBlur = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, dotSize, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0; // Reset shadow
                }
            }
        };

        // Draw all face contours as dots instead of lines
        drawContourDots(FACE_OVAL, colors.oval, 1.5);
        drawContourDots(LEFT_EYE, colors.eyes, 1.5);
        drawContourDots(RIGHT_EYE, colors.eyes, 1.5);
        drawContourDots(LIPS_OUTER, colors.lips, 1.5);
        drawContourDots(LIPS_INNER, colors.lips, 1.5);
        drawContourDots(LEFT_EYEBROW, colors.eyebrows, 1.5);
        drawContourDots(RIGHT_EYEBROW, colors.eyebrows, 1.5);
        drawContourDots(NOSE_BRIDGE, colors.nose, 1.5);

        // Draw key landmark points
        this.ctx.fillStyle = colors.points;
        const keyPoints = [1, 4, 5, 6, 168, 197, 195, 5, 4, 1, 2, 98, 327, 33, 133, 362, 263, 61, 291, 199];

        for (const idx of keyPoints) {
            const p = transformedLandmarks[idx];
            if (p) {
                // Add glow effect for key points
                this.ctx.shadowColor = colors.points;
                this.ctx.shadowBlur = 3;
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, 1.5, 0, 2 * Math.PI);
                this.ctx.fill();
                this.ctx.shadowBlur = 0; // Reset shadow
            }
        }

        // Draw targeting reticle around face center
        if (style === 'TACTICAL') {
            const nose = transformedLandmarks[1]; // Nose tip
            if (nose) {
                const cx = nose.x;
                const cy = nose.y;
                const size = 60;

                this.ctx.strokeStyle = 'rgba(255, 0, 85, 0.5)';
                this.ctx.lineWidth = 1;

                // Corner brackets
                const corners = [
                    { x: cx - size, y: cy - size, dx: 20, dy: 0, dx2: 0, dy2: 20 },
                    { x: cx + size, y: cy - size, dx: -20, dy: 0, dx2: 0, dy2: 20 },
                    { x: cx - size, y: cy + size, dx: 20, dy: 0, dx2: 0, dy2: -20 },
                    { x: cx + size, y: cy + size, dx: -20, dy: 0, dx2: 0, dy2: -20 }
                ];

                corners.forEach(c => {
                    this.ctx.beginPath();
                    this.ctx.moveTo(c.x + c.dx, c.y);
                    this.ctx.lineTo(c.x, c.y);
                    this.ctx.lineTo(c.x, c.y + c.dy2);
                    this.ctx.stroke();
                });

                // Center crosshair
                this.ctx.beginPath();
                this.ctx.moveTo(cx - 10, cy);
                this.ctx.lineTo(cx + 10, cy);
                this.ctx.moveTo(cx, cy - 10);
                this.ctx.lineTo(cx, cy + 10);
                this.ctx.stroke();

                // ID Label
                this.ctx.fillStyle = 'rgba(255, 0, 85, 0.8)';
                this.ctx.font = '10px Share Tech Mono';
                this.ctx.fillText('BIOMETRIC ID: SCANNING...', cx - size, cy - size - 10);
            }
        }
    }

    // ========== CAROUSEL MODE HAND FX ==========
    // High-Tech Fine Line visual overlay for CAROUSEL mode
    drawCarouselHandFX(hands) {
        if (!hands || !hands.landmarks || hands.landmarks.length === 0) return;

        const time = performance.now() * 0.001; // Time in seconds for animations
        
        for (let handIdx = 0; handIdx < hands.landmarks.length; handIdx++) {
            const landmarks = hands.landmarks[handIdx];
            if (!landmarks || landmarks.length < 21) continue;

            // Transform all relevant landmarks to canvas coordinates
            const wrist = this.transformLandmark(landmarks[0]);           // Wrist
            const indexMCP = this.transformLandmark(landmarks[5]);        // Index finger base
            const indexPIP = this.transformLandmark(landmarks[6]);        // Index finger middle joint
            const indexDIP = this.transformLandmark(landmarks[7]);        // Index finger top joint
            const indexTip = this.transformLandmark(landmarks[8]);        // Index finger tip
            const middleMCP = this.transformLandmark(landmarks[9]);       // For hand angle calculation
            const pinkyMCP = this.transformLandmark(landmarks[17]);       // For hand angle calculation

            if (!wrist || !indexTip) continue;

            // Calculate hand rotation angle for perspective effect
            const handAngle = Math.atan2(
                middleMCP.y - wrist.y,
                middleMCP.x - wrist.x
            );

            // ========== 1. DIGITAL WRIST BRACELET ==========
            this.drawWristBracelet(wrist, handAngle, time);

            // ========== 2. DASHED LINE FROM WRIST TO INDEX TIP ==========
            this.drawIndexConnector(wrist, indexMCP, indexPIP, indexDIP, indexTip, time);

            // ========== 3. JOINT NODES ==========
            this.drawJointNode(indexPIP, time, 0);
            this.drawJointNode(indexDIP, time, 1);

            // ========== 4. PRECISION RETICLE AT FINGERTIP ==========
            this.drawPrecisionReticle(indexTip, time);
        }
    }

    // Draw 3 concentric rotating/pulsing rings around the wrist
    drawWristBracelet(wrist, handAngle, time) {
        this.ctx.save();
        this.ctx.translate(wrist.x, wrist.y);
        
        // Apply slight perspective rotation based on hand angle
        const perspectiveScale = 0.3 + Math.abs(Math.cos(handAngle)) * 0.7;
        
        for (let ring = 0; ring < 3; ring++) {
            const baseRadius = 25 + ring * 8;
            const rotation = time * (0.5 + ring * 0.2) * (ring % 2 === 0 ? 1 : -1);
            const pulse = 1 + Math.sin(time * 3 + ring * 0.5) * 0.05;
            const radius = baseRadius * pulse;
            
            // Ring opacity varies with pulse
            const alpha = 0.15 + Math.sin(time * 2 + ring) * 0.1;
            
            this.ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
            this.ctx.lineWidth = 0.5;
            this.ctx.shadowColor = 'rgba(0, 255, 255, 0.3)';
            this.ctx.shadowBlur = 3;
            
            this.ctx.beginPath();
            
            // Draw ellipse for perspective effect
            this.ctx.save();
            this.ctx.rotate(rotation);
            this.ctx.scale(1, perspectiveScale);
            this.ctx.arc(0, 0, radius, 0, Math.PI * 2);
            this.ctx.restore();
            
            this.ctx.stroke();
            
            // Add small tick marks on outermost ring
            if (ring === 2) {
                const tickCount = 12;
                for (let i = 0; i < tickCount; i++) {
                    const tickAngle = (i / tickCount) * Math.PI * 2 + rotation;
                    const innerR = radius - 3;
                    const outerR = radius;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(
                        Math.cos(tickAngle) * innerR,
                        Math.sin(tickAngle) * innerR * perspectiveScale
                    );
                    this.ctx.lineTo(
                        Math.cos(tickAngle) * outerR,
                        Math.sin(tickAngle) * outerR * perspectiveScale
                    );
                    this.ctx.stroke();
                }
            }
        }
        
        this.ctx.shadowBlur = 0;
        this.ctx.restore();
    }

    // Draw dashed line connector from wrist through index finger joints to tip
    drawIndexConnector(wrist, mcp, pip, dip, tip, time) {
        this.ctx.save();
        
        // Animated dash offset
        const dashOffset = time * 30;
        
        this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.25)';
        this.ctx.lineWidth = 0.5;
        this.ctx.setLineDash([4, 6]);
        this.ctx.lineDashOffset = -dashOffset;
        this.ctx.shadowColor = 'rgba(0, 255, 255, 0.2)';
        this.ctx.shadowBlur = 2;
        
        // Draw path through all joints
        this.ctx.beginPath();
        this.ctx.moveTo(wrist.x, wrist.y);
        
        if (mcp) this.ctx.lineTo(mcp.x, mcp.y);
        if (pip) this.ctx.lineTo(pip.x, pip.y);
        if (dip) this.ctx.lineTo(dip.x, dip.y);
        if (tip) this.ctx.lineTo(tip.x, tip.y);
        
        this.ctx.stroke();
        
        // Reset dash
        this.ctx.setLineDash([]);
        this.ctx.shadowBlur = 0;
        this.ctx.restore();
    }

    // Draw glowing node at joint position
    drawJointNode(joint, time, index) {
        if (!joint) return;
        
        this.ctx.save();
        
        // Pulsing glow
        const pulse = 0.5 + Math.sin(time * 4 + index * 1.5) * 0.5;
        const radius = 2 + pulse;
        
        // Outer glow
        this.ctx.shadowColor = 'rgba(0, 255, 255, 0.6)';
        this.ctx.shadowBlur = 6;
        
        // Inner bright point
        const gradient = this.ctx.createRadialGradient(
            joint.x, joint.y, 0,
            joint.x, joint.y, radius * 2
        );
        gradient.addColorStop(0, `rgba(255, 255, 255, ${0.8 * pulse})`);
        gradient.addColorStop(0.3, `rgba(0, 255, 255, ${0.6 * pulse})`);
        gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
        
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(joint.x, joint.y, radius * 2, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Core point
        this.ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * pulse})`;
        this.ctx.beginPath();
        this.ctx.arc(joint.x, joint.y, 1.5, 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.shadowBlur = 0;
        this.ctx.restore();
    }

    // Draw precision reticle at fingertip (interaction point)
    drawPrecisionReticle(tip, time) {
        if (!tip) return;
        
        this.ctx.save();
        this.ctx.translate(tip.x, tip.y);
        
        // Pulsing effect
        const pulse = 1 + Math.sin(time * 5) * 0.15;
        const rotation = time * 0.5;
        
        // Outer reticle ring
        const outerRadius = 12 * pulse;
        
        this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
        this.ctx.lineWidth = 0.5;
        this.ctx.shadowColor = 'rgba(0, 255, 255, 0.5)';
        this.ctx.shadowBlur = 8;
        
        // Rotating outer circle with gaps
        this.ctx.beginPath();
        for (let i = 0; i < 4; i++) {
            const startAngle = rotation + (i * Math.PI / 2) + 0.2;
            const endAngle = rotation + ((i + 1) * Math.PI / 2) - 0.2;
            this.ctx.arc(0, 0, outerRadius, startAngle, endAngle);
        }
        this.ctx.stroke();
        
        // Inner static circle
        this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 5, 0, Math.PI * 2);
        this.ctx.stroke();
        
        // Crosshair lines
        const crossSize = 8;
        this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
        this.ctx.lineWidth = 0.5;
        
        // Horizontal line (with gap in center)
        this.ctx.beginPath();
        this.ctx.moveTo(-crossSize, 0);
        this.ctx.lineTo(-3, 0);
        this.ctx.moveTo(3, 0);
        this.ctx.lineTo(crossSize, 0);
        this.ctx.stroke();
        
        // Vertical line (with gap in center)
        this.ctx.beginPath();
        this.ctx.moveTo(0, -crossSize);
        this.ctx.lineTo(0, -3);
        this.ctx.moveTo(0, 3);
        this.ctx.lineTo(0, crossSize);
        this.ctx.stroke();
        
        // Center bright dot
        const centerPulse = 0.6 + Math.sin(time * 6) * 0.4;
        const centerGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, 4);
        centerGradient.addColorStop(0, `rgba(255, 255, 255, ${centerPulse})`);
        centerGradient.addColorStop(0.5, `rgba(0, 255, 255, ${centerPulse * 0.7})`);
        centerGradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
        
        this.ctx.fillStyle = centerGradient;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 4, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Intense center point
        this.ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * centerPulse})`;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 1.5, 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.shadowBlur = 0;
        this.ctx.restore();
    }

    // ========== HAND PARTICLE & MAP SYSTEM ==========
    renderHandParticleSystem(hands, deltaTime) {
        if (!this.handParticleSystem || !this.handParticlesEnabled) return;
        
        // Detectar gestos
        const gestureState = this.gestureDetector.detect(hands);
        
        // Actualizar sistema de partículas
        this.handParticleSystem.update(hands, deltaTime, gestureState);
        
        // Renderizar mapa de mano
        if (this.handMapRenderer) {
            this.handMapRenderer.renderHandMap(hands, deltaTime, gestureState);
            this.handMapRenderer.setVisible(true);
            
            // Renderizar overlay del mapa en el canvas 2D
            this.handMapRenderer.renderMapOverlay(this.ctx, this.canvas.width, this.canvas.height);
        }
    }
    
    toggleHandParticles() {
        this.handParticlesEnabled = !this.handParticlesEnabled;
        if (this.handParticleSystem && this.handParticleSystem.particleMesh) {
            this.handParticleSystem.particleMesh.visible = this.handParticlesEnabled;
        }
        if (this.handMapRenderer) {
            this.handMapRenderer.setVisible(this.handParticlesEnabled);
        }
        log(`HAND PARTICLES: ${this.handParticlesEnabled ? 'ENABLED' : 'DISABLED'}`);
    }
}

// --- DRAGGABLE SYSTEM ---
class DraggableSystem {
    constructor() {
        this.isDragging = false;
        this.currentElement = null;
        this.offsetX = 0;
        this.offsetY = 0;
        this.isHandDragging = false;
        this.draggedByHand = null;
        this.handGrabThreshold = 150; // Distance in pixels to detect hand grab (increased for better detection)
        this.lastHandPosition = null;
        this.init();
    }

    init() {
        document.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        document.addEventListener('mouseup', () => this.handleMouseUp());

        // Touch support
        document.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
        document.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        document.addEventListener('touchend', () => this.handleMouseUp());
    }

    handleMouseDown(e) {
        const handle = e.target.closest('.drag-handle');
        if (handle && handle.parentElement.classList.contains('draggable')) {
            e.preventDefault();
            this.startDrag(handle.parentElement, e.clientX, e.clientY);
        }
    }

    handleTouchStart(e) {
        const handle = e.target.closest('.drag-handle');
        if (handle && handle.parentElement.classList.contains('draggable')) {
            e.preventDefault();
            const touch = e.touches[0];
            this.startDrag(handle.parentElement, touch.clientX, touch.clientY);
        }
    }

    startDrag(element, clientX, clientY) {
        this.isDragging = true;
        this.currentElement = element;
        this.currentElement.classList.add('dragging');

        const rect = element.getBoundingClientRect();
        this.offsetX = clientX - rect.left;
        this.offsetY = clientY - rect.top;
    }

    handleMouseMove(e) {
        if (this.isDragging && this.currentElement) {
            e.preventDefault();
            this.updatePosition(e.clientX, e.clientY);
        }
    }

    handleTouchMove(e) {
        if (this.isDragging && this.currentElement) {
            e.preventDefault(); // CRITICAL: Prevents page scroll while dragging
            e.stopPropagation(); // Prevents event bubbling
            const touch = e.touches[0];
            this.updatePosition(touch.clientX, touch.clientY);
        }
    }

    updatePosition(clientX, clientY) {
        const newX = Math.max(0, Math.min(window.innerWidth - this.currentElement.offsetWidth, clientX - this.offsetX));
        const newY = Math.max(0, Math.min(window.innerHeight - this.currentElement.offsetHeight, clientY - this.offsetY));

        this.currentElement.style.left = newX + 'px';
        this.currentElement.style.top = newY + 'px';
        this.currentElement.style.transform = 'none';
    }

    handleMouseUp() {
        if (this.currentElement) {
            this.currentElement.classList.remove('dragging');
        }
        this.isDragging = false;
        this.currentElement = null;
    }

    // === HAND GESTURE DRAGGING ===
    updateHandDragging(hands, mode) {
        if (mode !== 'OPERATOR' && mode !== 'CAROUSEL') {
            this.releaseHandDrag();
            return;
        }

        if (!hands || !hands.landmarks || hands.landmarks.length === 0) {
            this.releaseHandDrag();
            return;
        }

        // Check if any hand is grabbing a panel
        for (let i = 0; i < hands.landmarks.length && i < 2; i++) {
            const landmarks = hands.landmarks[i];
            if (!landmarks) continue;

            const handGrabGesture = this.detectGrabGesture(landmarks);
            const handCenter = this.getHandCenter(landmarks);

            if (handGrabGesture && !this.isHandDragging) {
                // Try to grab a nearby panel
                const nearbyPanel = this.findNearbyPanel(handCenter);
                if (nearbyPanel) {
                    // Only grab if the gesture is stable (hand hasn't moved much recently)
                    // This prevents accidental grabs from quick gestures
                    this.startHandDrag(nearbyPanel, handCenter);
                    break;
                }
            } else if (this.isHandDragging && this.draggedByHand) {
                // Continue dragging with hand
                if (handGrabGesture) {
                    this.updateHandDragPosition(handCenter);
                } else {
                    // Add a small delay before releasing to prevent accidental releases
                    // Only release if hand is clearly open (not just a brief moment)
                    this.releaseHandDrag();
                }
                break;
            }
        }

        // Release if no grabbing gesture
        if (!this.isHandDragging && !this.detectAnyGrabGesture(hands)) {
            this.releaseHandDrag();
        }
    }

    detectGrabGesture(landmarks) {
        // Detect fist/closed hand gesture for grabbing
        // Alternative: check if index finger is curled toward palm (simple fist detection)
        const indexTip = landmarks[8];
        const indexDip = landmarks[7]; // Index finger middle joint
        const palmCenter = landmarks[9];

        if (!indexTip || !indexDip || !palmCenter) return false;

        // Check if index finger tip is below the middle joint (curled finger)
        const fingerCurled = indexTip.y > indexDip.y;

        // Check if index tip is close to palm
        const tipToPalmDistance = Math.hypot(
            (indexTip.x - palmCenter.x) * 1920,
            (indexTip.y - palmCenter.y) * 1080
        );

        // Gesture detected silently

        // Consider it a grab gesture if finger is curled AND close to palm
        return fingerCurled && tipToPalmDistance < 200;
    }

    detectAnyGrabGesture(hands) {
        if (!hands || !hands.landmarks) return false;

        for (const landmarks of hands.landmarks) {
            if (this.detectGrabGesture(landmarks)) {
                return true;
            }
        }
        return false;
    }

    getHandCenter(landmarks) {
        // Use palm center (landmark 9 - middle finger knuckle) as hand center for better accuracy
        const palmCenter = landmarks[9];
        if (!palmCenter) {
            // Fallback to wrist if palm center not available
            const wrist = landmarks[0];
            if (!wrist) return null;
            // Apply mirror correction for natural movement (since main canvas is mirrored)
            return {
                x: (1 - wrist.x) * window.innerWidth,
                y: wrist.y * window.innerHeight
            };
        }

        // Apply mirror correction for natural movement (since main canvas is mirrored)
        return {
            x: (1 - palmCenter.x) * window.innerWidth,
            y: palmCenter.y * window.innerHeight
        };
    }

    findNearbyPanel(handCenter) {
        if (!handCenter) return null;

        // Clear all hand-hover states first
        document.querySelectorAll('.hand-hover').forEach(el => {
            el.classList.remove('hand-hover');
        });

        const draggablePanels = document.querySelectorAll('.draggable');
        let closestPanel = null;
        let minDistance = this.handGrabThreshold;

        for (const panel of draggablePanels) {
            if (!panel.offsetParent) continue; // Skip hidden panels

            const rect = panel.getBoundingClientRect();
            const panelCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };

            const distance = Math.hypot(
                handCenter.x - panelCenter.x,
                handCenter.y - panelCenter.y
            );

            // Add hover effect for nearby panels
            if (distance < this.handGrabThreshold * 1.5) {
                panel.classList.add('hand-hover');
            }

            if (distance < minDistance) {
                minDistance = distance;
                closestPanel = panel;
            }
        }

        return closestPanel;
    }

    startHandDrag(panel, handCenter) {
        this.isHandDragging = true;
        this.draggedByHand = panel;
        this.lastHandPosition = handCenter;

        // For hand dragging, we want the panel center to follow the hand center exactly
        // So we set offset to zero (panel center = hand center)
        this.offsetX = 0;
        this.offsetY = 0;

        // Position the panel center exactly at the hand center when grabbing
        const rect = panel.getBoundingClientRect();
        const panelCenterX = rect.left + rect.width / 2;
        const panelCenterY = rect.top + rect.height / 2;

        // Move panel so its center is at hand position
        const newX = Math.max(0, Math.min(window.innerWidth - panel.offsetWidth,
            handCenter.x - panel.offsetWidth / 2));
        const newY = Math.max(0, Math.min(window.innerHeight - panel.offsetHeight,
            handCenter.y - panel.offsetHeight / 2));

        panel.style.left = newX + 'px';
        panel.style.top = newY + 'px';
        panel.style.transform = 'none';

        panel.classList.add('dragging');
    }

    updateHandDragPosition(handCenter) {
        if (!this.draggedByHand || !handCenter || !this.lastHandPosition) return;

        // For hand dragging, we want smooth following of the hand center
        // The panel center should follow the hand center exactly
        const newX = Math.max(0, Math.min(window.innerWidth - this.draggedByHand.offsetWidth,
            handCenter.x - this.draggedByHand.offsetWidth / 2));
        const newY = Math.max(0, Math.min(window.innerHeight - this.draggedByHand.offsetHeight,
            handCenter.y - this.draggedByHand.offsetHeight / 2));

        this.draggedByHand.style.left = newX + 'px';
        this.draggedByHand.style.top = newY + 'px';
        this.draggedByHand.style.transform = 'none';

        this.lastHandPosition = handCenter;
    }

    releaseHandDrag() {
        if (this.draggedByHand) {
            this.draggedByHand.classList.remove('dragging');
        }

        // Clear all hand-hover states
        document.querySelectorAll('.hand-hover').forEach(el => {
            el.classList.remove('hand-hover');
        });

        this.isHandDragging = false;
        this.draggedByHand = null;
        this.lastHandPosition = null;
    }
}

// --- CAROUSEL SYSTEM ---
class CarouselSystem {
    constructor() {
        this.canvas = document.getElementById('carousel-canvas');
        this.ctx = this.canvas ? this.canvas.getContext('2d') : null;
        this.images = [];
        this.currentIndex = 0;
        this.rotation = 0;
        this.targetRotation = 0;
        this.radius = 150;
        this.imageWidth = 120;
        this.imageHeight = 80;
        this.lastIndexFingerX = null;
        this.swipeThreshold = 30;
        this.isInitialized = false;
        
        // Touch swipe state
        this.touchStartX = null;
        this.touchStartY = null;
        this.isTouchSwiping = false;
        this.touchSwipeThreshold = 50;
        
        // Panel drag state (mouse & touch)
        this.isPanelDragging = false;
        this.panelOffsetX = 0;
        this.panelOffsetY = 0;

        if (this.canvas && this.ctx) {
            this.initImages();
            this.resize();
            this.initTouchEvents();
            window.addEventListener('resize', () => this.resize());
        }
    }
    
    // ========== TOUCH & MOUSE EVENT HANDLERS ==========
    initTouchEvents() {
        const panel = document.getElementById('carousel-panel');
        const dragHandle = panel ? panel.querySelector('.drag-handle') : null;
        if (!panel) return;
        
        // Keep canvas pointer-events as none so drag-handle works
        // this.canvas.style.pointerEvents = 'auto'; // DISABLED - interferes with panel drag
        
        // ========== MOUSE DRAG FOR PANEL ==========
        // Mouse down on drag-handle or panel header starts panel drag
        if (dragHandle) {
            dragHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                this.isPanelDragging = true;
                const rect = panel.getBoundingClientRect();
                this.panelOffsetX = e.clientX - rect.left;
                this.panelOffsetY = e.clientY - rect.top;
                panel.style.cursor = 'grabbing';
                dragHandle.style.cursor = 'grabbing';
            });
        }
        
        // Also allow dragging from the panel border area
        panel.addEventListener('mousedown', (e) => {
            // Only if clicking on panel border, not content or canvas
            if (e.target === panel || e.target.classList.contains('drag-handle')) {
                e.preventDefault();
                this.isPanelDragging = true;
                const rect = panel.getBoundingClientRect();
                this.panelOffsetX = e.clientX - rect.left;
                this.panelOffsetY = e.clientY - rect.top;
                panel.style.cursor = 'grabbing';
            }
        });
        
        // Mouse move for panel dragging
        document.addEventListener('mousemove', (e) => {
            if (!this.isPanelDragging) return;
            
            const newX = Math.max(0, Math.min(window.innerWidth - panel.offsetWidth, e.clientX - this.panelOffsetX));
            const newY = Math.max(0, Math.min(window.innerHeight - panel.offsetHeight, e.clientY - this.panelOffsetY));
            
            panel.style.left = newX + 'px';
            panel.style.top = newY + 'px';
            panel.style.transform = 'none';
        });
        
        // Mouse up ends panel dragging
        document.addEventListener('mouseup', () => {
            if (this.isPanelDragging) {
                this.isPanelDragging = false;
                panel.style.cursor = 'grab';
                if (dragHandle) dragHandle.style.cursor = 'grab';
            }
        });
        
        // ========== TOUCH EVENTS ==========
        // Touch start
        panel.addEventListener('touchstart', (e) => {
            // If touching drag-handle, drag panel instead of rotating carousel
            if (e.target.closest('.drag-handle')) {
                this.isPanelDragging = true;
                const rect = panel.getBoundingClientRect();
                this.panelOffsetX = e.touches[0].clientX - rect.left;
                this.panelOffsetY = e.touches[0].clientY - rect.top;
                return;
            }
            
            if (e.touches.length === 1) {
                this.touchStartX = e.touches[0].clientX;
                this.touchStartY = e.touches[0].clientY;
                this.isTouchSwiping = true;
            }
        }, { passive: true });
        
        // Touch move
        panel.addEventListener('touchmove', (e) => {
            // Handle panel dragging
            if (this.isPanelDragging) {
                const touch = e.touches[0];
                const newX = Math.max(0, Math.min(window.innerWidth - panel.offsetWidth, touch.clientX - this.panelOffsetX));
                const newY = Math.max(0, Math.min(window.innerHeight - panel.offsetHeight, touch.clientY - this.panelOffsetY));
                
                panel.style.left = newX + 'px';
                panel.style.top = newY + 'px';
                panel.style.transform = 'none';
                return;
            }
            
            if (!this.isTouchSwiping || !this.touchStartX) return;
            
            const currentX = e.touches[0].clientX;
            const deltaX = currentX - this.touchStartX;
            
            // Real-time rotation feedback during swipe
            const swipeRotation = (deltaX / window.innerWidth) * Math.PI;
            this.rotation = this.targetRotation - swipeRotation;
        }, { passive: true });
        
        // Touch end
        panel.addEventListener('touchend', (e) => {
            // Handle panel drag end
            if (this.isPanelDragging) {
                this.isPanelDragging = false;
                return;
            }
            
            if (!this.isTouchSwiping || !this.touchStartX) return;
            
            const endX = e.changedTouches[0].clientX;
            const deltaX = endX - this.touchStartX;
            
            // Determine if swipe was significant
            if (Math.abs(deltaX) > this.touchSwipeThreshold) {
                if (deltaX > 0) {
                    // Swipe right - previous image
                    this.currentIndex = (this.currentIndex - 1 + this.images.length) % this.images.length;
                    log(`CAROUSEL: Swipe right - showing image ${this.currentIndex + 1}`);
                } else {
                    // Swipe left - next image
                    this.currentIndex = (this.currentIndex + 1) % this.images.length;
                    log(`CAROUSEL: Swipe left - showing image ${this.currentIndex + 1}`);
                }
                
                // Update target rotation
                this.targetRotation = (this.currentIndex / this.images.length) * Math.PI * 2;
                
                // Update info display
                const carouselInfo = document.getElementById('carousel-info');
                if (carouselInfo) {
                    carouselInfo.textContent = `IMAGE ${this.currentIndex + 1} / ${this.images.length}`;
                }
            } else {
                // Snap back to current position
                this.targetRotation = (this.currentIndex / this.images.length) * Math.PI * 2;
            }
            
            // Reset touch state
            this.touchStartX = null;
            this.touchStartY = null;
            this.isTouchSwiping = false;
        }, { passive: true });
        
        log('CAROUSEL: Touch & mouse events initialized');
    }

    initImages() {
        // Create cyberpunk-style placeholder images for all expected images
        const cyberpunkData = [
            { text: 'ACORRALADO', color: '#FF6B35', subtitle: 'CYBER TRAP' },
            { text: 'CUERVO', color: '#00FF00', subtitle: 'SHADOW BIRD' },
            { text: 'DEMONIO', color: '#FF0055', subtitle: 'DIGITAL DEMON' },
            { text: 'DIAMANTE', color: '#00FFFF', subtitle: 'DATA CRYSTAL' },
            { text: 'IMPERIO', color: '#FFFF00', subtitle: 'CYBER EMPIRE' },
            { text: 'NADIE', color: '#FF00FF', subtitle: 'VOID ENTITY' },
            { text: 'REY', color: '#00FF88', subtitle: 'DIGITAL MONARCH' }
        ];

        const placeholderImages = cyberpunkData.map(data => this.createCyberpunkImage(data.text, data.color, data.subtitle));

        // Try to load real images, fallback to placeholders
        const imageFiles = [
            'acorralado.jpg',
            'cuervo.jpg',
            'demonio.jpg',
            'diamante.jpg',
            'imperio.jpg',
            'nadie.jpg',
            'rey.jpg'
        ];

        let loadedCount = 0;
        let realImagesLoaded = 0;
        const totalImages = Math.max(imageFiles.length, placeholderImages.length);

        // Add placeholder images first
        placeholderImages.forEach(img => {
            this.images.push(img);
        });

        // Try to load real images and replace placeholders if successful
        imageFiles.forEach((fileName, index) => {
            const img = new Image();
            img.onload = () => {
                // Replace placeholder with real image if it loads successfully
                if (index < this.images.length) {
                    this.images[index] = img;
                    realImagesLoaded++;
                    log(`CAROUSEL: ✅ ${fileName} loaded successfully (${realImagesLoaded}/${imageFiles.length})`);
                }
                loadedCount++;
                if (loadedCount === imageFiles.length) {
                    log(`CAROUSEL: Real image loading complete. ${realImagesLoaded} real images loaded!`);
                }
            };

            img.onerror = () => {
                log(`CAROUSEL: ❌ ${fileName} failed to load, keeping cyberpunk placeholder (${realImagesLoaded}/${imageFiles.length} real images loaded)`);
                loadedCount++;
                if (loadedCount === imageFiles.length) {
                    log(`CAROUSEL: All images ready (${realImagesLoaded} real + ${imageFiles.length - realImagesLoaded} placeholder)`);
                }
            };

            // Set crossOrigin to handle potential CORS issues
            img.crossOrigin = 'anonymous';
            img.src = `./img/${fileName}`;
        });

        // Mark as initialized immediately since we have placeholder images
        this.isInitialized = true;
        log(`CAROUSEL: 7 cyberpunk placeholder images ready as fallback`);
        log(`CAROUSEL: Loading ${imageFiles.length} real images from ./img/ directory`);
    }

    createCyberpunkImage(text, color, subtitle = 'CYBERPUNK OS') {
        // Create a cyberpunk-style placeholder image
        const canvas = document.createElement('canvas');
        canvas.width = this.imageWidth;
        canvas.height = this.imageHeight;
        const ctx = canvas.getContext('2d');

        // Base dark background
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, this.imageWidth, this.imageHeight);

        // Unique pattern based on text (deterministic)
        const patternSeed = text.length % 5;
        switch (patternSeed) {
            case 0: // Circuit pattern
                this.drawCircuitPattern(ctx, color);
                break;
            case 1: // Matrix rain
                this.drawMatrixPattern(ctx, color);
                break;
            case 2: // Geometric
                this.drawGeometricPattern(ctx, color);
                break;
            case 3: // Wave pattern
                this.drawWavePattern(ctx, color);
                break;
            case 4: // Particle field
                this.drawParticlePattern(ctx, color);
                break;
        }

        // Main text with glow
        ctx.shadowColor = color;
        ctx.shadowBlur = 8;
        ctx.fillStyle = color;
        ctx.font = 'bold 16px Share Tech Mono';
        ctx.textAlign = 'center';
        ctx.fillText(text, this.imageWidth / 2, this.imageHeight / 2);
        ctx.shadowBlur = 0;

        // Subtitle
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.font = '10px Share Tech Mono';
        ctx.fillText(subtitle, this.imageWidth / 2, this.imageHeight / 2 + 22);

        // Glowing border
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.shadowColor = color;
        ctx.shadowBlur = 6;
        ctx.strokeRect(3, 3, this.imageWidth - 6, this.imageHeight - 6);
        ctx.shadowBlur = 0;

        // Corner accents
        this.drawCornerAccents(ctx, color);

        const img = new Image();
        img.src = canvas.toDataURL();
        return img;
    }

    drawCircuitPattern(ctx, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.3;

        // Horizontal lines
        for (let y = 20; y < this.imageHeight; y += 30) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(this.imageWidth, y);
            ctx.stroke();

            // Add circuit nodes
            for (let x = 30; x < this.imageWidth; x += 60) {
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
            }
        }

        ctx.globalAlpha = 1;
    }

    drawMatrixPattern(ctx, color) {
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.4;

        // Matrix-like falling characters effect
        ctx.font = '12px monospace';
        for (let x = 10; x < this.imageWidth; x += 15) {
            const char = String.fromCharCode(65 + Math.floor(Math.random() * 26));
            const y = 20 + Math.random() * (this.imageHeight - 40);
            ctx.fillText(char, x, y);
        }

        ctx.globalAlpha = 1;
    }

    drawGeometricPattern(ctx, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.2;

        // Hexagonal pattern
        const size = 15;
        for (let x = 0; x < this.imageWidth + size; x += size * 1.5) {
            for (let y = 0; y < this.imageHeight + size; y += size * 1.7) {
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const px = x + size * Math.cos(angle);
                    const py = y + size * Math.sin(angle);
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
            }
        }

        ctx.globalAlpha = 1;
    }

    drawWavePattern(ctx, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.3;

        // Sine wave pattern
        ctx.beginPath();
        for (let x = 0; x < this.imageWidth; x += 2) {
            const y = this.imageHeight / 2 + Math.sin(x * 0.05) * 20;
            if (x === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();

        ctx.globalAlpha = 1;
    }

    drawParticlePattern(ctx, color) {
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.5;

        // Random particle field
        for (let i = 0; i < 50; i++) {
            const x = Math.random() * this.imageWidth;
            const y = Math.random() * this.imageHeight;
            const size = Math.random() * 3 + 1;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.globalAlpha = 1;
    }

    drawCornerAccents(ctx, color) {
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.6;

        // Corner triangles
        const size = 15;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(size, 0);
        ctx.lineTo(0, size);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(this.imageWidth, 0);
        ctx.lineTo(this.imageWidth - size, 0);
        ctx.lineTo(this.imageWidth, size);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(0, this.imageHeight);
        ctx.lineTo(size, this.imageHeight);
        ctx.lineTo(0, this.imageHeight - size);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(this.imageWidth, this.imageHeight);
        ctx.lineTo(this.imageWidth - size, this.imageHeight);
        ctx.lineTo(this.imageWidth, this.imageHeight - size);
        ctx.closePath();
        ctx.fill();

        ctx.globalAlpha = 1;
    }

    createFallbackImage(fileName) {
        // Create a fallback placeholder image for failed loads
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = this.imageWidth;
        tempCanvas.height = this.imageHeight;
        const tempCtx = tempCanvas.getContext('2d');

        // Dark background
        tempCtx.fillStyle = '#111';
        tempCtx.fillRect(0, 0, this.imageWidth, this.imageHeight);

        // Error text
        tempCtx.fillStyle = '#FF0055';
        tempCtx.font = 'bold 12px Share Tech Mono';
        tempCtx.textAlign = 'center';
        tempCtx.fillText('LOAD ERROR', this.imageWidth / 2, this.imageHeight / 2 - 10);

        // Filename
        tempCtx.fillStyle = '#666';
        tempCtx.font = '10px Share Tech Mono';
        tempCtx.fillText(fileName, this.imageWidth / 2, this.imageHeight / 2 + 10);

        // Border
        tempCtx.strokeStyle = '#FF0055';
        tempCtx.lineWidth = 2;
        tempCtx.strokeRect(2, 2, this.imageWidth - 4, this.imageHeight - 4);

        const fallbackImg = new Image();
        fallbackImg.src = tempCanvas.toDataURL();
        return fallbackImg;
    }

    drawPattern(ctx, pattern, baseColor, width, height) {
        ctx.globalAlpha = 0.3;

        switch (pattern) {
            case 'circles':
                for (let i = 0; i < 8; i++) {
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    const radius = Math.random() * 15 + 5;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.adjustColor(baseColor, Math.random() * 60 - 30);
                    ctx.fill();
                }
                break;

            case 'grid':
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 1;
                for (let x = 0; x < width; x += 20) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                for (let y = 0; y < height; y += 20) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
                break;

            case 'waves':
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let x = 0; x < width; x += 5) {
                    const y = height / 2 + Math.sin(x * 0.1) * 20;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                break;

            case 'noise':
                const imageData = ctx.createImageData(width, height);
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const noise = Math.random() * 100;
                    imageData.data[i] = noise;     // R
                    imageData.data[i + 1] = noise; // G
                    imageData.data[i + 2] = noise; // B
                    imageData.data[i + 3] = 100;   // A
                }
                ctx.putImageData(imageData, 0, 0);
                break;
        }

        ctx.globalAlpha = 1;
    }

    adjustColor(color, amount) {
        const usePound = color[0] === '#';
        const col = usePound ? color.slice(1) : color;

        const num = parseInt(col, 16);
        let r = (num >> 16) + amount;
        let g = (num >> 8 & 0x00FF) + amount;
        let b = (num & 0x0000FF) + amount;

        r = r > 255 ? 255 : r < 0 ? 0 : r;
        g = g > 255 ? 255 : g < 0 ? 0 : g;
        b = b > 255 ? 255 : b < 0 ? 0 : b;

        return (usePound ? '#' : '') + (r << 16 | g << 8 | b).toString(16);
    }

    resize() {
        if (!this.canvas) return;

        const rect = this.canvas.getBoundingClientRect();
        
        // Only resize if dimensions are valid (panel must be visible)
        if (rect.width > 0 && rect.height > 0) {
            this.canvas.width = rect.width;
            this.canvas.height = rect.height;

            // Adjust cylinder radius based on canvas size
            this.radius = Math.min(rect.width, rect.height) * 0.35;
        }
    }

    update(hands) {
        if (!this.isInitialized || !this.ctx) {
            return;
        }

        // Handle swipe gestures with index finger
        this.handleSwipeGesture(hands);

        // Smooth rotation interpolation
        const rotationDiff = this.targetRotation - this.rotation;
        this.rotation += rotationDiff * 0.1;

        // Update current index based on rotation
        const normalizedRotation = this.rotation % (Math.PI * 2);
        const indexFromRotation = Math.round(normalizedRotation / (Math.PI * 2) * this.images.length) % this.images.length;
        this.currentIndex = Math.max(0, Math.min(this.images.length - 1, indexFromRotation));

        // Update info display with image names
        const infoEl = document.getElementById('carousel-info');
        if (infoEl) {
            const imageNames = [
                'ACORRALADO', 'CUERVO', 'DEMONIO', 'DIAMANTE',
                'IMPERIO', 'NADIE', 'REY'
            ];
            const currentName = imageNames[this.currentIndex] || `IMAGE ${this.currentIndex + 1}`;
            infoEl.textContent = `${currentName} [${this.currentIndex + 1}/7]`;
        }

        this.render();
    }

    handleSwipeGesture(hands) {
        if (!hands || !hands.landmarks || hands.landmarks.length === 0) {
            this.lastIndexFingerX = null;
            return;
        }

        // Use first hand's index finger
        const landmarks = hands.landmarks[0];
        if (!landmarks || !landmarks[8]) return;

        const indexFinger = window.app.engine.transformLandmark(landmarks[8]);
        const currentX = indexFinger.x;

        if (this.lastIndexFingerX !== null) {
            const deltaX = currentX - this.lastIndexFingerX;

            // Only consider significant movements
            if (Math.abs(deltaX) > 5) {
                // Convert pixel movement to rotation (swipe right = rotate left, etc.)
                const rotationDelta = deltaX * 0.01;
                this.targetRotation += rotationDelta;

                // Normalize target rotation
                while (this.targetRotation < 0) this.targetRotation += Math.PI * 2;
                this.targetRotation %= Math.PI * 2;
            }
        }

        this.lastIndexFingerX = currentX;
    }

    render() {
        if (!this.ctx || !this.canvas) return;

        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        // Skip cylinder base for transparent look

        // Draw images on cylinder surface
        for (let i = 0; i < this.images.length; i++) {
            const angle = (i / this.images.length) * Math.PI * 2 - this.rotation;
            const normalizedAngle = ((angle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);

            // Calculate 3D position on cylinder
            const x = centerX + Math.cos(angle) * this.radius;
            const z = Math.sin(angle) * this.radius * 0.5; // Depth for perspective

            // Simple perspective projection
            const scale = Math.max(0.3, 1 - Math.abs(z) / (this.radius * 0.5));
            const screenX = x;
            const screenY = centerY;

            // Only draw if not too far back
            if (scale > 0.1) {
                this.ctx.save();
                this.ctx.translate(screenX, screenY);
                this.ctx.scale(scale, scale);
                this.ctx.rotate(angle * 0.1); // Slight tilt

                // Draw image with glow if it's the current one
                if (i === this.currentIndex) {
                    this.ctx.shadowColor = 'rgba(100, 200, 255, 0.8)';
                    this.ctx.shadowBlur = 15;
                }

                // Only draw if image is loaded and not broken
                if (this.images[i].complete && this.images[i].naturalWidth !== 0) {
                    this.ctx.drawImage(
                        this.images[i],
                        -this.imageWidth / 2,
                        -this.imageHeight / 2,
                        this.imageWidth,
                        this.imageHeight
                    );
                } else {
                    // Draw placeholder if image failed to load
                    this.ctx.fillStyle = 'rgba(255, 0, 85, 0.5)';
                    this.ctx.fillRect(-this.imageWidth / 2, -this.imageHeight / 2, this.imageWidth, this.imageHeight);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '12px Share Tech Mono';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('LOADING...', 0, 0);
                }

                // Reset shadow
                this.ctx.shadowBlur = 0;
                this.ctx.restore();
            }
        }

        // Skip cylinder edges and navigation for transparent look
    }

    drawCylinderBase(centerX, centerY) {
        // Draw elliptical base
        this.ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.ellipse(centerX, centerY, this.radius, this.radius * 0.3, 0, 0, Math.PI * 2);
        this.ctx.stroke();

        // Draw vertical cylinder lines
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const x = centerX + Math.cos(angle) * this.radius;
            const topY = centerY - this.imageHeight / 2;
            const bottomY = centerY + this.imageHeight / 2;

            this.ctx.beginPath();
            this.ctx.moveTo(x, topY);
            this.ctx.lineTo(x, bottomY);
            this.ctx.stroke();
        }
    }

    drawCylinderEdges(centerX, centerY) {
        // Draw front and back edges
        this.ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
        this.ctx.lineWidth = 1;
        this.ctx.setLineDash([5, 5]);

        // Front ellipse
        this.ctx.beginPath();
        this.ctx.ellipse(centerX, centerY, this.radius, this.radius * 0.3, 0, 0, Math.PI * 2);
        this.ctx.stroke();

        // Back ellipse (smaller, more transparent)
        this.ctx.globalAlpha = 0.3;
        this.ctx.beginPath();
        this.ctx.ellipse(centerX, centerY, this.radius * 0.7, this.radius * 0.2, 0, 0, Math.PI * 2);
        this.ctx.stroke();

        this.ctx.globalAlpha = 1;
        this.ctx.setLineDash([]);
    }

    drawNavigationIndicator(centerX, centerY) {
        // Draw dots for each image
        const indicatorRadius = 120;
        for (let i = 0; i < this.images.length; i++) {
            const angle = (i / this.images.length) * Math.PI * 2;
            const x = centerX + Math.cos(angle) * indicatorRadius;
            const y = centerY + Math.sin(angle) * indicatorRadius;

            this.ctx.fillStyle = i === this.currentIndex ?
                'rgba(100, 200, 255, 0.9)' :
                'rgba(100, 200, 255, 0.3)';
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }
}

// ========== VISUAL PROFILES SYSTEM ==========
// Centralized visual configuration per mode
const VISUAL_PROFILES = {
    // Default/base profile
    _default: {
        glowIntensity: 1.0,
        scanlineOpacity: 0.3,
        grainIntensity: 0.02,
        vignetteStrength: 0.3,
        bloomStrength: 0.0,
        saturation: 1.0,
        contrast: 1.0,
        particleDensity: 1.0,
        primaryColor: '#00FFFF',
        secondaryColor: '#FF0055',
        backgroundColor: 'rgba(0,0,0,0)'
    },
    STANDBY: {
        glowIntensity: 0.3,
        scanlineOpacity: 0.1,
        grainIntensity: 0.01,
        vignetteStrength: 0.2,
        particleDensity: 0.0
    },
    HUD: {
        glowIntensity: 1.0,
        scanlineOpacity: 0.3,
        grainIntensity: 0.02,
        particleDensity: 0.5
    },
    DRAW: {
        glowIntensity: 0.8,
        scanlineOpacity: 0.2,
        grainIntensity: 0.01,
        primaryColor: '#FF0055'
    },
    XRAY: {
        glowIntensity: 1.2,
        scanlineOpacity: 0.4,
        grainIntensity: 0.03,
        saturation: 0.0,
        contrast: 1.3
    },
    INTEL: {
        glowIntensity: 1.0,
        scanlineOpacity: 0.25,
        grainIntensity: 0.02,
        particleDensity: 0.8,
        primaryColor: '#00FF00'
    },
    MATRIX: {
        glowIntensity: 1.5,
        scanlineOpacity: 0.5,
        grainIntensity: 0.04,
        saturation: 0.3,
        primaryColor: '#00FF00',
        backgroundColor: 'rgba(0,0,0,0.95)'
    },
    VOID: {
        glowIntensity: 1.2,
        scanlineOpacity: 0.0,
        grainIntensity: 0.0,
        vignetteStrength: 0.0,
        backgroundColor: 'rgba(0,0,0,1)'
    },
    WIREFRAME: {
        glowIntensity: 0.6,
        scanlineOpacity: 0.15,
        grainIntensity: 0.01,
        particleDensity: 0.3
    },
    DRONE: {
        glowIntensity: 0.9,
        scanlineOpacity: 0.35,
        grainIntensity: 0.025,
        vignetteStrength: 0.6,
        saturation: 0.7
    },
    FACE: {
        glowIntensity: 1.0,
        scanlineOpacity: 0.2,
        grainIntensity: 0.015,
        primaryColor: '#FF0055'
    },
    OPERATOR: {
        glowIntensity: 1.1,
        scanlineOpacity: 0.3,
        grainIntensity: 0.02,
        particleDensity: 0.7
    },
    CAROUSEL: {
        glowIntensity: 1.3,
        scanlineOpacity: 0.25,
        grainIntensity: 0.015,
        bloomStrength: 0.2,
        particleDensity: 0.6
    },
    SANDTABLE: {
        glowIntensity: 1.2,
        scanlineOpacity: 0.2,
        grainIntensity: 0.02,
        bloomStrength: 0.15,
        particleDensity: 1.0
    },
    TOUCH: {
        glowIntensity: 1.4,
        scanlineOpacity: 0.3,
        grainIntensity: 0.025,
        bloomStrength: 0.25,
        particleDensity: 1.2
    }
};

// Get merged profile for a mode
function getVisualProfile(mode) {
    const base = { ...VISUAL_PROFILES._default };
    const modeProfile = VISUAL_PROFILES[mode] || {};
    return { ...base, ...modeProfile };
}

// ========== GLOBAL LANDMARK SMOOTHER ==========
// Reusable EMA + prediction smoothing for all hand tracking modes
class GlobalLandmarkSmoother {
    constructor() {
        this.alpha = 0.35;           // EMA factor (0.3-0.4 = responsive but smooth)
        this.predictionFactor = 0.02; // Velocity-based prediction
        this.maxVelocity = 2.0;       // Clamp extreme velocities
        this.landmarks = new Map();   // Stores smoothed positions per hand+landmark
        this.velocities = new Map();  // Stores velocities
        this.lastTime = 0;
    }
    
    // Smooth a single landmark
    smooth(handIndex, landmarkIndex, rawPos, currentTime) {
        const key = `h${handIndex}_l${landmarkIndex}`;
        const deltaTime = Math.max(currentTime - this.lastTime, 0.016);
        
        if (!this.landmarks.has(key)) {
            // First frame - initialize
            this.landmarks.set(key, { x: rawPos.x, y: rawPos.y, z: rawPos.z || 0 });
            this.velocities.set(key, { x: 0, y: 0, z: 0 });
            return rawPos;
        }
        
        const prev = this.landmarks.get(key);
        const vel = this.velocities.get(key);
        
        // Calculate raw velocity
        const rawVelX = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, (rawPos.x - prev.x) / deltaTime));
        const rawVelY = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, (rawPos.y - prev.y) / deltaTime));
        
        // Smooth velocity with EMA
        vel.x = vel.x * 0.7 + rawVelX * 0.3;
        vel.y = vel.y * 0.7 + rawVelY * 0.3;
        
        // Apply EMA to position
        const smoothX = prev.x * (1 - this.alpha) + rawPos.x * this.alpha;
        const smoothY = prev.y * (1 - this.alpha) + rawPos.y * this.alpha;
        
        // Add prediction
        const predictedX = smoothX + vel.x * this.predictionFactor;
        const predictedY = smoothY + vel.y * this.predictionFactor;
        
        // Update stored values
        const smoothed = { x: predictedX, y: predictedY, z: rawPos.z || 0 };
        this.landmarks.set(key, smoothed);
        this.velocities.set(key, vel);
        
        return smoothed;
    }
    
    // Smooth entire hand (all 21 landmarks)
    smoothHand(handIndex, landmarks, currentTime) {
        if (!landmarks || landmarks.length < 21) return landmarks;
        
        this.lastTime = currentTime;
        
        return landmarks.map((lm, idx) => {
            if (!lm) return lm;
            return this.smooth(handIndex, idx, lm, currentTime);
        });
    }
    
    // Clear data for a specific hand
    clearHand(handIndex) {
        const keysToDelete = [];
        for (const key of this.landmarks.keys()) {
            if (key.startsWith(`h${handIndex}_`)) {
                keysToDelete.push(key);
            }
        }
        keysToDelete.forEach(k => {
            this.landmarks.delete(k);
            this.velocities.delete(k);
        });
    }
    
    // Clear all data
    reset() {
        this.landmarks.clear();
        this.velocities.clear();
    }
}

// ========== HAND GRACE PERIOD SYSTEM ==========
// Maintains last valid hand state during brief tracking loss
class HandGracePeriod {
    constructor() {
        this.maxGraceFrames = 8;       // ~5-10 frames at 60fps ≈ 130ms
        this.fadeStartFrame = 4;       // Start fading after this many frames
        this.hands = new Map();        // Stores last valid hands data
        this.graceCounters = new Map(); // Frames since last valid detection
        this.fadeAlpha = new Map();    // Current fade alpha per hand
    }
    
    // Update with current detection results
    update(rawHands) {
        const currentTime = performance.now();
        const result = { landmarks: [], handedness: [], worldLandmarks: [] };
        
        // Process each potential hand slot (0 and 1)
        for (let handIdx = 0; handIdx < 2; handIdx++) {
            const hasValidHand = rawHands && 
                                 rawHands.landmarks && 
                                 rawHands.landmarks[handIdx] && 
                                 rawHands.landmarks[handIdx].length >= 21;
            
            if (hasValidHand) {
                // Valid detection - store and reset grace counter
                this.hands.set(handIdx, {
                    landmarks: rawHands.landmarks[handIdx],
                    handedness: rawHands.handedness ? rawHands.handedness[handIdx] : null,
                    worldLandmarks: rawHands.worldLandmarks ? rawHands.worldLandmarks[handIdx] : null,
                    timestamp: currentTime
                });
                this.graceCounters.set(handIdx, 0);
                this.fadeAlpha.set(handIdx, 1.0);
                
                result.landmarks[handIdx] = rawHands.landmarks[handIdx];
                if (rawHands.handedness) result.handedness[handIdx] = rawHands.handedness[handIdx];
                if (rawHands.worldLandmarks) result.worldLandmarks[handIdx] = rawHands.worldLandmarks[handIdx];
                
            } else if (this.hands.has(handIdx)) {
                // No detection but we have cached data
                const graceCount = (this.graceCounters.get(handIdx) || 0) + 1;
                this.graceCounters.set(handIdx, graceCount);
                
                if (graceCount <= this.maxGraceFrames) {
                    // Within grace period - use cached data with fade
                    const cached = this.hands.get(handIdx);
                    
                    // Calculate fade alpha
                    let alpha = 1.0;
                    if (graceCount > this.fadeStartFrame) {
                        alpha = 1 - ((graceCount - this.fadeStartFrame) / (this.maxGraceFrames - this.fadeStartFrame));
                    }
                    this.fadeAlpha.set(handIdx, Math.max(0, alpha));
                    
                    result.landmarks[handIdx] = cached.landmarks;
                    if (cached.handedness) result.handedness[handIdx] = cached.handedness;
                    if (cached.worldLandmarks) result.worldLandmarks[handIdx] = cached.worldLandmarks;
                } else {
                    // Grace period expired
                    this.hands.delete(handIdx);
                    this.graceCounters.delete(handIdx);
                    this.fadeAlpha.delete(handIdx);
                }
            }
        }
        
        // Clean up empty arrays
        result.landmarks = result.landmarks.filter(l => l !== undefined);
        result.handedness = result.handedness.filter(h => h !== undefined);
        result.worldLandmarks = result.worldLandmarks.filter(w => w !== undefined);
        
        return result;
    }
    
    // Get fade alpha for rendering
    getFadeAlpha(handIndex) {
        return this.fadeAlpha.get(handIndex) || 1.0;
    }
    
    // Check if hand is in grace period (not live tracking)
    isInGracePeriod(handIndex) {
        return (this.graceCounters.get(handIndex) || 0) > 0;
    }
    
    // Reset all grace data
    reset() {
        this.hands.clear();
        this.graceCounters.clear();
        this.fadeAlpha.clear();
    }
}

// ========== TRACKING QUALITY METER ==========
// Measures and displays real-time tracking quality
class TrackingQualityMeter {
    constructor() {
        this.jitterHistory = [];
        this.historySize = 30;          // ~0.5 second at 60fps
        this.lastLandmarks = null;
        this.landmarkCount = 0;
        this.quality = 1.0;             // 0-1 quality score
        this.isVisible = false;
        
        this.createUI();
    }
    
    createUI() {
        // Create tracking quality UI element
        this.container = document.createElement('div');
        this.container.id = 'tracking-quality-meter';
        this.container.innerHTML = `
            <div class="tq-label">TRACKING</div>
            <div class="tq-bar-container">
                <div class="tq-bar"></div>
            </div>
            <div class="tq-value">100%</div>
        `;
        this.container.style.cssText = `
            position: fixed;
            top: 70px;
            right: 15px;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(0,255,255,0.3);
            border-radius: 4px;
            padding: 8px 12px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 11px;
            color: #00FFFF;
            z-index: var(--z-decorative);
            display: none;
            min-width: 80px;
        `;
        
        // Add styles
        const style = document.createElement('style');
        style.textContent = `
            #tracking-quality-meter .tq-label {
                font-size: 9px;
                opacity: 0.7;
                margin-bottom: 4px;
            }
            #tracking-quality-meter .tq-bar-container {
                width: 100%;
                height: 4px;
                background: rgba(255,255,255,0.1);
                border-radius: 2px;
                overflow: hidden;
            }
            #tracking-quality-meter .tq-bar {
                height: 100%;
                width: 100%;
                background: linear-gradient(90deg, #FF0055, #FFFF00, #00FF00);
                transition: width 0.2s ease;
            }
            #tracking-quality-meter .tq-value {
                text-align: right;
                margin-top: 4px;
                font-size: 12px;
            }
            #tracking-quality-meter.quality-low .tq-value { color: #FF0055; }
            #tracking-quality-meter.quality-mid .tq-value { color: #FFFF00; }
            #tracking-quality-meter.quality-high .tq-value { color: #00FF00; }
        `;
        document.head.appendChild(style);
        document.body.appendChild(this.container);
    }
    
    update(hands) {
        if (!hands || !hands.landmarks || hands.landmarks.length === 0) {
            this.quality = 0;
            this.landmarkCount = 0;
            this.lastLandmarks = null;
            this.updateUI();
            return this.quality;
        }
        
        const currentLandmarks = hands.landmarks[0];
        this.landmarkCount = currentLandmarks ? currentLandmarks.length : 0;
        
        // Calculate jitter (average movement between frames)
        if (this.lastLandmarks && currentLandmarks) {
            let totalJitter = 0;
            let count = 0;
            
            for (let i = 0; i < Math.min(currentLandmarks.length, this.lastLandmarks.length); i++) {
                if (currentLandmarks[i] && this.lastLandmarks[i]) {
                    const dx = currentLandmarks[i].x - this.lastLandmarks[i].x;
                    const dy = currentLandmarks[i].y - this.lastLandmarks[i].y;
                    totalJitter += Math.sqrt(dx * dx + dy * dy);
                    count++;
                }
            }
            
            const avgJitter = count > 0 ? totalJitter / count : 0;
            this.jitterHistory.push(avgJitter);
            
            if (this.jitterHistory.length > this.historySize) {
                this.jitterHistory.shift();
            }
        }
        
        this.lastLandmarks = currentLandmarks ? [...currentLandmarks] : null;
        
        // Calculate quality score
        // Low jitter = high quality, high jitter = low quality
        const avgJitter = this.jitterHistory.length > 0 
            ? this.jitterHistory.reduce((a, b) => a + b, 0) / this.jitterHistory.length 
            : 0;
        
        // Map jitter to quality (0.001 = excellent, 0.05 = poor)
        const jitterScore = Math.max(0, 1 - (avgJitter / 0.03));
        
        // Landmark completeness score
        const completenessScore = this.landmarkCount / 21;
        
        // Combined quality
        this.quality = (jitterScore * 0.7 + completenessScore * 0.3);
        
        this.updateUI();
        return this.quality;
    }
    
    updateUI() {
        if (!this.isVisible) return;
        
        const bar = this.container.querySelector('.tq-bar');
        const value = this.container.querySelector('.tq-value');
        
        bar.style.width = `${this.quality * 100}%`;
        value.textContent = `${Math.round(this.quality * 100)}%`;
        
        // Update color class
        this.container.classList.remove('quality-low', 'quality-mid', 'quality-high');
        if (this.quality < 0.4) {
            this.container.classList.add('quality-low');
        } else if (this.quality < 0.7) {
            this.container.classList.add('quality-mid');
        } else {
            this.container.classList.add('quality-high');
        }
    }
    
    show() {
        this.isVisible = true;
        this.container.style.display = 'block';
    }
    
    hide() {
        this.isVisible = false;
        this.container.style.display = 'none';
    }
    
    toggle() {
        this.isVisible ? this.hide() : this.show();
    }
    
    getQuality() {
        return this.quality;
    }
}

// ========== DYNAMIC QUALITY SCALER ==========
// Auto-adjusts rendering quality based on FPS
class DynamicQualityScaler {
    constructor(engine) {
        this.engine = engine;
        this.targetFPS = 30;
        this.minFPS = 20;
        this.qualityLevel = 1.0;        // 0-1 quality multiplier
        this.fpsHistory = [];
        this.historySize = 60;          // 1 second at 60fps
        this.lastAdjustTime = 0;
        this.adjustCooldown = 2000;     // 2 seconds between adjustments
        this.visionSystem = null;       // Will be set by TacticalOS
        
        // Quality settings per level
        this.qualitySettings = {
            resolution: 1.0,            // Renderer pixel ratio
            antialias: true,
            particleCount: 1.0,         // Multiplier for particle systems
            shadowQuality: 1.0,
            effectsEnabled: true,
            scanlines: true,
            bloom: true
        };
    }
    
    update(currentFPS) {
        this.fpsHistory.push(currentFPS);
        if (this.fpsHistory.length > this.historySize) {
            this.fpsHistory.shift();
        }
        
        const now = performance.now();
        if (now - this.lastAdjustTime < this.adjustCooldown) return;
        
        const avgFPS = this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length;
        
        // Adjust quality based on FPS
        if (avgFPS < this.minFPS && this.qualityLevel > 0.3) {
            this.decreaseQuality();
            this.lastAdjustTime = now;
        } else if (avgFPS > this.targetFPS * 1.2 && this.qualityLevel < 1.0) {
            this.increaseQuality();
            this.lastAdjustTime = now;
        }
    }
    
    decreaseQuality() {
        this.qualityLevel = Math.max(0.3, this.qualityLevel - 0.1);
        this.applyQuality();
        this.adjustDetectionFPS();
        log(`QUALITY: Decreased to ${Math.round(this.qualityLevel * 100)}%`);
    }
    
    increaseQuality() {
        this.qualityLevel = Math.min(1.0, this.qualityLevel + 0.1);
        this.applyQuality();
        this.adjustDetectionFPS();
        log(`QUALITY: Increased to ${Math.round(this.qualityLevel * 100)}%`);
    }
    
    applyQuality() {
        const q = this.qualityLevel;
        
        // Adjust renderer
        if (this.engine && this.engine.renderer3D) {
            this.engine.renderer3D.setPixelRatio(window.devicePixelRatio * q);
        }
        
        // Update settings
        this.qualitySettings.resolution = q;
        this.qualitySettings.particleCount = q;
        this.qualitySettings.shadowQuality = q;
        this.qualitySettings.effectsEnabled = q > 0.5;
        this.qualitySettings.scanlines = q > 0.4;
        this.qualitySettings.bloom = q > 0.6;
        
        // Update CSS scanlines
        const scanlines = document.querySelector('.scanlines');
        if (scanlines) {
            scanlines.style.display = this.qualitySettings.scanlines ? 'block' : 'none';
        }
        
        // Mobile performance optimizations - disable expensive UI effects when quality is low
        if (window.innerWidth <= 768 || document.body.classList.contains('mobile-view')) {
            this.applyMobileUIOptimizations(q);
        }
        
        // Adjust main canvas resolution (render at lower res, scale with CSS)
        this.adjustCanvasResolution(q);
    }
    
    applyMobileUIOptimizations(q) {
        // Disable backdrop-filter blur when quality < 0.6
        const panels = document.querySelectorAll('.panel, .operator-panel, #intel-filter-panel, #carousel-panel');
        panels.forEach(panel => {
            if (q < 0.6) {
                // Replace blur with solid background
                panel.style.backdropFilter = 'none';
                panel.style.webkitBackdropFilter = 'none';
                panel.style.backgroundColor = 'rgba(0, 20, 20, 0.85)';
            } else {
                // Restore blur
                panel.style.backdropFilter = '';
                panel.style.webkitBackdropFilter = '';
                panel.style.backgroundColor = '';
            }
        });
        
        // Reduce shadows when quality < 0.5
        if (q < 0.5) {
            document.documentElement.style.setProperty('--panel-shadow', 'none');
        } else {
            document.documentElement.style.setProperty('--panel-shadow', '0 0 20px rgba(0, 255, 255, 0.3)');
        }
        
        // Reduce grain/scanlines opacity based on quality
        const grain = document.querySelector('.grain');
        if (grain) {
            grain.style.opacity = q > 0.5 ? '0.03' : '0';
        }
    }
    
    adjustCanvasResolution(q) {
        const mainCanvas = document.getElementById('main-canvas');
        if (!mainCanvas) return;
        
        const container = mainCanvas.parentElement;
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // Render at reduced resolution but keep CSS size at 100%
        mainCanvas.width = Math.floor(width * q);
        mainCanvas.height = Math.floor(height * q);
        
        // CSS keeps it full size (will scale up)
        mainCanvas.style.width = '100%';
        mainCanvas.style.height = '100%';
    }
    
    // Adjust detection FPS based on average FPS
    adjustDetectionFPS() {
        if (!this.visionSystem) return;
        
        const avgFPS = this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length;
        
        // If FPS is low, reduce detection frequency
        if (avgFPS < 25 && this.qualityLevel < 0.6) {
            this.visionSystem.setDetectionMode('performance'); // 20 FPS
        } else if (avgFPS < 35 && this.qualityLevel < 0.8) {
            this.visionSystem.setDetectionMode('balanced'); // 30 FPS
        } else {
            this.visionSystem.setDetectionMode('quality'); // 60 FPS
        }
    }
    
    getSettings() {
        return this.qualitySettings;
    }
    
    getLevel() {
        return this.qualityLevel;
    }
}

// ========== MOBILE UI LAYOUT MANAGER ==========
// Enhanced layout manager with mobile-specific handling
class PanelLayoutManager {
    constructor() {
        // Panel configuration: ID, dock position, priority (higher = stays in place)
        this.panelConfigs = [
            { id: 'sys-panel', dock: 'top-left', priority: 100, baseTop: 20, baseLeft: 20 },
            { id: 'mode-panel', dock: 'top-right', priority: 100, baseTop: 20, baseRight: 20 },
            { id: 'data-panel', dock: 'bottom-left', priority: 90, baseBottom: 20, baseLeft: 20 },
            { id: 'latency-panel', dock: 'bottom-right', priority: 90, baseBottom: 20, baseRight: 20 },
            { id: 'intel-filter-panel', dock: 'top-left', priority: 60, baseTop: 20, baseLeft: 20 },
            { id: 'carousel-panel', dock: 'center', priority: 50, baseTop: 200, baseLeft: 300 },
            { id: 'tracking-quality-meter', dock: 'top-right', priority: 10, baseTop: 70, baseRight: 15 },
            { id: 'more-modes-panel', dock: 'bottom-center', priority: 80, baseBottom: 90 },
            // Mobile-specific elements
            { id: 'toggle-hud-btn', dock: 'top-right', priority: 95, baseTop: 10, baseRight: 10 },
            { id: 'telemetry-sidebar', dock: 'bottom-left', priority: 85, baseBottom: 85, baseLeft: 10 },
            { id: 'touch-bar-toggle', dock: 'bottom-right', priority: 95, baseBottom: 10, baseRight: 10 }
        ];
        
        this.collisionMargin = 8;  // Smaller margin for mobile (8px grid)
        this.moveIncrement = 8;    // Move in 8px increments
        this.isMobile = false;
    }
    
    // Check if we're in mobile mode
    checkMobileMode() {
        const wasMobile = this.isMobile;
        this.isMobile = window.innerWidth <= 768 || document.body.classList.contains('mobile-view');
        
        // If mobile state changed, update collision margin
        if (wasMobile !== this.isMobile) {
            this.collisionMargin = this.isMobile ? 8 : 12;
            this.moveIncrement = this.isMobile ? 8 : 12;
        }
        
        return this.isMobile;
    }
    
    // Get safe area values from CSS variables
    getSafeAreas() {
        const style = getComputedStyle(document.documentElement);
        return {
            top: parseInt(style.getPropertyValue('--safe-top')) || 10,
            bottom: parseInt(style.getPropertyValue('--safe-bottom')) || 10,
            left: parseInt(style.getPropertyValue('--safe-left')) || 10,
            right: parseInt(style.getPropertyValue('--safe-right')) || 10
        };
    }
    
    // Apply base dock position to a panel
    applyDockPosition(el, config, safeAreas) {
        if (!el) return;
        
        const dock = config.dock;
        const isMobile = this.isMobile;
        
        // Reset all positioning
        el.style.top = '';
        el.style.bottom = '';
        el.style.left = '';
        el.style.right = '';
        el.style.transform = '';
        
        // Mobile-specific adjustments
        if (isMobile && config.id === 'mode-panel') {
            // mode-panel uses CSS variables for safe areas
            el.style.top = `var(--safe-top)`;
            el.style.right = `var(--safe-right)`;
            return;
        }
        
        // Apply base position based on dock
        switch (dock) {
            case 'top-left':
                el.style.top = `${(config.baseTop || 20) + safeAreas.top}px`;
                el.style.left = `${(config.baseLeft || 20) + safeAreas.left}px`;
                break;
            case 'top-right':
                el.style.top = `${(config.baseTop || 20) + safeAreas.top}px`;
                el.style.right = `${(config.baseRight || 20) + safeAreas.right}px`;
                break;
            case 'bottom-left':
                el.style.bottom = `${(config.baseBottom || 20) + safeAreas.bottom}px`;
                el.style.left = `${(config.baseLeft || 20) + safeAreas.left}px`;
                break;
            case 'bottom-right':
                el.style.bottom = `${(config.baseBottom || 20) + safeAreas.bottom}px`;
                el.style.right = `${(config.baseRight || 20) + safeAreas.right}px`;
                break;
            case 'bottom-center':
                el.style.bottom = `${(config.baseBottom || 90) + safeAreas.bottom}px`;
                el.style.left = '50%';
                el.style.transform = 'translateX(-50%)';
                break;
            case 'center':
                el.style.top = `${config.baseTop || 200}px`;
                el.style.left = `${config.baseLeft || 300}px`;
                break;
        }
    }
    
    // Check if two rectangles intersect
    rectsIntersect(rect1, rect2, margin = 0) {
        return !(
            rect1.right + margin < rect2.left ||
            rect1.left - margin > rect2.right ||
            rect1.bottom + margin < rect2.top ||
            rect1.top - margin > rect2.bottom
        );
    }
    
    // Get visible panels with their rects
    getVisiblePanels() {
        const visible = [];
        
        for (const config of this.panelConfigs) {
            const el = document.getElementById(config.id);
            if (!el) continue;
            
            const style = window.getComputedStyle(el);
            const isVisible = style.display !== 'none' && 
                            parseFloat(style.opacity || 1) > 0 &&
                            el.offsetParent !== null;
            
            if (isVisible) {
                visible.push({
                    el,
                    config,
                    rect: el.getBoundingClientRect()
                });
            }
        }
        
        return visible;
    }
    
    // Resolve overlaps between panels
    resolveOverlaps(safeAreas) {
        const panels = this.getVisiblePanels();
        
        // Sort by priority (highest first - these stay in place)
        panels.sort((a, b) => b.config.priority - a.config.priority);
        
        // Mobile-specific rules
        if (this.isMobile) {
            this.applyMobileRules(panels, safeAreas);
        }
        
        // Special rule: tracking-quality-meter alignment with mode-panel
        const trackingMeter = panels.find(p => p.config.id === 'tracking-quality-meter');
        const modePanel = panels.find(p => p.config.id === 'mode-panel');
        
        if (trackingMeter && modePanel) {
            const modePanelRect = modePanel.el.getBoundingClientRect();
            trackingMeter.el.style.top = `${modePanelRect.bottom + 10}px`;
            trackingMeter.el.style.right = modePanel.el.style.right || `${window.innerWidth - modePanelRect.right}px`;
            // Update rect after repositioning
            trackingMeter.rect = trackingMeter.el.getBoundingClientRect();
        }
        
        // Check each panel against higher priority panels
        for (let i = 1; i < panels.length; i++) {
            const currentPanel = panels[i];
            let moved = false;
            let attempts = 0;
            const maxAttempts = 50;
            
            while (attempts < maxAttempts) {
                let hasCollision = false;
                
                // Check against all higher priority panels
                for (let j = 0; j < i; j++) {
                    const otherPanel = panels[j];
                    
                    if (this.rectsIntersect(currentPanel.rect, otherPanel.rect, this.collisionMargin)) {
                        hasCollision = true;
                        
                        // Try to move down first
                        const currentTop = parseInt(currentPanel.el.style.top) || currentPanel.rect.top;
                        const maxTop = window.innerHeight - safeAreas.bottom - currentPanel.rect.height;
                        
                        if (currentTop + this.moveIncrement < maxTop) {
                            // Move down
                            currentPanel.el.style.top = `${currentTop + this.moveIncrement}px`;
                            currentPanel.el.style.bottom = '';
                            moved = true;
                        } else {
                            // No space down, try moving left
                            const currentLeft = parseInt(currentPanel.el.style.left);
                            const currentRight = parseInt(currentPanel.el.style.right);
                            
                            if (!isNaN(currentLeft)) {
                                const newLeft = currentLeft - this.moveIncrement;
                                if (newLeft >= safeAreas.left) {
                                    currentPanel.el.style.left = `${newLeft}px`;
                                    moved = true;
                                }
                            } else if (!isNaN(currentRight)) {
                                const newRight = currentRight + this.moveIncrement;
                                const maxRight = window.innerWidth - safeAreas.right - currentPanel.rect.width;
                                if (newRight < maxRight) {
                                    currentPanel.el.style.right = `${newRight}px`;
                                    moved = true;
                                }
                            }
                        }
                        
                        // Update rect after move
                        currentPanel.rect = currentPanel.el.getBoundingClientRect();
                        break;
                    }
                }
                
                if (!hasCollision) break;
                attempts++;
            }
            
            if (attempts >= maxAttempts) {
                console.warn(`PanelLayout: Could not resolve collision for ${currentPanel.config.id}`);
            }
        }
    }
    
    // Enforce sacred zones - ensure panels don't enter no-go areas (especially mobile touch bar)
    enforceSacredZones(panels, safeAreas) {
        if (!this.isMobile) {
            // Sacred zones are mainly for mobile devices
            return;
        }
        
        // Define sacred zones (no-go areas)
        const touchBar = document.getElementById('mobile-touch-bar');
        const topBar = document.getElementById('mobile-top-bar');
        
        // Sacred zone 1: Touch bar area (bottom of screen)
        if (touchBar) {
            const touchBarRect = touchBar.getBoundingClientRect();
            const sacredBottom = {
                top: touchBarRect.top - safeAreas.bottom,
                bottom: window.innerHeight,
                left: 0,
                right: window.innerWidth
            };
            
            // Move any panel that intersects with touch bar area
            for (const panel of panels) {
                // Skip touch bar itself and panels that should be in bottom dock
                if (panel.config.id === 'mobile-touch-bar' || 
                    panel.config.id === 'telemetry-sidebar' ||
                    panel.config.dock === 'bottom-left' ||
                    panel.config.dock === 'bottom-right' ||
                    panel.config.dock === 'bottom-center') {
                    continue;
                }
                
                // Check if panel intersects with sacred bottom zone
                if (this.rectsIntersect(panel.rect, sacredBottom, 0)) {
                    // Move panel up to avoid touch bar
                    const currentTop = parseInt(panel.el.style.top) || panel.rect.top;
                    const currentBottom = parseInt(panel.el.style.bottom);
                    
                    if (!isNaN(currentBottom)) {
                        // Panel uses bottom positioning
                        const newBottom = window.innerHeight - touchBarRect.top + safeAreas.bottom + 10;
                        panel.el.style.bottom = `${newBottom}px`;
                        panel.el.style.top = '';
                    } else {
                        // Panel uses top positioning - ensure it's above sacred zone
                        const minTop = sacredBottom.top - panel.rect.height - 10;
                        if (currentTop > minTop) {
                            panel.el.style.top = `${Math.max(safeAreas.top, minTop)}px`;
                        }
                    }
                    
                    // Update rect after repositioning
                    panel.rect = panel.el.getBoundingClientRect();
                }
            }
        }
        
        // Sacred zone 2: Top bar area (for notches/status bars)
        if (topBar) {
            const topBarRect = topBar.getBoundingClientRect();
            const sacredTop = {
                top: 0,
                bottom: topBarRect.bottom + safeAreas.top,
                left: 0,
                right: window.innerWidth
            };
            
            // Move any panel that intersects with top bar area
            for (const panel of panels) {
                // Skip top bar itself and panels that should be in top dock
                if (panel.config.id === 'mobile-top-bar' ||
                    panel.config.dock === 'top-left' ||
                    panel.config.dock === 'top-right') {
                    continue;
                }
                
                // Check if panel intersects with sacred top zone
                if (this.rectsIntersect(panel.rect, sacredTop, 0)) {
                    // Move panel down to avoid top bar
                    const currentTop = parseInt(panel.el.style.top);
                    const currentBottom = parseInt(panel.el.style.bottom) || window.innerHeight - panel.rect.top;
                    
                    if (!isNaN(currentTop)) {
                        // Panel uses top positioning
                        const newTop = topBarRect.bottom + safeAreas.top + 10;
                        panel.el.style.top = `${newTop}px`;
                        panel.el.style.bottom = '';
                    } else {
                        // Panel uses bottom positioning - ensure it's below sacred zone
                        const maxBottom = window.innerHeight - sacredTop.bottom - 10;
                        if (currentBottom < maxBottom) {
                            panel.el.style.bottom = `${Math.max(safeAreas.bottom, maxBottom)}px`;
                        }
                    }
                    
                    // Update rect after repositioning
                    panel.rect = panel.el.getBoundingClientRect();
                }
            }
        }
    }
    
    // Update z-index for all panels (coherent layering)
    updateZIndex() {
        const zIndexMap = {
            'sys-panel': 30,
            'mode-panel': 30,
            'data-panel': 30,
            'latency-panel': 30,
            'intel-filter-panel': 45,
            'carousel-panel': 40,
            'tracking-quality-meter': 50,
            'more-modes-panel': 99,
            'mobile-top-bar': 100,
            'mobile-touch-bar': 100
        };
        
        for (const [id, zIndex] of Object.entries(zIndexMap)) {
            const el = document.getElementById(id);
            if (el) {
                el.style.zIndex = zIndex;
            }
        }
    }
    
    // Mobile-specific collision rules
    applyMobileRules(panels, safeAreas) {
        const modePanel = panels.find(p => p.config.id === 'mode-panel');
        const toggleHudBtn = panels.find(p => p.config.id === 'toggle-hud-btn');
        const telemetry = panels.find(p => p.config.id === 'telemetry-sidebar');
        const moreModesPanel = panels.find(p => p.config.id === 'more-modes-panel');
        const touchBar = panels.find(p => p.config.id === 'mobile-touch-bar');
        
        // Rule 1: mobile-touch-bar always at bottom (never move)
        // Already handled by high priority and bottom dock
        
        // Rule 2: more-modes-panel always above touch bar
        if (moreModesPanel && touchBar) {
            const touchBarRect = touchBar.el.getBoundingClientRect();
            moreModesPanel.el.style.bottom = `${window.innerHeight - touchBarRect.top + 10}px`;
            moreModesPanel.rect = moreModesPanel.el.getBoundingClientRect();
        }
        
        // Rule 3: If mode-panel collides with toggle-hud-btn, move toggle to left
        if (modePanel && toggleHudBtn) {
            if (this.rectsIntersect(modePanel.rect, toggleHudBtn.rect, this.collisionMargin)) {
                // Move toggle-hud-btn to left side
                toggleHudBtn.el.style.right = '';
                toggleHudBtn.el.style.left = `${safeAreas.left + 10}px`;
                toggleHudBtn.rect = toggleHudBtn.el.getBoundingClientRect();
            }
        }
        
        // Rule 4: Hide telemetry when more-modes-panel is open
        if (telemetry && moreModesPanel) {
            const isMoreModesOpen = moreModesPanel.el.classList.contains('open');
            if (isMoreModesOpen) {
                telemetry.el.style.opacity = '0';
                telemetry.el.style.pointerEvents = 'none';
            } else {
                telemetry.el.style.opacity = '';
                telemetry.el.style.pointerEvents = '';
            }
        }
    }
    
    // Main update function - call this whenever layout needs recalculation
    update() {
        // Check mobile mode first
        this.checkMobileMode();
        
        const safeAreas = this.getSafeAreas();
        
        // Step 1: Apply base dock positions
        for (const config of this.panelConfigs) {
            const el = document.getElementById(config.id);
            if (el) {
                this.applyDockPosition(el, config, safeAreas);
            }
        }
        
        // Step 2: Update z-index (using CSS tokens)
        this.updateZIndex();
        
        // Step 3: Enforce sacred zones (no-go areas for mobile)
        requestAnimationFrame(() => {
            const panels = this.panelConfigs.map(config => {
                const el = document.getElementById(config.id);
                if (!el) return null;
                return {
                    el,
                    config,
                    rect: el.getBoundingClientRect()
                };
            }).filter(p => p !== null);
            
            this.enforceSacredZones(panels, safeAreas);
            
            // Step 4: Resolve overlaps (after sacred zones are enforced)
            this.resolveOverlaps(safeAreas);
            
            // Step 5: Apply mobile-specific rules
            if (this.isMobile) {
                this.applyMobileRules(panels, safeAreas);
            }
        });
    }
}

// Global instances (initialized by TacticalOS)
let globalLandmarkSmoother = null;
let handGracePeriod = null;
let trackingQualityMeter = null;
let dynamicQualityScaler = null;
let panelLayoutManager = null;

// ========== FLUID SIMULATION SYSTEM ==========
class FluidSystem {
    constructor(canvas) {
        this.canvas = canvas;
        // Low res grid for physics, scaled up for display
        this.resolution = 128;
        this.size = this.resolution + 2;
        this.dt = 0.15;
        this.diff = 0.0001;
        this.visc = 0.0001;
        
        // Arrays for density and velocity (current and previous)
        const arraySize = this.size * this.size;
        this.s = new Float32Array(arraySize); // Density
        this.density = new Float32Array(arraySize);
        
        this.Vx = new Float32Array(arraySize);
        this.Vy = new Float32Array(arraySize);
        this.Vx0 = new Float32Array(arraySize);
        this.Vy0 = new Float32Array(arraySize);
        
        // Offscreen canvas for rendering the fluid
        this.fluidCanvas = document.createElement('canvas');
        this.fluidCanvas.width = this.resolution;
        this.fluidCanvas.height = this.resolution;
        this.fluidCtx = this.fluidCanvas.getContext('2d');
        this.imageData = this.fluidCtx.createImageData(this.resolution, this.resolution);
        
        this.iter = 4; // Solver iterations
        
        // Colors
        this.colorShift = 0;
    }

    // --- SOLVER CORE METHODS ---
    IX(x, y) {
        return x + y * this.size;
    }

    addDensity(x, y, amount) {
        const index = this.IX(x, y);
        this.density[index] += amount;
        // Clamp
        if (this.density[index] > 255) this.density[index] = 255;
    }

    addVelocity(x, y, amountX, amountY) {
        const index = this.IX(x, y);
        this.Vx[index] += amountX;
        this.Vy[index] += amountY;
    }

    diffuse(b, x, x0, diff, dt) {
        const a = dt * diff * (this.resolution - 2) * (this.resolution - 2);
        this.lin_solve(b, x, x0, a, 1 + 6 * a);
    }

    lin_solve(b, x, x0, a, c) {
        const invC = 1.0 / c;
        for (let k = 0; k < this.iter; k++) {
            for (let j = 1; j < this.size - 1; j++) {
                for (let i = 1; i < this.size - 1; i++) {
                    x[this.IX(i, j)] =
                        (x0[this.IX(i, j)] +
                            a * (x[this.IX(i + 1, j)] +
                                x[this.IX(i - 1, j)] +
                                x[this.IX(i, j + 1)] +
                                x[this.IX(i, j - 1)]
                            )) * invC;
                }
            }
            this.set_bnd(b, x);
        }
    }

    project(velocX, velocY, p, div) {
        for (let j = 1; j < this.size - 1; j++) {
            for (let i = 1; i < this.size - 1; i++) {
                div[this.IX(i, j)] = -0.5 * (
                    velocX[this.IX(i + 1, j)] - velocX[this.IX(i - 1, j)] +
                    velocY[this.IX(i, j + 1)] - velocY[this.IX(i, j - 1)]
                ) / this.resolution;
                p[this.IX(i, j)] = 0;
            }
        }
        this.set_bnd(0, div);
        this.set_bnd(0, p);
        this.lin_solve(0, p, div, 1, 6);

        for (let j = 1; j < this.size - 1; j++) {
            for (let i = 1; i < this.size - 1; i++) {
                velocX[this.IX(i, j)] -= 0.5 * (p[this.IX(i + 1, j)] - p[this.IX(i - 1, j)]) * this.resolution;
                velocY[this.IX(i, j)] -= 0.5 * (p[this.IX(i, j + 1)] - p[this.IX(i, j - 1)]) * this.resolution;
            }
        }
        this.set_bnd(1, velocX);
        this.set_bnd(2, velocY);
    }

    advect(b, d, d0, velocX, velocY, dt) {
        let i0, i1, j0, j1;
        let x, y, s0, t0, s1, t1;
        let dt0 = dt * (this.resolution - 2);
        let float_N = this.resolution - 2;

        for (let j = 1; j < this.size - 1; j++) {
            for (let i = 1; i < this.size - 1; i++) {
                x = i - dt0 * velocX[this.IX(i, j)];
                y = j - dt0 * velocY[this.IX(i, j)];

                if (x < 0.5) x = 0.5;
                if (x > float_N + 0.5) x = float_N + 0.5;
                i0 = Math.floor(x);
                i1 = i0 + 1;
                
                if (y < 0.5) y = 0.5;
                if (y > float_N + 0.5) y = float_N + 0.5;
                j0 = Math.floor(y);
                j1 = j0 + 1;

                s1 = x - i0;
                s0 = 1.0 - s1;
                t1 = y - j0;
                t0 = 1.0 - t1;

                const i0j0 = this.IX(i0, j0);
                const i0j1 = this.IX(i0, j1);
                const i1j0 = this.IX(i1, j0);
                const i1j1 = this.IX(i1, j1);

                d[this.IX(i, j)] =
                    s0 * (t0 * d0[i0j0] + t1 * d0[i0j1]) +
                    s1 * (t0 * d0[i1j0] + t1 * d0[i1j1]);
            }
        }
        this.set_bnd(b, d);
    }

    set_bnd(b, x) {
        for (let i = 1; i < this.size - 1; i++) {
            x[this.IX(i, 0)] = b === 2 ? -x[this.IX(i, 1)] : x[this.IX(i, 1)];
            x[this.IX(i, this.size - 1)] = b === 2 ? -x[this.IX(i, this.size - 2)] : x[this.IX(i, this.size - 2)];
        }
        for (let j = 1; j < this.size - 1; j++) {
            x[this.IX(0, j)] = b === 1 ? -x[this.IX(1, j)] : x[this.IX(1, j)];
            x[this.IX(this.size - 1, j)] = b === 1 ? -x[this.IX(this.size - 2, j)] : x[this.IX(this.size - 2, j)];
        }
        
        x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]);
        x[this.IX(0, this.size - 1)] = 0.5 * (x[this.IX(1, this.size - 1)] + x[this.IX(0, this.size - 2)]);
        x[this.IX(this.size - 1, 0)] = 0.5 * (x[this.IX(this.size - 2, 0)] + x[this.IX(this.size - 1, 1)]);
        x[this.IX(this.size - 1, this.size - 1)] = 0.5 * (x[this.IX(this.size - 2, this.size - 1)] + x[this.IX(this.size - 1, this.size - 2)]);
    }

    // --- INTERACTION & UPDATE ---
    update(hands) {
        this.colorShift += 0.5;
        
        // Physics Step
        this.diffuse(1, this.Vx0, this.Vx, this.visc, this.dt);
        this.diffuse(2, this.Vy0, this.Vy, this.visc, this.dt);

        this.project(this.Vx0, this.Vy0, this.Vx, this.Vy);

        this.advect(1, this.Vx, this.Vx0, this.Vx0, this.Vy0, this.dt);
        this.advect(2, this.Vy, this.Vy0, this.Vx0, this.Vy0, this.dt);

        this.project(this.Vx, this.Vy, this.Vx0, this.Vy0);

        this.diffuse(0, this.s, this.density, this.diff, this.dt);
        this.advect(0, this.density, this.s, this.Vx, this.Vy, this.dt);

        // Fade out - slower fade (0.99 -> 0.995) for more persistence
        for (let i = 0; i < this.density.length; i++) {
            this.density[i] *= 0.995; 
        }

        // Hand Interactions
        if (hands && hands.landmarks) {
            this.handleInput(hands);
        }
    }

    handleInput(hands) {
        // We need previous hand positions to calculate velocity
        // Storing them on the fluid system instance for simplicity
        if (!this.lastHandPositions) this.lastHandPositions = [];

        hands.landmarks.forEach((hand, i) => {
            const indexTip = hand[8]; // Index tip
            const thumbTip = hand[4]; // Thumb tip
            const wrist = hand[0];
            
            if (!indexTip) return;

            // Map coordinates (0-1) to Grid Size
            const x = Math.floor((1 - indexTip.x) * this.resolution); 
            const y = Math.floor(indexTip.y * this.resolution);
            
            if (x < 1 || x >= this.resolution - 1 || y < 1 || y >= this.resolution - 1) return;

            // 1. MOVEMENT -> Velocity
            if (this.lastHandPositions[i]) {
                const last = this.lastHandPositions[i];
                // Calculate delta (velocity) - Increased multiplier (5.0 -> 15.0) for more response
                const amtX = (x - last.x) * 15.0; 
                const amtY = (y - last.y) * 15.0;
                
                this.addVelocity(x, y, amtX, amtY);
                // Also add MORE density trail (20 -> 50)
                this.addDensity(x, y, Math.sqrt(amtX*amtX + amtY*amtY) * 50);
            }

            // 2. PINCH -> Explosion of Color
            const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
            if (pinchDist < 0.05) {
                // Inject heavy density in a radius (150 -> 255 max)
                for(let py = -2; py <= 2; py++) {
                    for(let px = -2; px <= 2; px++) {
                        this.addDensity(x + px, y + py, 255);
                    }
                }
            }

            this.lastHandPositions[i] = { x, y };
        });

        // 3. CLAP -> Shockwave
        if (hands.landmarks.length >= 2) {
            const h1 = hands.landmarks[0][9]; // Middle knuckle
            const h2 = hands.landmarks[1][9];
            if (h1 && h2) {
                const dist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                // Simple state machine for clap
                if (dist < 0.1 && !this.wasClapping) {
                    this.wasClapping = true;
                    // Trigger Shockwave at center
                    const cx = Math.floor((1 - (h1.x + h2.x)/2) * this.resolution);
                    const cy = Math.floor(((h1.y + h2.y)/2) * this.resolution);
                    
                    // Radial impulse - Increased force (500 -> 1000)
                    for(let angle=0; angle<Math.PI*2; angle+=0.1) {
                        const vx = Math.cos(angle) * 1000;
                        const vy = Math.sin(angle) * 1000;
                        this.addVelocity(cx, cy, vx, vy);
                    }
                } else if (dist > 0.15) {
                    this.wasClapping = false;
                }
            }
        }
    }

    draw(ctx) {
        const data = this.imageData.data;
        
        for (let i = 0; i < this.size * this.size; i++) {
            const density = this.density[i];
            const pixelIndex = i * 4;
            
            // Lower threshold (1 -> 0.1) to show faint smoke
            if (density > 0.1) {
                // Sine wave coloring
                const r = density * (Math.sin(this.colorShift * 0.01 + i * 0.001) * 0.5 + 0.5); 
                const g = density; // Green channel high -> Cyan
                const b = density * 1.5; // Boost Blue for stronger neon
                
                // Magenta tint logic if pinch active
                if (density > 200) {
                    data[pixelIndex] = 255;     // R
                    data[pixelIndex + 1] = 0;   // G
                    data[pixelIndex + 2] = 255; // B
                } else {
                    data[pixelIndex] = r;
                    data[pixelIndex + 1] = g;
                    data[pixelIndex + 2] = b;
                }
                // Boost Alpha
                data[pixelIndex + 3] = Math.min(255, density * 2); 
            } else {
                data[pixelIndex + 3] = 0;
            }
        }
        
        this.fluidCtx.putImageData(this.imageData, 0, 0);
        
        // Scale up to main canvas
        ctx.save();
        // Use 'lighter' (additive) instead of 'screen' for brighter overlap
        ctx.globalCompositeOperation = 'lighter'; 
        // Increased contrast and brightness
        ctx.filter = 'blur(6px) contrast(2.0) brightness(1.2)'; 
        ctx.drawImage(this.fluidCanvas, 0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.restore();
    }
}

// --- APP CONTROLLER ---
class TacticalOS {
    constructor() {
        this.video = document.getElementById('video-feed');
        this.vision = new VisionSystem();
        this.engine = new RenderEngine();
        this.fluidSystem = new FluidSystem(this.engine.canvas);
        
        // Initialize global systems
        globalLandmarkSmoother = new GlobalLandmarkSmoother();
        handGracePeriod = new HandGracePeriod();
        trackingQualityMeter = new TrackingQualityMeter();
        dynamicQualityScaler = new DynamicQualityScaler(this.engine);
        panelLayoutManager = new PanelLayoutManager();
        
        // Store references
        this.smoother = globalLandmarkSmoother;
        this.gracePeriod = handGracePeriod;
        this.qualityMeter = trackingQualityMeter;
        this.qualityScaler = dynamicQualityScaler;
        this.layoutManager = panelLayoutManager;
        
        // Connect vision system to quality scaler
        this.qualityScaler.visionSystem = this.vision;
        
        // Current visual profile
        this.visualProfile = getVisualProfile('HUD');
        
        // Initial layout update after DOM is ready
        setTimeout(() => {
            this.layoutManager.update();
        }, 100);
        
        // Update layout on window resize
        window.addEventListener('resize', () => {
            if (this.layoutManager) {
                this.layoutManager.update();
            }
        });

        // Initialize systems
        this.draggableSystem = new DraggableSystem();
        this.carouselSystem = new CarouselSystem();

        this.mode = 'HUD'; // Default
        // Set initial data-mode attribute
        document.body.setAttribute('data-mode', 'HUD');
        this.isRunning = false;

        // Independent toggles (work in any mode)
        this.cubeActive = false;

        // Background control state
        this.backgroundSettings = {
            opacity: 0,     // 0-90%
            blur: 0,        // 0-20px
            vignette: false,
            grain: false,
            scanlines: false
        };

        // Censorship state
        this.isCensored = false;
        this.censorshipTimer = null;
        
        // INTEL Filter System
        this.intelFilters = {
            person: true,
            vehicle: true,
            electronics: true,
            furniture: true,
            animals: true,
            food: true,
            sports: true,
            accessories: true,
            kitchen: true,
            other: true
        };
        
        // Category mapping for COCO-SSD classes
        this.categoryMapping = {
            // Person
            person: 'person',
            // Vehicles
            bicycle: 'vehicle', car: 'vehicle', motorcycle: 'vehicle', airplane: 'vehicle',
            bus: 'vehicle', train: 'vehicle', truck: 'vehicle', boat: 'vehicle',
            // Electronics
            'tv': 'electronics', 'tvmonitor': 'electronics', laptop: 'electronics', 
            mouse: 'electronics', remote: 'electronics', keyboard: 'electronics',
            'cell phone': 'electronics', cellphone: 'electronics',
            // Furniture
            chair: 'furniture', couch: 'furniture', sofa: 'furniture', 
            'potted plant': 'furniture', bed: 'furniture', 'dining table': 'furniture',
            toilet: 'furniture', desk: 'furniture',
            // Animals
            bird: 'animals', cat: 'animals', dog: 'animals', horse: 'animals',
            sheep: 'animals', cow: 'animals', elephant: 'animals', bear: 'animals',
            zebra: 'animals', giraffe: 'animals',
            // Food
            banana: 'food', apple: 'food', sandwich: 'food', orange: 'food',
            broccoli: 'food', carrot: 'food', 'hot dog': 'food', pizza: 'food',
            donut: 'food', cake: 'food',
            // Sports
            frisbee: 'sports', skis: 'sports', snowboard: 'sports', 'sports ball': 'sports',
            kite: 'sports', 'baseball bat': 'sports', 'baseball glove': 'sports',
            skateboard: 'sports', surfboard: 'sports', 'tennis racket': 'sports',
            // Accessories
            backpack: 'accessories', umbrella: 'accessories', handbag: 'accessories',
            tie: 'accessories', suitcase: 'accessories', 
            // Kitchen
            bottle: 'kitchen', 'wine glass': 'kitchen', cup: 'kitchen', fork: 'kitchen',
            knife: 'kitchen', spoon: 'kitchen', bowl: 'kitchen', microwave: 'kitchen',
            oven: 'kitchen', toaster: 'kitchen', sink: 'kitchen', refrigerator: 'kitchen',
            // Other
            book: 'other', clock: 'other', vase: 'other', scissors: 'other',
            'teddy bear': 'other', 'hair drier': 'other', toothbrush: 'other',
            'traffic light': 'other', 'fire hydrant': 'other', 'stop sign': 'other',
            'parking meter': 'other', bench: 'other'
        };
        
        this.filterPanelCollapsed = false;
        this.detectedCounts = {}; // Track counts per category
        
        // Performance Stats
        this.lastFrameTime = performance.now();
        this.fps = 0;
        this.fpsHistory = []; // For averaging
        this.fpsHistorySize = 30; // Average over 30 frames
        this.frameCount = 0;
        this.lastFpsUpdate = 0;
        this.lastStatsUpdate = 0;
        this.minFps = Infinity;
        this.maxFps = 0;

        this.bindInput();
        this.initPanelToggle();
        this.start();
    }

    bindInput() {
        document.addEventListener('keydown', (e) => {
            const key = e.key.toUpperCase();
            
            // Mode map (H removed - cube is independent toggle)
            const map = {
                'U': 'HUD',
                'L': 'DRAW',
                'X': 'XRAY',
                'K': 'INTEL',
                'V': 'MATRIX',
                'T': 'VOID',
                'P': 'WIREFRAME',
                'C': 'DRONE',
                'B': 'FACE',
                'O': 'OPERATOR',
                'R': 'TOUCH',
                'J': 'CAROUSEL',
                'S': 'SANDTABLE',
                'Z': 'FLUID'
            };
            
            // H key toggles cube independently (works in any mode)
            if(key === 'H') {
                this.cubeActive = !this.cubeActive;
                this.engine.cubeGroup.visible = this.cubeActive;
                
                // Update body class for CSS selectors
                if (this.cubeActive) {
                    document.body.classList.add('cube-active');
                } else {
                    document.body.classList.remove('cube-active');
                }

                // Reset cube position and scale when activating
                if (this.cubeActive) {
                    this.engine.cubeBasePosition = { x: 0, y: 0, z: 0 };
                    this.engine.cubeBaseScale = 1.0;
                    this.engine.lastPinchDistance = null;
                    this.engine.cubeGroup.position.set(0, 0, 0);
                    this.engine.cubeGroup.scale.set(1, 1, 1);
                }

                // If deactivating, render empty scene to clear the cube from view
                if (!this.cubeActive) {
                    this.engine.renderer3D.render(this.engine.scene, this.engine.camera3D);
                }

                log(this.cubeActive ? 'CUBE: ACTIVATED' : 'CUBE: DEACTIVATED');

                // Glitch effect
                document.body.classList.add('glitch-active');
                setTimeout(() => document.body.classList.remove('glitch-active'), 200);
            }
            
            if(map[key]) {
                // Toggle: if same mode pressed, go back to HUD (keeps hand tracking)
                if(this.mode === map[key]) {
                    this.setMode('HUD');
                } else {
                    this.setMode(map[key]);
                }
            }
            
            // Clear Draw Path when entering DRAW mode
            if(key === 'L' && this.mode === 'DRAW') this.engine.drawPath = [];
            
            // Fullscreen toggle with F key
            if(key === 'F') this.toggleFullscreen();
            
            // Mobile view toggle with M key
            if(key === 'M') this.toggleMobileView();

            // Sandtable brush controls (only when in SANDTABLE mode)
            if(this.mode === 'SANDTABLE') {
                if(key === '[') {
                    // Decrease brush size
                    this.sandtableState.brushSizeMultiplier = Math.max(0.3, this.sandtableState.brushSizeMultiplier - 0.1);
                    log(`BRUSH SIZE: ${(this.sandtableState.brushSizeMultiplier * 100).toFixed(0)}%`);
                }
                if(key === ']') {
                    // Increase brush size
                    this.sandtableState.brushSizeMultiplier = Math.min(3.0, this.sandtableState.brushSizeMultiplier + 0.1);
                    log(`BRUSH SIZE: ${(this.sandtableState.brushSizeMultiplier * 100).toFixed(0)}%`);
                }
                if(key === 'R') {
                    // Reset terrain
                    if(this.engine.resetTerrainDeformations) {
                        this.engine.resetTerrainDeformations();
                        log('TERRAIN RESET');
                    }
                }
            }
            
            // Q key toggles Tracking Quality Meter
            if(key === 'Q') {
                if (this.qualityMeter) {
                    this.qualityMeter.toggle();
                    log(`TRACKING QUALITY: ${this.qualityMeter.isVisible ? 'VISIBLE' : 'HIDDEN'}`);
                    
                    // Update panel layout when toggling quality meter
                    if (this.layoutManager) {
                        setTimeout(() => this.layoutManager.update(), 50);
                    }
                }
            }
            
            // P key toggles Hand Particle System & Map
            if(key === 'P') {
                if (this.engine) {
                    this.engine.toggleHandParticles();
                }
            }
        });

        // Fullscreen button click
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        if(fullscreenBtn) {
            fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
        }

        // Mobile button click
        const mobileBtn = document.getElementById('mobile-btn');
        if(mobileBtn) {
            mobileBtn.addEventListener('click', () => this.toggleMobileView());
        }

        // Update button state on fullscreen change
        document.addEventListener('fullscreenchange', () => this.updateFullscreenButton());

        // Initialize background controls
        this.initBackgroundControls();
        
        // Initialize mobile UI enhancements
        this.initMobileUIEnhancements();
    }
    
    initMobileUIEnhancements() {
        // Mode panel tap to expand on small screens
        const modePanel = document.getElementById('mode-panel');
        if (modePanel) {
            modePanel.addEventListener('click', () => {
                if (window.innerWidth <= 480) {
                    modePanel.classList.toggle('expanded');
                }
            });
        }
        
        // Telemetry collapse when more-modes-panel opens
        const moreModesPanel = document.getElementById('more-modes-panel');
        const telemetry = document.getElementById('telemetry-sidebar');
        
        if (moreModesPanel && telemetry) {
            // Create a MutationObserver to watch for class changes
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.attributeName === 'class') {
                        const isOpen = moreModesPanel.classList.contains('open');
                        if (isOpen && window.innerWidth <= 768) {
                            telemetry.style.opacity = '0';
                            telemetry.style.pointerEvents = 'none';
                        } else {
                            telemetry.style.opacity = '';
                            telemetry.style.pointerEvents = '';
                        }
                    }
                });
            });
            
            observer.observe(moreModesPanel, { attributes: true });
        }
    }

    initBackgroundControls() {
        log('=== INITIALIZING BACKGROUND CONTROLS ===');

        // Test basic functionality first
        setTimeout(() => {
            log('Testing background controls after delay...');
            this.testBackgroundControls();
        }, 2000);

        // Test button
        const testBtn = document.getElementById('test-bg-btn');
        if (testBtn) {
            log('✅ Test button found, adding event listener');
            testBtn.addEventListener('click', () => {
                log('🧪 Test button clicked!');
                alert('Background controls are working! Opacity will be set to 50%');
                this.setBackgroundOpacity(50);
            });
        } else {
            log('❌ Test button NOT found');
        }

        // Opacity slider
        const opacitySlider = document.getElementById('bg-opacity-slider');
        const opacityValue = document.getElementById('bg-opacity-value');

        if (opacitySlider && opacityValue) {
            log('✅ Opacity slider found, adding event listener');
            opacitySlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                log(`🔧 Opacity slider input: ${value}`);
                this.setBackgroundOpacity(value);
            });
        } else {
            log('❌ Opacity slider NOT found');
        }

        // Blur slider
        const blurSlider = document.getElementById('bg-blur-slider');
        const blurValue = document.getElementById('bg-blur-value');

        if (blurSlider && blurValue) {
            log('✅ Blur slider found, adding event listener');
            blurSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                log(`🔧 Blur slider input: ${value}`);
                this.setBackgroundBlur(value);
            });
        } else {
            log('❌ Blur slider NOT found');
        }

        // Keyboard controls for background
        document.addEventListener('keydown', (e) => {
            const key = e.key;
            if (key === '1') {
                this.adjustOpacity(-10);
            } else if (key === '2') {
                this.adjustOpacity(10);
            } else if (key === '3') {
                this.adjustBlur(-1);
            } else if (key === '4') {
                this.adjustBlur(1);
            } else if (key === '5') {
                this.toggleVignette();
            } else if (key === '6') {
                this.toggleGrain();
            } else if (key === '7') {
                this.toggleScanlines();
            }
        });

        // Preset buttons
        const presetButtons = document.querySelectorAll('.preset-btn');
        log(`Found ${presetButtons.length} preset buttons`);
        presetButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                log(`Preset button clicked: ${preset}`);
                this.applyBackgroundPreset(preset);
            });
        });

        // Initialize background overlay
        this.createBackgroundOverlay();

        // Make sure controls panel is expanded by default
        const dataPanel = document.getElementById('data-panel');
        if (dataPanel) {
            dataPanel.classList.remove('collapsed');
            log('Controls panel expanded by default');
        }

        log('=== BACKGROUND CONTROLS INITIALIZATION COMPLETE ===');
    }

    testBackgroundControls() {
        log('🧪 Testing background controls...');

        // Test setting opacity to 50%
        this.setBackgroundOpacity(50);

        // Test setting blur to 5px
        this.setBackgroundBlur(5);

        log('🧪 Background controls test complete');
    }

    setBackgroundOpacity(value) {
        this.backgroundSettings.opacity = value;
        const opacityValue = document.getElementById('bg-opacity-value');
        if (opacityValue) {
            opacityValue.textContent = value;
        }

        if (this.backgroundOverlay) {
            if (value > 0) {
                this.backgroundOverlay.style.background = `rgba(0, 0, 0, ${value / 100})`;
                log(`🎨 Background opacity set to ${value}%`);
            } else {
                this.backgroundOverlay.style.background = 'transparent';
                log('🎨 Background set to transparent');
            }
        } else {
            log('❌ Background overlay not available');
        }
    }

    setBackgroundBlur(value) {
        this.backgroundSettings.blur = value;
        const blurValue = document.getElementById('bg-blur-value');
        if (blurValue) {
            blurValue.textContent = value;
        }

        if (this.backgroundOverlay) {
            if (value > 0) {
                this.backgroundOverlay.style.backdropFilter = `blur(${value}px)`;
                log(`🎨 Background blur set to ${value}px`);
            } else {
                this.backgroundOverlay.style.backdropFilter = 'none';
                log('🎨 Background blur removed');
            }
        } else {
            log('❌ Background overlay not available');
        }
    }

    createBackgroundOverlay() {
        // Create overlay div for background effects
        const overlay = document.createElement('div');
        overlay.id = 'background-overlay';
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.pointerEvents = 'none';
        overlay.style.zIndex = '2'; // Above video (z-index: 1) but below panels (z-index: 10)
        overlay.style.transition = 'all 0.3s ease';
        overlay.style.background = 'transparent';
        document.body.appendChild(overlay);
        this.backgroundOverlay = overlay;
        log('Background overlay created');
    }

    updateBackgroundOverlay() {
        this.setBackgroundOpacity(this.backgroundSettings.opacity);
        this.setBackgroundBlur(this.backgroundSettings.blur);
    }

    adjustOpacity(delta) {
        this.backgroundSettings.opacity = Math.max(0, Math.min(90, this.backgroundSettings.opacity + delta));
        const slider = document.getElementById('bg-opacity-slider');
        const value = document.getElementById('bg-opacity-value');
        if (slider) slider.value = this.backgroundSettings.opacity;
        if (value) value.textContent = this.backgroundSettings.opacity;
        this.updateBackgroundOverlay();
    }

    adjustBlur(delta) {
        this.backgroundSettings.blur = Math.max(0, Math.min(20, this.backgroundSettings.blur + delta));
        const slider = document.getElementById('bg-blur-slider');
        const value = document.getElementById('bg-blur-value');
        if (slider) slider.value = this.backgroundSettings.blur;
        if (value) value.textContent = this.backgroundSettings.blur;
        this.updateBackgroundOverlay();
    }

    toggleVignette() {
        this.backgroundSettings.vignette = !this.backgroundSettings.vignette;
        this.updateBackgroundEffects();
        log(`VIGNETTE: ${this.backgroundSettings.vignette ? 'ON' : 'OFF'}`);
    }

    toggleGrain() {
        this.backgroundSettings.grain = !this.backgroundSettings.grain;
        this.updateBackgroundEffects();
        log(`GRAIN: ${this.backgroundSettings.grain ? 'ON' : 'OFF'}`);
    }

    toggleScanlines() {
        this.backgroundSettings.scanlines = !this.backgroundSettings.scanlines;
        this.updateBackgroundEffects();
        log(`SCANLINES: ${this.backgroundSettings.scanlines ? 'ON' : 'OFF'}`);
    }

    updateBackgroundEffects() {
        const { vignette, grain, scanlines } = this.backgroundSettings;
        
        // Reduce effects on mobile for performance
        const isMobile = window.innerWidth <= 768 || this.engine?.isMobileScreen;
        const reducedEffects = isMobile;

        // Vignette effect
        if (vignette) {
            this.backgroundOverlay.style.background = `radial-gradient(circle, transparent 30%, rgba(0,0,0,0.3) 70%, rgba(0,0,0,0.6) 100%)`;
        } else if (this.backgroundSettings.opacity === 0) {
            this.backgroundOverlay.style.background = 'transparent';
        }

        // Grain effect (CSS noise) - reduced on mobile
        if (grain && !reducedEffects) {
            this.backgroundOverlay.style.backgroundImage = `url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E")`;
            this.backgroundOverlay.style.opacity = '0.1';
        } else if (grain && reducedEffects) {
            // Lighter grain for mobile
            this.backgroundOverlay.style.backgroundImage = `url("data:image/svg+xml,%3Csvg viewBox='0 0 128 128' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.5' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E")`;
            this.backgroundOverlay.style.opacity = '0.05';
        } else {
            this.backgroundOverlay.style.backgroundImage = 'none';
            this.backgroundOverlay.style.opacity = '1';
        }

        // Scanlines effect - reduced on mobile
        if (scanlines && !reducedEffects) {
            this.backgroundOverlay.style.backgroundImage += `, linear-gradient(to bottom, transparent 50%, rgba(0,255,255,0.03) 50%)`;
            this.backgroundOverlay.style.backgroundSize = `100% 4px`;
        } else if (scanlines && reducedEffects) {
            // Lighter scanlines for mobile
            this.backgroundOverlay.style.backgroundImage += `, linear-gradient(to bottom, transparent 50%, rgba(0,255,255,0.015) 50%)`;
            this.backgroundOverlay.style.backgroundSize = `100% 6px`;
        }
    }

    applyBackgroundPreset(preset) {
        switch (preset) {
            case 'clear':
                this.backgroundSettings = { opacity: 0, blur: 0, vignette: false, grain: false, scanlines: false };
                break;
            case 'subtle':
                this.backgroundSettings = { opacity: 20, blur: 2, vignette: false, grain: false, scanlines: false };
                break;
            case 'medium':
                this.backgroundSettings = { opacity: 40, blur: 5, vignette: true, grain: false, scanlines: false };
                break;
            case 'heavy':
                this.backgroundSettings = { opacity: 70, blur: 10, vignette: true, grain: true, scanlines: true };
                break;
        }

        // Update UI elements
        const opacitySlider = document.getElementById('bg-opacity-slider');
        const opacityValue = document.getElementById('bg-opacity-value');
        const blurSlider = document.getElementById('bg-blur-slider');
        const blurValue = document.getElementById('bg-blur-value');

        if (opacitySlider) opacitySlider.value = this.backgroundSettings.opacity;
        if (opacityValue) opacityValue.textContent = this.backgroundSettings.opacity;
        if (blurSlider) blurSlider.value = this.backgroundSettings.blur;
        if (blurValue) blurValue.textContent = this.backgroundSettings.blur;

        this.updateBackgroundOverlay();
        this.updateBackgroundEffects();
        log(`BACKGROUND PRESET: ${preset.toUpperCase()}`);
    }

    toggleFullscreen() {
        const container = document.getElementById('container');
        
        if (!document.fullscreenElement) {
            // Enter fullscreen
            if (container.requestFullscreen) {
                container.requestFullscreen();
            } else if (container.webkitRequestFullscreen) {
                container.webkitRequestFullscreen();
            } else if (container.msRequestFullscreen) {
                container.msRequestFullscreen();
            }
            log("Entering Fullscreen Mode");
        } else {
            // Exit fullscreen
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            log("Exiting Fullscreen Mode");
        }
        
        // Update panel layout after fullscreen change
        if (this.layoutManager) {
            setTimeout(() => this.layoutManager.update(), 100);
        }
    }

    updateFullscreenButton() {
        const btn = document.getElementById('fullscreen-btn');
        const text = document.getElementById('fullscreen-text');
        
        if (document.fullscreenElement) {
            btn.classList.add('is-fullscreen');
            text.textContent = 'EXIT';
        } else {
            btn.classList.remove('is-fullscreen');
            text.textContent = 'FULLSCREEN';
        }
    }

    toggleMobileView() {
        const isMobile = document.body.classList.toggle('mobile-view');
        this.updateMobileButton();
        
        if (isMobile) {
            log("Mobile View Enabled");
        } else {
            log("Desktop View Enabled");
        }
        
        // Trigger resize to update canvas
        this.engine.resize();
        
        // Update panel layout for mobile view
        if (this.layoutManager) {
            setTimeout(() => this.layoutManager.update(), 100);
        }
    }

    updateMobileButton() {
        const btn = document.getElementById('mobile-btn');
        const text = document.getElementById('mobile-text');

        if (document.body.classList.contains('mobile-view')) {
            btn.classList.add('is-mobile');
            if (text) text.textContent = 'DESKTOP';
        } else {
            btn.classList.remove('is-mobile');
            if (text) text.textContent = 'MOBILE';
        }
    }

    detectMiddleFingerGesture(hands) {
        if (!hands || !hands.landmarks || hands.landmarks.length === 0) return false;

        // Check first hand for middle finger
        const landmarks = hands.landmarks[0];
        if (!landmarks) return false;

        // Middle finger landmarks: MCP (9), PIP (10), DIP (11), TIP (12)
        const middleMCP = landmarks[9];  // Middle finger knuckle
        const middlePIP = landmarks[10]; // Middle finger middle joint
        const middleDIP = landmarks[11]; // Middle finger top joint
        const middleTip = landmarks[12]; // Middle finger tip

        if (!middleMCP || !middlePIP || !middleDIP || !middleTip) return false;

        // Check if middle finger is extended (tip is above DIP and PIP)
        // Y coordinates decrease as you go up the screen, so higher Y means lower position
        const isExtended = middleTip.y < middleDIP.y && middleDIP.y < middlePIP.y;

        // Check that other fingers are not extended (basic check)
        const indexTip = landmarks[8];
        const ringTip = landmarks[16];
        const pinkyTip = landmarks[20];

        // Middle finger should be significantly higher than others when extended
        let otherFingersLower = true;
        if (indexTip && ringTip && pinkyTip) {
            const avgOtherFingers = (indexTip.y + ringTip.y + pinkyTip.y) / 3;
            otherFingersLower = middleTip.y < avgOtherFingers - 30; // At least 30 pixels higher
        }

        return isExtended && otherFingersLower;
    }

    applyCensorship() {
        if (this.isCensored) return; // Already censored

        this.isCensored = true;

        // Create censorship overlay
        const overlay = document.createElement('div');
        overlay.className = 'censorship-glitch';
        overlay.id = 'censorship-overlay';

        const text = document.createElement('div');
        text.className = 'censorship-overlay';
        text.textContent = '🚫 CENSORED 🚫';

        document.body.appendChild(overlay);
        document.body.appendChild(text);

        // Log the censorship
        log('MIDDLE FINGER DETECTED - CENSORSHIP ACTIVATED');

        // Clear existing timer
        if (this.censorshipTimer) {
            clearTimeout(this.censorshipTimer);
        }

        // Remove censorship after 3 seconds
        this.censorshipTimer = setTimeout(() => {
            this.removeCensorship();
        }, 3000);
    }

    removeCensorship() {
        this.isCensored = false;

        const overlay = document.getElementById('censorship-overlay');
        const textElements = document.querySelectorAll('.censorship-overlay');

        if (overlay) {
            overlay.remove();
        }
        textElements.forEach(el => el.remove());

        if (this.censorshipTimer) {
            clearTimeout(this.censorshipTimer);
            this.censorshipTimer = null;
        }

        log('CENSORSHIP DEACTIVATED');
    }

    setMode(newMode) {
        // Remove censorship when changing modes
        this.removeCensorship();

        this.mode = newMode;
        document.getElementById('current-mode').innerText = newMode;
        document.getElementById('mode-desc').innerText = this.getModeDesc(newMode);
        
        // Set data-mode attribute on body for CSS selectors
        document.body.setAttribute('data-mode', newMode);
        
        // Update visual profile for new mode
        this.visualProfile = getVisualProfile(newMode);
        this.applyVisualProfile();
        
        // Update mobile top bar mode indicator
        this.updateTopBarMode();
        
        log(`Switched to Mode: ${newMode}`);
        
        // Reset smoothing when changing modes to avoid artifacts
        if (this.smoother) {
            this.smoother.reset();
        }
        
        // Handle mode-specific panels and visibility
        this.handleModeChange(newMode);
        
        // Update panel layout
        if (this.layoutManager) {
            setTimeout(() => this.layoutManager.update(), 50);
        }
        
        // Glitch Effect
        document.body.classList.add('glitch-active');
        setTimeout(() => document.body.classList.remove('glitch-active'), 300);
    }
    
    // Apply visual profile settings to rendering systems
    applyVisualProfile() {
        const vp = this.visualProfile;
        if (!vp) return;
        
        // Update CSS custom properties for consistent styling
        document.documentElement.style.setProperty('--glow-intensity', vp.glowIntensity);
        document.documentElement.style.setProperty('--scanline-opacity', vp.scanlineOpacity);
        document.documentElement.style.setProperty('--grain-intensity', vp.grainIntensity);
        document.documentElement.style.setProperty('--vignette-strength', vp.vignetteStrength);
        document.documentElement.style.setProperty('--mode-primary-color', vp.primaryColor);
        document.documentElement.style.setProperty('--mode-secondary-color', vp.secondaryColor);
        
        // Update scanlines element
        const scanlines = document.querySelector('.scanlines');
        if (scanlines) {
            scanlines.style.opacity = vp.scanlineOpacity;
        }
        
        // Update engine if available
        if (this.engine) {
            // Store profile for use in render methods
            this.engine.visualProfile = vp;
            
            // Update 3D materials if needed
            if (this.engine.braceletShaderUniforms) {
                const hexToRgb = (hex) => {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? {
                        r: parseInt(result[1], 16) / 255,
                        g: parseInt(result[2], 16) / 255,
                        b: parseInt(result[3], 16) / 255
                    } : { r: 0, g: 1, b: 1 };
                };
                
                const primary = hexToRgb(vp.primaryColor);
                const secondary = hexToRgb(vp.secondaryColor);
                
                this.engine.braceletShaderUniforms.uPrimaryColor.value.setRGB(primary.r, primary.g, primary.b);
                this.engine.braceletShaderUniforms.uSecondaryColor.value.setRGB(secondary.r, secondary.g, secondary.b);
            }
        }
        
        log(`VISUAL PROFILE: Applied for mode ${this.mode}`);
    }
    
    // Get current visual profile
    getVisualProfile() {
        return this.visualProfile;
    }
    
    // Handle mode-specific panel visibility
    handleModeChange(newMode) {
        // Handle OPERATOR mode panels
        const operatorPanels = document.getElementById('operator-panels');
        if (operatorPanels) {
            if (newMode === 'OPERATOR') {
                operatorPanels.style.display = 'block';
                this.positionOperatorPanels();
            } else {
                operatorPanels.style.display = 'none';
            }
        }

        // Handle SANDTABLE mode
        if (this.engine && this.engine.sandtableGroup) {
            if (newMode === 'SANDTABLE') {
                this.engine.sandtableGroup.visible = true;
                log('SANDTABLE: Mode activated');
            } else if (this.mode === 'SANDTABLE') {
                // Complete reset when leaving SANDTABLE mode
                this.engine.sandtableGroup.visible = false;
                if (this.engine.resetSandtableState) {
                    this.engine.resetSandtableState();
                }
                log('SANDTABLE: Mode deactivated - complete reset');
            }
        }
        
        // Handle INTEL 3D boxes
        if (this.engine && this.engine.intel3DGroup) {
            if (newMode === 'INTEL') {
                this.engine.intel3DGroup.visible = true;
                log('INTEL 3D: Tactical boxes enabled');
            } else {
                this.engine.hideIntel3D();
            }
        }
        
        // Handle INTEL filter panel visibility
        this.updateIntelFilterPanelVisibility(newMode === 'INTEL');

        // Handle CAROUSEL mode panel
        const carouselPanel = document.getElementById('carousel-panel');
        if (carouselPanel) {
            if (newMode === 'CAROUSEL') {
                carouselPanel.style.display = 'block';
                if (!carouselPanel.style.left) {
                    carouselPanel.style.left = '300px';
                    carouselPanel.style.top = '200px';
                }
                // Resize carousel canvas after panel is visible (fixes images not showing on first load)
                setTimeout(() => {
                    if (this.carouselSystem) {
                        this.carouselSystem.resize();
                    }
                }, 50);
            } else {
                carouselPanel.style.display = 'none';
                // Hide 3D hand FX when leaving CAROUSEL mode
                if (this.engine && this.engine.hideCarouselHandFX) {
                    this.engine.hideCarouselHandFX();
                }
            }
        }
    }

    positionOperatorPanels() {
        const cyberDeck = document.getElementById('cyber-deck');
        const orbitalScan = document.getElementById('orbital-scan');
        const sysIntegrity = document.getElementById('sys-integrity');

        if (cyberDeck && !cyberDeck.style.left) {
            cyberDeck.style.left = '100px';
            cyberDeck.style.top = '150px';
        }
        if (orbitalScan && !orbitalScan.style.left) {
            orbitalScan.style.left = '550px';
            orbitalScan.style.top = '150px';
        }
        if (sysIntegrity && !sysIntegrity.style.left) {
            sysIntegrity.style.right = '100px';
            sysIntegrity.style.top = '150px';
        }
    }

    initPanelToggle() {
        const controlsTab = document.getElementById('controls-tab');
        const dataPanel = document.getElementById('data-panel');

        if (controlsTab && dataPanel) {
            controlsTab.addEventListener('click', () => {
                dataPanel.classList.toggle('collapsed');

                // Update tab icon based on state
                const tabIcon = controlsTab.querySelector('.tab-icon');
                if (dataPanel.classList.contains('collapsed')) {
                    tabIcon.textContent = '🔽';
                    controlsTab.title = 'Show Controls Panel';
                } else {
                    tabIcon.textContent = '⚙️';
                    controlsTab.title = 'Hide Controls Panel';
                }
            });
        }
        
        // Initialize mobile touch bar
        this.initMobileTouchBar();
        
        // Initialize INTEL filter panel
        this.initIntelFilterPanel();
    }
    
    // ========== INTEL FILTER PANEL SYSTEM ==========
    initIntelFilterPanel() {
        const filterPanel = document.getElementById('intel-filter-panel');
        if (!filterPanel) return;
        
        // Set up category click handlers
        const categories = document.querySelectorAll('.intel-filter-category');
        categories.forEach(cat => {
            cat.addEventListener('click', () => {
                const categoryName = cat.dataset.category;
                this.toggleFilter(categoryName);
            });
        });
        
        log('INTEL FILTER: System initialized');
    }
    
    toggleIntelFilterPanel() {
        const filterPanel = document.getElementById('intel-filter-panel');
        if (!filterPanel) return;
        
        this.filterPanelCollapsed = !this.filterPanelCollapsed;
        
        if (this.filterPanelCollapsed) {
            filterPanel.classList.add('collapsed');
        } else {
            filterPanel.classList.remove('collapsed');
        }
    }
    
    toggleFilter(category) {
        if (this.intelFilters.hasOwnProperty(category)) {
            this.intelFilters[category] = !this.intelFilters[category];
            this.updateFilterUI(category);
            
            const status = this.intelFilters[category] ? 'ENABLED' : 'DISABLED';
            log(`INTEL FILTER: ${category.toUpperCase()} ${status}`);
        }
    }
    
    updateFilterUI(category) {
        const catElement = document.querySelector(`.intel-filter-category[data-category="${category}"]`);
        if (catElement) {
            if (this.intelFilters[category]) {
                catElement.classList.remove('disabled');
            } else {
                catElement.classList.add('disabled');
            }
        }
    }
    
    enableAllFilters() {
        Object.keys(this.intelFilters).forEach(cat => {
            this.intelFilters[cat] = true;
            this.updateFilterUI(cat);
        });
        log('INTEL FILTER: ALL CATEGORIES ENABLED');
    }
    
    disableAllFilters() {
        Object.keys(this.intelFilters).forEach(cat => {
            this.intelFilters[cat] = false;
            this.updateFilterUI(cat);
        });
        log('INTEL FILTER: ALL CATEGORIES DISABLED');
    }
    
    // Get category for an object class
    getObjectCategory(objClass) {
        const className = objClass.toLowerCase().trim();
        return this.categoryMapping[className] || 'other';
    }
    
    // Check if an object should be displayed based on filters
    shouldDisplayObject(objClass) {
        const category = this.getObjectCategory(objClass);
        return this.intelFilters[category] === true;
    }
    
    // Filter objects based on active filters
    filterIntelObjects(objects) {
        if (!objects) return [];
        
        // Reset counts
        this.detectedCounts = {
            person: 0, vehicle: 0, electronics: 0, furniture: 0,
            animals: 0, food: 0, sports: 0, accessories: 0,
            kitchen: 0, other: 0
        };
        
        // Count all objects by category
        objects.forEach(obj => {
            const category = this.getObjectCategory(obj.class);
            this.detectedCounts[category] = (this.detectedCounts[category] || 0) + 1;
        });
        
        // Update UI counts
        this.updateFilterCounts();
        
        // Return filtered objects
        return objects.filter(obj => this.shouldDisplayObject(obj.class));
    }
    
    updateFilterCounts() {
        Object.keys(this.detectedCounts).forEach(cat => {
            const countEl = document.getElementById(`count-${cat}`);
            if (countEl) {
                countEl.textContent = this.detectedCounts[cat] || 0;
            }
        });
    }
    
    // Show/hide filter panel based on mode
    updateIntelFilterPanelVisibility(show) {
        const filterPanel = document.getElementById('intel-filter-panel');
        if (filterPanel) {
            filterPanel.style.display = show ? 'block' : 'none';
        }
    }
    
    // ========== MOBILE TOUCH BAR SYSTEM ==========
    initMobileTouchBar() {
        const touchBar = document.getElementById('mobile-touch-bar');
        const moreModesPanel = document.getElementById('more-modes-panel');
        const touchBarToggle = document.getElementById('touch-bar-toggle');
        
        if (!touchBar) return;
        
        // Detect if mobile device or small screen
        this.isMobileDevice = this.detectMobileDevice();
        this.updateMobileTouchBarVisibility();
        
        // Listen for resize to update visibility
        window.addEventListener('resize', () => {
            this.updateMobileTouchBarVisibility();
        });
        
        // Handle touch button clicks
        const allTouchBtns = document.querySelectorAll('.touch-btn');
        allTouchBtns.forEach(btn => {
            // Use touchstart for faster response on mobile
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.handleTouchButton(btn);
            }, { passive: false });
            
            // Fallback for mouse/desktop
            btn.addEventListener('click', (e) => {
                if (e.pointerType !== 'touch') {
                    this.handleTouchButton(btn);
                }
            });
        });
        
        // Toggle more modes panel
        if (touchBarToggle) {
            touchBarToggle.addEventListener('click', () => {
                this.toggleMoreModesPanel();
            });
        }
        
        // Close more modes panel when clicking outside
        // Use setTimeout to allow the toggle to happen first
        document.addEventListener('click', (e) => {
            // Ignore clicks on the MORE button itself (it handles toggle)
            if (e.target.closest('[data-action="more"]')) {
                return;
            }
            
            // Ignore clicks on touch-bar-toggle
            if (e.target.closest('#touch-bar-toggle')) {
                return;
            }
            
            // Close panel if clicking outside
            if (moreModesPanel && moreModesPanel.classList.contains('open')) {
                if (!moreModesPanel.contains(e.target)) {
                    this.closeMoreModesPanel();
                }
            }
        });
        
        log('MOBILE: Touch bar initialized');
        
        // Initialize mobile top bar
        this.initMobileTopBar();
        
        // Initialize toggle HUD button
        this.initToggleHUD();
    }
    
    // ========== MOBILE TOP BAR ==========
    initMobileTopBar() {
        const topBar = document.getElementById('mobile-top-bar');
        if (!topBar) return;
        
        // Fullscreen button
        const fullscreenBtn = document.getElementById('top-fullscreen-btn');
        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', () => {
                this.toggleFullscreen();
            });
        }
        
        // Mobile view button
        const mobileBtn = document.getElementById('top-mobile-btn');
        if (mobileBtn) {
            mobileBtn.addEventListener('click', () => {
                this.toggleMobileView();
            });
        }
        
        // Camera switch button (if available)
        const cameraBtn = document.getElementById('top-camera-btn');
        if (cameraBtn) {
            cameraBtn.addEventListener('click', () => {
                this.switchCamera();
            });
        }
        
        // Settings button - opens more modes panel
        const settingsBtn = document.getElementById('top-settings-btn');
        if (settingsBtn) {
            settingsBtn.addEventListener('click', () => {
                this.toggleMoreModesPanel();
            });
        }
        
        log('MOBILE: Top bar initialized');
    }
    
    // ========== TOGGLE HUD ==========
    initToggleHUD() {
        const toggleBtn = document.getElementById('toggle-hud-btn');
        if (!toggleBtn) return;
        
        this.hudVisible = true;
        
        toggleBtn.addEventListener('click', () => {
            this.hudVisible = !this.hudVisible;
            document.body.classList.toggle('hud-collapsed', !this.hudVisible);
            toggleBtn.classList.toggle('hud-hidden', !this.hudVisible);
            toggleBtn.textContent = this.hudVisible ? '👁️' : '👁️‍🗨️';
            log(`HUD: ${this.hudVisible ? 'VISIBLE' : 'HIDDEN'}`);
        });
        
        log('MOBILE: Toggle HUD initialized');
    }
    
    // Switch camera (front/back)
    async switchCamera() {
        if (!this.video || !this.video.srcObject) return;
        
        try {
            // Get current facing mode
            const tracks = this.video.srcObject.getVideoTracks();
            if (tracks.length === 0) return;
            
            const currentFacingMode = tracks[0].getSettings().facingMode || 'user';
            const newFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            
            // Stop current stream
            tracks.forEach(track => track.stop());
            
            // Request new stream
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: newFacingMode,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            });
            
            this.video.srcObject = stream;
            await this.video.play();
            
            log(`CAMERA: Switched to ${newFacingMode === 'user' ? 'FRONT' : 'BACK'} camera`);
        } catch (error) {
            console.warn('Camera switch failed:', error);
            log('CAMERA: Switch failed - device may not support multiple cameras');
        }
    }
    
    // Update top bar mode indicator
    updateTopBarMode() {
        const modeIndicator = document.getElementById('top-bar-mode');
        if (modeIndicator) {
            modeIndicator.textContent = this.mode;
        }
    }
    
    detectMobileDevice() {
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        const isMobileUA = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());
        const isSmallScreen = window.innerWidth <= 768;
        const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        return isMobileUA || (isSmallScreen && hasTouchScreen);
    }
    
    updateMobileTouchBarVisibility() {
        const touchBar = document.getElementById('mobile-touch-bar');
        const moreModesPanel = document.getElementById('more-modes-panel');
        const touchBarToggle = document.getElementById('touch-bar-toggle');
        
        const shouldShow = window.innerWidth <= 768 || this.isMobileDevice;
        
        if (touchBar) {
            touchBar.classList.toggle('visible', shouldShow);
        }
        if (moreModesPanel) {
            moreModesPanel.classList.toggle('visible', shouldShow);
        }
        if (touchBarToggle) {
            touchBarToggle.classList.toggle('visible', shouldShow);
        }
    }
    
    handleTouchButton(btn) {
        const mode = btn.dataset.mode;
        const action = btn.dataset.action;
        const key = btn.dataset.key;
        
        // Visual feedback
        btn.classList.add('active');
        setTimeout(() => btn.classList.remove('active'), 150);
        
        // Handle special actions
        if (action === 'more') {
            this.toggleMoreModesPanel();
            return;
        }
        
        if (action === 'fullscreen') {
            this.toggleFullscreen();
            this.closeMoreModesPanel();
            return;
        }
        
        if (action === 'cube') {
            // Simulate H key press for cube toggle
            this.cubeActive = !this.cubeActive;
            this.engine.cubeGroup.visible = this.cubeActive;
            
            if (this.cubeActive) {
                this.engine.cubeBasePosition = { x: 0, y: 0, z: 0 };
                this.engine.cubeBaseScale = 1.0;
                this.engine.lastPinchDistance = null;
                this.engine.cubeGroup.position.set(0, 0, 0);
                this.engine.cubeGroup.scale.set(1, 1, 1);
            } else {
                this.engine.renderer3D.render(this.engine.scene, this.engine.camera3D);
            }
            
            log(this.cubeActive ? 'CUBE: ACTIVATED' : 'CUBE: DEACTIVATED');
            this.closeMoreModesPanel();
            return;
        }
        
        // Handle mode change
        if (mode) {
            this.setMode(mode);
            this.closeMoreModesPanel();
            this.updateTouchBarActiveState();
        }
    }
    
    toggleMoreModesPanel() {
        const panel = document.getElementById('more-modes-panel');
        if (panel) {
            const isOpen = panel.classList.contains('open');
            
            if (isOpen) {
                // Close: remove open first (animation), then visible after transition
                panel.classList.remove('open');
                setTimeout(() => {
                    panel.classList.remove('visible');
                }, 300); // Match transition duration
            } else {
                // Open: add visible first (display), then open for animation
                panel.classList.add('visible');
                // Force reflow to ensure transition works
                panel.offsetHeight;
                panel.classList.add('open');
            }
            
            // Update body class for mobile top bar hiding (mobile-only)
            document.body.classList.toggle('more-modes-open', !isOpen);
            
            // Update layout when panel opens/closes
            if (this.layoutManager) {
                this.layoutManager.update();
            }
        }
    }
    
    closeMoreModesPanel() {
        const panel = document.getElementById('more-modes-panel');
        if (panel) {
            // Remove open first (animation), then visible after transition
            panel.classList.remove('open');
            setTimeout(() => {
                panel.classList.remove('visible');
            }, 300); // Match transition duration
            
            // Remove body class (mobile-only)
            document.body.classList.remove('more-modes-open');
            
            // Update layout when panel closes
            if (this.layoutManager) {
                this.layoutManager.update();
            }
        }
    }
    
    updateTouchBarActiveState() {
        const allTouchBtns = document.querySelectorAll('.touch-btn[data-mode]');
        allTouchBtns.forEach(btn => {
            const isActive = btn.dataset.mode === this.mode;
            btn.classList.toggle('active', isActive);
        });
    }

    getModeDesc(mode) {
        const descs = {
            'STANDBY': 'CAMERA FEED ONLY - NO TRACKING',
            'HUD': 'HAND TRACKING + TACTICAL HUD',
            'DRAW': 'AIR GESTURE DRAWING',
            'XRAY': 'SPECTRAL INVERSION FILTER',
            'INTEL': 'SMART CAPTURE • 3D WIREFRAME BOXES • TECHNICAL DATA • THREAT ANALYSIS',
            'MATRIX': 'LiDAR DEPTH SIMULATION (PSEUDO-DEPTH)',
            'VOID': 'SENSOR DATA ONLY - BLACK BG',
            'WIREFRAME': 'MINIMAL HAND SKELETON',
            'DRONE': 'OPTICAL DISTORTION FX',
            'FACE': 'BIOMETRIC FACE TRACKING',
            'OPERATOR': 'ADVANCED OPERATOR INTERFACE',
            'CAROUSEL': '3D CYLINDRICAL IMAGE CAROUSEL',
            'SANDTABLE': 'HOLOGRAPHIC TERRAIN • PALM ANCHOR • PINCH-TO-ZOOM • FINGER SCULPT',
            'TOUCH': 'HOLOGRAPHIC AIR TOUCH • IMPACT WAVES • DIGITAL GLITCH FX'
        };
        return descs[mode] || 'UNKNOWN';
    }

    detectAutoModes(hands) {
        // AUTO-DETECT DISABLED: User has full control of mode switching
        // Previously, this function would auto-switch to SANDTABLE when detecting 2 hands
        // This was causing unwanted mode changes and interfering with user control
        
        // Reset any existing auto-mode state
        if (this.autoModeState) {
            this.autoModeState.sandtableConfidence = 0;
            this.autoModeState.framesStable = 0;
        }
        
        // Exit early - no auto-detection
        return;
        
        /* ORIGINAL CODE DISABLED:
        // PROTECTED MODES: Don't auto-switch when user is in these modes
        // These modes require specific hand gestures or interactions that would conflict
        const protectedModes = ['DRAW', 'INTEL', 'FACE', 'OPERATOR', 'CAROUSEL', 'TOUCH', 'XRAY', 'MATRIX', 'VOID', 'WIREFRAME', 'DRONE', 'SANDTABLE'];
        
        // Also protect when cube is active (H key toggle) - it's independent of mode
        const cubeIsActive = this.cubeActive === true;
        
        if (protectedModes.includes(this.mode) || cubeIsActive) {
            // Reset auto-mode state when protected to avoid instant switch when leaving
            if (this.autoModeState) {
                this.autoModeState.sandtableConfidence = 0;
                this.autoModeState.framesStable = 0;
            }
            return; // Don't auto-switch modes
        }
        */
        
        /* REST OF AUTO-DETECT CODE DISABLED:
        
        if (!this.autoModeState) {
            this.autoModeState = {
                sandtableConfidence: 0,
                framesStable: 0,
                minFramesStable: 10 // Require 10 stable frames before activation
            };
        }

        let currentConfidence = 0;

        if (hands && hands.landmarks && hands.landmarks.length === 2) {
            const hand1 = hands.landmarks[0];
            const hand2 = hands.landmarks[1];

            // Validate that hands have required landmarks
            if (!hand1 || !hand2 || hand1.length < 13 || hand2.length < 13) {
                currentConfidence = 0;
            } else {
                // Improved palm detection: check multiple finger relationships for robustness
                const palm1Facing = this.detectPalmFacing(hand1);
                const palm2Facing = this.detectPalmFacing(hand2);

                if (palm1Facing && palm2Facing) {
                    // Calculate distance between wrist centers
                    const wrist1 = hand1[0];
                    const wrist2 = hand2[0];

                    if (wrist1 && wrist2) {
                        const distance = Math.sqrt(
                            Math.pow(wrist1.x - wrist2.x, 2) +
                            Math.pow(wrist1.y - wrist2.y, 2)
                        );

                        // Distance in normalized space should be 0.15-0.5
                        if (distance >= 0.15 && distance <= 0.5) {
                            // Additional stability checks: hands shouldn't be moving too much
                            const handStability = this.checkHandStability(hands);
                            currentConfidence = handStability > 0.7 ? 1.0 : 0.5;
                        }
                    }
                }
            }
        }

        // Smooth confidence with exponential moving average to reduce jitter
        this.autoModeState.sandtableConfidence =
            this.autoModeState.sandtableConfidence * 0.8 + currentConfidence * 0.2;

        // Hysteresis thresholds
        const activationThreshold = 0.8;  // Need 80% confidence to activate
        const deactivationThreshold = 0.3; // Drop to 30% confidence to deactivate

        if (this.autoModeState.sandtableConfidence > activationThreshold) {
            this.autoModeState.framesStable++;
            if (this.autoModeState.framesStable >= this.autoModeState.minFramesStable) {
                if (this.mode !== 'SANDTABLE') {
                    this.setMode('SANDTABLE');
                    log('AUTO: SANDTABLE MODE ACTIVATED (stable detection)');
                }
            }
        } else if (this.autoModeState.sandtableConfidence < deactivationThreshold) {
            this.autoModeState.framesStable = 0;
            if (this.mode === 'SANDTABLE') {
                this.setMode('HUD');
                log('AUTO: SANDTABLE MODE DEACTIVATED (unstable detection)');
            }
        }
        */
    }

    detectPalmFacing(hand) {
        // More robust palm detection using multiple finger relationships
        const wrist = hand[0];
        const middleTip = hand[12];
        const indexTip = hand[8];
        const pinkyTip = hand[20];

        if (!wrist || !middleTip || !indexTip || !pinkyTip) return false;

        // Check that fingertips are generally above wrist (palm facing)
        const tipsAboveWrist = (middleTip.y < wrist.y) &&
                              (indexTip.y < wrist.y) &&
                              (pinkyTip.y < wrist.y);

        // Check finger spread (open hand vs fist)
        const fingerSpread = Math.abs(indexTip.x - pinkyTip.x) > 0.1;

        return tipsAboveWrist && fingerSpread;
    }

    checkHandStability(hands) {
        // Check if hands are relatively stable (not moving too much)
        if (!this.lastHandPositions) {
            this.lastHandPositions = hands.landmarks.map(h => ({ x: h[0].x, y: h[0].y }));
            return 1.0; // First frame is always stable
        }

        let totalMovement = 0;
        for (let i = 0; i < hands.landmarks.length; i++) {
            const current = hands.landmarks[i][0];
            const last = this.lastHandPositions[i];
            const movement = Math.sqrt(
                Math.pow(current.x - last.x, 2) + Math.pow(current.y - last.y, 2)
            );
            totalMovement += movement;
        }

        // Update last positions
        this.lastHandPositions = hands.landmarks.map(h => ({ x: h[0].x, y: h[0].y }));

        // Return stability score (1.0 = very stable, 0.0 = very unstable)
        const avgMovement = totalMovement / hands.landmarks.length;
        return Math.max(0, Math.min(1, 1 - avgMovement * 20)); // Movement threshold
    }

    async start() {
        // 1. Init Camera
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: CONFIG.camera
            });
            this.video.srcObject = stream;
            await new Promise(r => this.video.onloadedmetadata = r);
            this.video.play();
            log("Camera Feed Established");
        } catch(e) {
            log("CAMERA ACCESS DENIED");
            return;
        }

        // 2. Init AI
        const progressBar = document.getElementById('progress-bar');
        await this.vision.init((percent) => {
            if(progressBar) progressBar.style.width = `${percent}%`;
        });
        
        // 3. Hide Loader
        setTimeout(() => {
            const loader = document.getElementById('loader');
            if(loader) loader.style.display = 'none';
            this.isRunning = true;
            this.loop();
        }, 500);
    }

    loop() {
        if(!this.isRunning) return;
        requestAnimationFrame(() => this.loop());

        const now = performance.now();
        const dt = now - this.lastFrameTime;
        this.lastFrameTime = now;
        this.frameCount++;

        // Calculate instantaneous FPS
        const instantFps = dt > 0 ? 1000 / dt : 0;
        
        // Add to history for averaging
        this.fpsHistory.push(instantFps);
        if (this.fpsHistory.length > this.fpsHistorySize) {
            this.fpsHistory.shift();
        }
        
        // Calculate average FPS
        const avgFps = this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length;
        this.fps = Math.round(avgFps);
        
        // Track min/max (reset every 5 seconds)
        if (now - this.lastFpsUpdate > 5000) {
            this.minFps = Infinity;
            this.maxFps = 0;
            this.lastFpsUpdate = now;
        }
        if (instantFps > 0 && instantFps < 200) { // Filter outliers
            this.minFps = Math.min(this.minFps, instantFps);
            this.maxFps = Math.max(this.maxFps, instantFps);
        }

        // 1. Vision Inference
        this.vision.detect(this.video, this.mode);

        // 2. Clear & Prep
        this.engine.clear();

        // 3. Render Base Video Layer
        if (this.mode !== 'MATRIX') {
             this.engine.drawVideo(this.video, this.mode);
        } else {
             this.engine.drawVideo(this.video, 'VOID'); // Black background for Matrix
        }

        // 4. Get hands data with GLOBAL PROCESSING PIPELINE
        const currentTime = performance.now() * 0.001;
        let hands = this.vision.results.hands;
        
        // 4a. Apply Grace Period (maintains tracking during brief loss)
        if (this.gracePeriod) {
            hands = this.gracePeriod.update(hands);
        }
        
        // 4b. Apply Global Landmark Smoothing (anti-jitter)
        if (this.smoother && hands && hands.landmarks) {
            const smoothedLandmarks = [];
            for (let i = 0; i < hands.landmarks.length; i++) {
                smoothedLandmarks[i] = this.smoother.smoothHand(i, hands.landmarks[i], currentTime);
            }
            hands = { ...hands, landmarks: smoothedLandmarks };
        }
        
        // 4c. Update Tracking Quality Meter
        if (this.qualityMeter) {
            this.qualityMeter.update(hands);
        }
        
        // 4d. Update Dynamic Quality Scaler
        if (this.qualityScaler) {
            this.qualityScaler.update(instantFps);
        }

        // 5. Auto Mode Detection
        this.detectAutoModes(hands);

        // 6. Render Mode Specifics

        switch(this.mode) {
            case 'STANDBY':
                // Just camera feed, no overlays
                break;
            case 'HUD':
                this.engine.drawSkeleton(hands, 'TACTICAL');
                break;
            case 'WIREFRAME':
                this.engine.drawSkeleton(hands, 'SIMPLE');
                break;
            case 'DRAW':
                this.engine.renderAirDraw(hands);
                this.engine.drawSkeleton(hands, 'SIMPLE');
                break;
            case 'MATRIX':
                this.engine.renderLidar(this.video, hands, this.vision.results.face);
                break;
            case 'INTEL':
                // Apply category filters to objects
                const filteredObjects = this.filterIntelObjects(this.vision.results.objects);
                
                // Filter 3D objects based on same categories
                const filtered3DObjects = this.vision.results.objects3D ? 
                    this.vision.results.objects3D.filter(obj => this.shouldDisplayObject(obj.category)) : [];
                
                // Render 3D bounding boxes with orientation (pass hands for anchor system)
                if (filtered3DObjects.length > 0) {
                    // Use full 3D rendering - pass hands data for orientation calculation
                    this.engine.renderIntel3D(filtered3DObjects, this.video, this.vision.results.hands);
                    // Skip 2D overlays when 3D boxes are active
                } else {
                    // Fallback to 2D overlays if no 3D data
                    this.engine.renderIntel(filteredObjects, this.video);
                }
                
                // Always render skeleton and HUD
                this.engine.drawSkeleton(hands, 'TACTICAL');
                this.engine.drawIntelHUD(filteredObjects);
                break;
            case 'VOID':
                this.engine.drawSkeleton(hands, 'TACTICAL');
                break;
            case 'DRONE':
                this.engine.drawSkeleton(hands, 'TACTICAL');
                break;
            case 'XRAY':
                this.engine.drawSkeleton(hands, 'TACTICAL');
                break;
            case 'FACE':
                this.engine.drawSkeleton(hands, 'TACTICAL');
                this.engine.renderFaceMesh(this.vision.results.face, 'TACTICAL');
                break;
            case 'CAROUSEL':
                // Draw high-tech 3D hand overlay for carousel interaction
                this.engine.renderCarouselHandFX3D(hands);
                // Also draw 2D overlay for additional detail
                this.engine.drawCarouselHandFX(hands);
                break;
            case 'SANDTABLE':
                // Update hologram with MediaPipe results
                this.engine.updateHologram({ hands: hands });
                // Render the 3D scene
                this.engine.renderer3D.render(this.engine.scene, this.engine.camera3D);
                break;
            case 'FLUID':
                if (this.fluidSystem) {
                    this.fluidSystem.update(hands);
                    this.fluidSystem.draw(this.engine.ctx);
                }
                // Overlay minimal skeleton
                this.engine.drawSkeleton(hands, 'SIMPLE');
                break;
            case 'TOUCH':
                // Holographic air touch mode - simplified for initial release
                try {
                    this.engine.updateTouchMode(hands);
                    // Render the 3D scene with touch effects
                    this.engine.renderer3D.render(this.engine.scene, this.engine.camera3D);
                } catch (error) {
                    console.warn('TOUCH mode error, falling back to basic render:', error);
                    // Fallback render without touch effects
                    this.engine.renderer3D.render(this.engine.scene, this.engine.camera3D);
                }

                // Draw hologram status indicators with persistence info
                this.engine.ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
                this.engine.ctx.font = '14px monospace';

                let yOffset = this.engine.canvas.height - 100;

                // Hologram status with lock indicator
                const opacity = this.engine.sandtableMesh?.material.uniforms.hologramOpacity.value || 0;
                const hologramActive = opacity > 0.05;
                const state = this.engine.sandtableState;

                if (hologramActive) {
                    // Lock status indicator
                    if (state.hologramLocked) {
                        this.engine.ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';
                        this.engine.ctx.fillText('🔒 HOLOGRAM LOCKED', 20, yOffset);
                    } else {
                        this.engine.ctx.fillStyle = 'rgba(255, 165, 0, 0.9)';
                        this.engine.ctx.fillText('⏳ HOLOGRAM STABILIZING', 20, yOffset);
                    }
                    yOffset += 20;

                    // Tracking status
                    const gracePercent = (state.trackingGraceFrames / state.maxGraceFrames) * 100;
                    if (gracePercent < 100) {
                        this.engine.ctx.fillStyle = `rgba(255, ${Math.floor(255 * gracePercent / 100)}, 0, 0.8)`;
                        this.engine.ctx.fillText(`TRACKING: ${Math.round(gracePercent)}%`, 20, yOffset);
                        yOffset += 18;
                    }

                    // Scale indicator
                    const scale = Math.round(this.engine.sandtableGroup.scale.x * 100) / 100;
                    this.engine.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    this.engine.ctx.fillText(`SCALE: ${scale}x`, 20, yOffset);
                    yOffset += 18;

                    // Sculpting indicator
                    if (this.engine.brushRing && this.engine.brushRing.visible) {
                        this.engine.ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';
                        this.engine.ctx.fillText('🎨 SCULPTING ACTIVE', 20, yOffset);
                    } else {
                        this.engine.ctx.fillStyle = 'rgba(200, 200, 200, 0.7)';
                        this.engine.ctx.fillText('Position right index to sculpt', 20, yOffset);
                    }
                } else {
                    this.engine.ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
                    this.engine.ctx.fillText('Hologram inactive - Show left palm', 20, yOffset);
                }

                yOffset += 25;
                this.engine.ctx.fillStyle = 'rgba(150, 150, 150, 0.5)';
                this.engine.ctx.font = '12px monospace';
                this.engine.ctx.fillText('Left hand: Position & Zoom | Right hand: Sculpt', 20, yOffset);
                yOffset += 15;
                this.engine.ctx.fillText('Hologram persists through brief tracking loss', 20, yOffset);
                break;
        }
        
        // 4b. Render Hand Particle System & Map (always active when enabled)
        if (hands && hands.landmarks && hands.landmarks.length > 0) {
            const deltaTime = dt / 1000; // Convert to seconds
            this.engine.renderHandParticleSystem(hands, deltaTime);
        }

        // 4c. Render Cube if active (independent of mode)
        if (this.cubeActive) {
            this.engine.renderCube(hands);
        }

        // 4d. Render Mini-Canvas Telemetry (always active)
        this.engine.renderThermal(this.video);
        this.engine.renderMoCap(hands, this.vision.results.face);

        // 4e. Update Hand Gesture Dragging (when in OPERATOR mode)
        if (this.mode === 'OPERATOR') {
            this.draggableSystem.updateHandDragging(hands, this.mode);
        }

        // 4f. Update Carousel System (when in CAROUSEL mode)
        if (this.mode === 'CAROUSEL') {
            this.carouselSystem.update(hands);
        }

        // 4g. Check for middle finger censorship gesture (always active)
        if (this.detectMiddleFingerGesture(hands)) {
            this.applyCensorship();
        }

        // 4h. Render Operator Panels (when in OPERATOR mode)
        if (this.mode === 'OPERATOR') {
            this.engine.renderRadar();
            this.engine.updateHexMatrix();
        }

        // 5. Update UI Stats (every 100ms for smoother updates)
        if (now - this.lastStatsUpdate > 100) {
            this.lastStatsUpdate = now;
            
            const fpsEl = document.getElementById('fps-counter');
            if(fpsEl) {
                fpsEl.innerText = this.fps;
                // Color code FPS
                if (this.fps >= 50) {
                    fpsEl.style.color = 'var(--secondary)'; // Green - good
                } else if (this.fps >= 25) {
                    fpsEl.style.color = 'var(--primary)'; // Cyan - okay
                } else {
                    fpsEl.style.color = 'var(--danger)'; // Red - bad
                }
            }
            
            const latEl = document.getElementById('latency-val');
            if(latEl) latEl.innerText = Math.round(dt);
            
            const fpsRangeEl = document.getElementById('fps-range');
            if(fpsRangeEl && this.minFps !== Infinity) {
                fpsRangeEl.innerText = `${Math.round(this.minFps)}-${Math.round(this.maxFps)}`;
            }
            
            const memEl = document.getElementById('mem-stat');
            if(memEl) {
                if (performance.memory) {
                    const usedMB = Math.round(performance.memory.usedJSHeapSize / 1048576);
                    const totalMB = Math.round(performance.memory.jsHeapSizeLimit / 1048576);
                    memEl.innerText = `${usedMB}/${totalMB} MB`;
                } else {
                    memEl.innerText = 'N/A';
                }
            }
        }
    }
}

// Start
// Since we are in a module, we can just start.
window.app = new TacticalOS();

</script>
</body>
</html>