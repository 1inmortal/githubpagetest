<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
<title>Video Sync Panel - Mejorado</title>

<style>

/* ------------ RESET ------------ */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
}

/* ------------ LAYOUT BASE ------------ */
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden; /* Prevenir scroll en toda la p√°gina */
  box-sizing: border-box;
}

body {
  background: linear-gradient(135deg, #0d0d0f 0%, #1a1a1f 100%);
  color: #d9d9d9;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  width: 100vw;
  padding: 16px;
  overflow: hidden;
  box-sizing: border-box;
  position: relative;
}

/* Overlay de fondo para transici√≥n suave */
.page-transition-backdrop {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: linear-gradient(135deg, #0d0d0f 0%, #1a1a1f 100%);
  z-index: -1;
  opacity: 0;
  transition: opacity 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  pointer-events: none;
}

body.page-entering .page-transition-backdrop,
body.page-exiting .page-transition-backdrop {
  opacity: 1;
}

/* Animaci√≥n de entrada: zoom desde el panel peque√±o - Optimizada con GPU */
body.page-entering .video-sync-module {
  animation: panelEnterAnimation 0.7s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
  will-change: transform, opacity, filter;
  backface-visibility: hidden;
  transform-style: preserve-3d;
}

/* Animaci√≥n de salida: zoom hacia el panel peque√±o - Optimizada con GPU */
body.page-exiting .video-sync-module {
  animation: panelExitAnimation 0.6s cubic-bezier(0.55, 0.055, 0.675, 0.19) forwards;
  will-change: transform, opacity, filter;
  backface-visibility: hidden;
  transform-style: preserve-3d;
}

/* Animaci√≥n de entrada alternativa (sin datos del panel) */
body.page-entering-no-origin .video-sync-module {
  animation: panelEnterFade 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
  will-change: transform, opacity;
}

@keyframes panelEnterFade {
  0% {
    transform: translate3d(0, 20px, 0) scale(0.95);
    opacity: 0;
  }
  100% {
    transform: translate3d(0, 0, 0) scale(1);
    opacity: 1;
  }
}

@keyframes panelEnterAnimation {
  0% {
    transform: translate3d(var(--origin-x, 0), var(--origin-y, 0), 0) scale(0.08);
    opacity: 0;
    filter: blur(20px);
    border-radius: 12px;
  }
  25% {
    transform: translate3d(calc(var(--origin-x, 0) * 0.6), calc(var(--origin-y, 0) * 0.6), 0) scale(0.4);
    opacity: 0.3;
    filter: blur(10px);
  }
  50% {
    transform: translate3d(calc(var(--origin-x, 0) * 0.3), calc(var(--origin-y, 0) * 0.3), 0) scale(0.75);
    opacity: 0.7;
    filter: blur(4px);
  }
  75% {
    transform: translate3d(calc(var(--origin-x, 0) * 0.1), calc(var(--origin-y, 0) * 0.1), 0) scale(1.02);
    opacity: 0.95;
    filter: blur(1px);
  }
  100% {
    transform: translate3d(0, 0, 0) scale(1);
    opacity: 1;
    filter: blur(0);
    border-radius: 16px;
  }
}

@keyframes panelExitAnimation {
  0% {
    transform: translate3d(0, 0, 0) scale(1);
    opacity: 1;
    filter: blur(0);
    border-radius: 16px;
  }
  25% {
    transform: translate3d(calc(var(--origin-x, 0) * 0.1), calc(var(--origin-y, 0) * 0.1), 0) scale(0.98);
    opacity: 0.95;
    filter: blur(1px);
  }
  50% {
    transform: translate3d(calc(var(--origin-x, 0) * 0.3), calc(var(--origin-y, 0) * 0.3), 0) scale(0.75);
    opacity: 0.7;
    filter: blur(4px);
  }
  75% {
    transform: translate3d(calc(var(--origin-x, 0) * 0.6), calc(var(--origin-y, 0) * 0.6), 0) scale(0.4);
    opacity: 0.3;
    filter: blur(10px);
  }
  100% {
    transform: translate3d(var(--origin-x, 0), var(--origin-y, 0), 0) scale(0.08);
    opacity: 0;
    filter: blur(20px);
    border-radius: 12px;
  }
}

/* Optimizaci√≥n para m√≥viles: reducir blur */
@media (max-width: 768px) {
  @keyframes panelEnterAnimation {
    0% {
      transform: translate3d(var(--origin-x, 0), var(--origin-y, 0), 0) scale(0.08);
      opacity: 0;
      filter: blur(8px);
      border-radius: 12px;
    }
    50% {
      transform: translate3d(calc(var(--origin-x, 0) * 0.3), calc(var(--origin-y, 0) * 0.3), 0) scale(0.75);
      opacity: 0.7;
      filter: blur(2px);
    }
    100% {
      transform: translate3d(0, 0, 0) scale(1);
      opacity: 1;
      filter: blur(0);
      border-radius: 16px;
    }
  }
  
  @keyframes panelExitAnimation {
    0% {
      transform: translate3d(0, 0, 0) scale(1);
      opacity: 1;
      filter: blur(0);
      border-radius: 16px;
    }
    50% {
      transform: translate3d(calc(var(--origin-x, 0) * 0.3), calc(var(--origin-y, 0) * 0.3), 0) scale(0.75);
      opacity: 0.7;
      filter: blur(2px);
    }
    100% {
      transform: translate3d(var(--origin-x, 0), var(--origin-y, 0), 0) scale(0.08);
      opacity: 0;
      filter: blur(8px);
      border-radius: 12px;
    }
  }
}

/* ------------ CONTENEDOR PRINCIPAL ------------ */
.video-sync-module {
  width: 100%;
  max-width: 1400px;
  display: grid;
  grid-template-columns: 2fr 1fr;
  gap: 20px;
  background: linear-gradient(145deg, #111114, #0f0f12);
  padding: 16px;
  border-radius: 16px;
  box-shadow: 0 8px 60px rgba(0,0,0,0.8), 0 0 0 1px rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.08);
  box-sizing: border-box;
  overflow: hidden;
  margin: auto;
  /* Asegurar que el contenido quepa en la pantalla */
  max-height: calc(100vh - 32px);
  height: calc(100vh - 32px);
  align-content: start;
  overflow-y: auto; /* Permitir scroll interno si es necesario */
  overflow-x: hidden;
  transform-origin: center center;
  position: relative;
  z-index: 1;
  /* Optimizaciones de rendimiento */
  contain: layout style paint;
  isolation: isolate;
  /* GPU acceleration */
  transform: translateZ(0);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* ------------ PANEL DE VIDEO ------------ */
.video-panel {
  display: flex;
  flex-direction: column;
  background: linear-gradient(160deg, #141416, #0c0c0d);
  border-radius: 12px;
  padding: 20px;
  position: relative;
  box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
  min-height: 0; /* Permite que el flex se ajuste */
  overflow: hidden;
}

.video-wrapper {
  position: relative;
  width: 100%;
  border-radius: 10px;
  overflow: hidden;
  background: #000;
  box-shadow: 0 4px 20px rgba(0,0,0,0.7);
}

video {
  width: 100%;
  max-width: 100%;
  height: auto;
  max-height: 60vh; /* Ajustar seg√∫n el espacio disponible */
  display: block;
  outline: none;
  border: 1px solid rgba(255,255,255,0.1);
  box-sizing: border-box;
  object-fit: contain; /* Mantener proporci√≥n sin recortar */
}

/* ------------ CONTROLES DE VIDEO ------------ */
.video-controls {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-top: 12px;
  padding: 8px 12px;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
  flex-wrap: wrap;
}

.speed-control {
  display: flex;
  align-items: center;
  gap: 6px;
}

.speed-control label {
  font-size: 11px;
  color: rgba(255,255,255,0.7);
  white-space: nowrap;
}

.speed-select {
  background: rgba(154, 255, 0, 0.15);
  color: #9AFF00;
  border: 1px solid rgba(154, 255, 0, 0.3);
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  outline: none;
  transition: all 0.2s ease;
}

.speed-select:hover {
  background: rgba(154, 255, 0, 0.25);
  border-color: rgba(154, 255, 0, 0.5);
}

.speed-select:focus {
  border-color: #9AFF00;
  box-shadow: 0 0 0 2px rgba(154, 255, 0, 0.2);
}

.autoplay-controls {
  margin-top: 12px;
  padding: 12px;
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
  border: 1px solid rgba(154, 255, 0, 0.1);
}

.autoplay-toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  user-select: none;
  font-size: 13px;
  color: rgba(255,255,255,0.9);
  font-weight: 500;
}

.autoplay-toggle input[type="checkbox"] {
  width: 18px;
  height: 18px;
  cursor: pointer;
  accent-color: #9AFF00;
}

.autoplay-settings {
  display: none;
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid rgba(154, 255, 0, 0.1);
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: rgba(255,255,255,0.7);
}

.autoplay-settings.active {
  display: flex;
}

.autoplay-settings input[type="number"] {
  background: rgba(154, 255, 0, 0.1);
  color: #9AFF00;
  border: 1px solid rgba(154, 255, 0, 0.3);
  padding: 4px 8px;
  border-radius: 4px;
  width: 60px;
  font-size: 12px;
  font-weight: 600;
  text-align: center;
  outline: none;
}

.autoplay-settings input[type="number"]:focus {
  border-color: #9AFF00;
  box-shadow: 0 0 0 2px rgba(154, 255, 0, 0.2);
}

.control-btn {
  background: rgba(154, 255, 0, 0.15);
  color: #9AFF00;
  border: 1px solid rgba(154, 255, 0, 0.3);
  padding: 8px 14px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 600;
  transition: all 0.2s ease;
  min-width: 80px;
}

.control-btn:hover {
  background: rgba(154, 255, 0, 0.25);
  transform: translateY(-1px);
}

.control-btn:active {
  transform: translateY(0);
}

.time-display {
  font-size: 12px;
  color: rgba(255,255,255,0.7);
  font-variant-numeric: tabular-nums;
  margin-left: auto;
}

/* ------------ TIMELINE MEJORADO ------------ */
.timeline-container {
  margin-top: 16px;
  position: relative;
}

#timeline {
  position: relative;
  height: 10px;
  background: rgba(255,255,255,0.08);
  border-radius: 5px;
  cursor: pointer;
  overflow: visible;
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
}

.timeline-progress {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  background: linear-gradient(90deg, #9AFF00, #7FE000);
  border-radius: 5px;
  width: 0%;
  transition: width 0.1s linear;
  box-shadow: 0 0 10px rgba(154, 255, 0, 0.4);
  z-index: 1;
}

/* Barra de progreso de checkpoints completados */
.timeline-checkpoints-progress {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  background: linear-gradient(90deg, rgba(127, 224, 0, 0.5), rgba(154, 255, 0, 0.4));
  border-radius: 5px;
  width: 0%;
  transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  z-index: 0;
  border-right: 3px solid rgba(154, 255, 0, 0.8);
  box-shadow: 0 0 8px rgba(127, 224, 0, 0.3);
  opacity: 0.8;
}

.timeline-marker {
  position: absolute;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 16px;
  height: 16px;
  background: #9AFF00;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  border: 2px solid #111114;
  box-shadow: 0 2px 8px rgba(154, 255, 0, 0.4), 0 0 0 0 rgba(154, 255, 0, 0);
  z-index: 2;
}

.timeline-marker:hover {
  transform: translate(-50%, -50%) scale(1.5);
  box-shadow: 0 4px 16px rgba(154, 255, 0, 0.6), 0 0 0 4px rgba(154, 255, 0, 0.2);
}

.timeline-marker.completed {
  background: #7FE000;
  box-shadow: 0 2px 8px rgba(127, 224, 0, 0.3);
}

.timeline-marker.active {
  background: #BFFF40;
  box-shadow: 0 0 20px rgba(191, 255, 64, 0.8);
  animation: pulse 2s infinite;
}

.timeline-marker.pending {
  background: rgba(154, 255, 0, 0.4);
  border-color: rgba(154, 255, 0, 0.6);
}

@keyframes pulse {
  0%, 100% { box-shadow: 0 0 20px rgba(191, 255, 64, 0.8); }
  50% { box-shadow: 0 0 30px rgba(191, 255, 64, 1); }
}

.marker-tooltip {
  position: absolute;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.9);
  color: #fff;
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 11px;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s ease;
  border: 1px solid rgba(154, 255, 0, 0.3);
}

.timeline-marker:hover .marker-tooltip {
  opacity: 1;
}

/* ------------ PANEL INFO MEJORADO ------------ */
.info-panel {
  background: linear-gradient(180deg, #131316, #0b0b0c);
  border-radius: 12px;
  padding: 24px;
  border: 1px solid rgba(255,255,255,0.07);
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
  min-height: 0; /* Permite que el flex se ajuste */
  overflow-y: auto; /* Scroll interno si es necesario */
  overflow-x: hidden;
  max-height: 100%;
}

#infoContent {
  flex: 1;
  padding: 16px;
  opacity: 0;
  transform: translateY(20px) scale(0.95);
  transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
  border-radius: 8px;
}

#infoContent.active {
  opacity: 1;
  transform: translateY(0) scale(1);
  background: rgba(154, 255, 0, 0.05);
  border: 1px solid rgba(154, 255, 0, 0.15);
}

#infoContent h2 {
  font-size: 24px;
  margin-bottom: 12px;
  color: #9AFF00;
  font-weight: 700;
  letter-spacing: -0.5px;
}

#infoContent p {
  font-size: 15px;
  line-height: 1.7;
  opacity: 0.9;
  color: #e0e0e0;
}

.checkpoint-counter {
  font-size: 12px;
  color: rgba(154, 255, 0, 0.6);
  margin-top: 8px;
  font-weight: 500;
}

/* Informaci√≥n contextual (mientras el video corre) */
#infoContent.contextual {
  background: rgba(154, 255, 0, 0.03);
  border: 1px solid rgba(154, 255, 0, 0.1);
  opacity: 0.7;
}

#infoContent.contextual p {
  font-size: 14px;
  opacity: 0.85;
  color: rgba(255, 255, 255, 0.8);
  font-style: italic;
}

/* Mensaje de bienvenida */
.welcome-message {
  animation: fadeInUp 0.5s ease;
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.welcome-message ul {
  list-style: none;
  padding-left: 0;
}

.welcome-message ul li {
  position: relative;
  padding-left: 20px;
}

.welcome-message ul li::before {
  content: "‚ñ∏";
  position: absolute;
  left: 0;
  color: #9AFF00;
  font-weight: bold;
}

/* Contador de auto-skip */
#autoSkipDisplay {
  position: absolute;
  top: 10px;
  right: 10px;
  background: rgba(154, 255, 0, 0.2);
  border: 2px solid #9AFF00;
  color: #9AFF00;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 12px;
  font-weight: bold;
  z-index: 1000;
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
  white-space: nowrap;
}

/* ------------ PANEL "PR√ìXIMAMENTE" ------------ */
.upcoming-panel {
  margin-top: 16px;
  padding: 16px;
  background: linear-gradient(135deg, rgba(154, 255, 0, 0.08), rgba(127, 224, 0, 0.05));
  border: 1px solid rgba(154, 255, 0, 0.2);
  border-radius: 10px;
  opacity: 0;
  transform: translateY(10px);
  transition: all 0.4s ease;
}

.upcoming-panel.show {
  opacity: 1;
  transform: translateY(0);
}

.upcoming-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.upcoming-label {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: rgba(154, 255, 0, 0.7);
  font-weight: 600;
}

.countdown-display {
  font-size: 32px;
  font-weight: 700;
  color: #9AFF00;
  font-variant-numeric: tabular-nums;
  text-shadow: 0 0 20px rgba(154, 255, 0, 0.5);
  animation: countdownPulse 1s ease-in-out infinite;
  min-width: 60px;
  text-align: right;
}

@keyframes countdownPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

.upcoming-content h3 {
  font-size: 16px;
  color: #9AFF00;
  margin-bottom: 8px;
  font-weight: 600;
}

.upcoming-content p {
  font-size: 13px;
  color: rgba(255,255,255,0.8);
  line-height: 1.5;
  margin-bottom: 12px;
}

.upcoming-progress-bar {
  height: 4px;
  background: rgba(255,255,255,0.1);
  border-radius: 2px;
  overflow: hidden;
  margin-top: 8px;
}

.upcoming-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #9AFF00, #7FE000);
  width: 0%;
  transition: width 0.3s ease;
  box-shadow: 0 0 8px rgba(154, 255, 0, 0.5);
}

/* ------------ PANEL DE ESTAD√çSTICAS ------------ */
.stats-panel {
  margin-top: 12px;
  padding: 12px;
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.05);
  opacity: 0;
  transform: translateY(5px);
  transition: all 0.3s ease;
}

.stats-panel.show {
  opacity: 1;
  transform: translateY(0);
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
}

.stat-item {
  text-align: center;
  padding: 8px;
  background: rgba(154, 255, 0, 0.05);
  border-radius: 6px;
  border: 1px solid rgba(154, 255, 0, 0.1);
}

.stat-value {
  font-size: 18px;
  font-weight: 700;
  color: #9AFF00;
  font-variant-numeric: tabular-nums;
  margin-bottom: 4px;
}

.stat-label {
  font-size: 10px;
  color: rgba(255,255,255,0.6);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* ------------ PANEL DE TIPS ROTATIVOS ------------ */
.tips-panel {
  margin-top: 12px;
  padding: 12px 16px;
  background: linear-gradient(135deg, rgba(154, 255, 0, 0.06), rgba(127, 224, 0, 0.03));
  border-left: 3px solid rgba(154, 255, 0, 0.4);
  border-radius: 6px;
  display: flex;
  gap: 12px;
  align-items: flex-start;
  opacity: 0;
  transform: translateX(-10px);
  transition: all 0.4s ease;
}

.tips-panel.show {
  opacity: 1;
  transform: translateX(0);
}

.tip-icon {
  font-size: 20px;
  flex-shrink: 0;
  animation: tipIconFloat 3s ease-in-out infinite;
}

@keyframes tipIconFloat {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-3px); }
}

.tip-content {
  flex: 1;
}

.tip-content p {
  font-size: 12px;
  color: rgba(255,255,255,0.85);
  line-height: 1.6;
  margin: 0;
  font-style: italic;
}

/* ------------ SISTEMA DE LOGROS ------------ */
.achievements-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 2000;
  display: flex;
  flex-direction: column;
  gap: 10px;
  pointer-events: none;
}

.achievement-badge {
  background: linear-gradient(135deg, #9AFF00, #7FE000);
  color: #111;
  padding: 12px 16px;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(154, 255, 0, 0.4);
  display: flex;
  align-items: center;
  gap: 10px;
  min-width: 250px;
  opacity: 0;
  transform: translateX(100px);
  animation: achievementSlideIn 0.5s ease forwards;
  pointer-events: auto;
}

@keyframes achievementSlideIn {
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.achievement-badge.fade-out {
  animation: achievementFadeOut 0.5s ease forwards;
}

@keyframes achievementFadeOut {
  to {
    opacity: 0;
    transform: translateX(100px);
  }
}

.achievement-icon {
  font-size: 24px;
  flex-shrink: 0;
}

.achievement-text {
  flex: 1;
}

.achievement-title {
  font-weight: 700;
  font-size: 13px;
  margin-bottom: 2px;
}

.achievement-desc {
  font-size: 11px;
  opacity: 0.8;
}

/* Animaciones de fondo sutiles */
.info-panel {
  position: relative;
  overflow: hidden;
}

.info-panel::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, rgba(154, 255, 0, 0.03) 0%, transparent 70%);
  animation: backgroundPulse 8s ease-in-out infinite;
  pointer-events: none;
  z-index: 0;
}

@keyframes backgroundPulse {
  0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.3; }
  50% { transform: translate(10px, 10px) scale(1.1); opacity: 0.5; }
}

.info-panel > * {
  position: relative;
  z-index: 1;
}

/* ------------ BOTONES MEJORADOS ------------ */
.button-group {
  display: flex;
  gap: 10px;
  margin-top: 20px;
}

button {
  background: linear-gradient(135deg, #9AFF00, #7FE000);
  color: #111;
  padding: 14px 20px;
  border: none;
  border-radius: 8px;
  font-weight: 700;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 4px 12px rgba(154, 255, 0, 0.3);
  flex: 1;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(154, 255, 0, 0.4);
  background: linear-gradient(135deg, #BFFF40, #9AFF00);
}

button:active {
  transform: translateY(0);
}

button.secondary {
  background: rgba(255,255,255,0.1);
  color: #fff;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

button.secondary:hover {
  background: rgba(255,255,255,0.15);
  box-shadow: 0 6px 20px rgba(0,0,0,0.4);
}

.hidden {
  display: none !important;
}

/* ------------ MENSAJES DE ERROR ------------ */
.error-message {
  background: rgba(255, 50, 50, 0.1);
  border: 1px solid rgba(255, 50, 50, 0.3);
  color: #ff6b6b;
  padding: 12px;
  border-radius: 8px;
  margin-top: 12px;
  font-size: 13px;
  display: none;
}

.error-message.show {
  display: block;
  animation: slideIn 0.3s ease;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* ------------ LOADING STATE ------------ */
.loading {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 40px;
  color: rgba(255,255,255,0.5);
  font-size: 14px;
}

/* ------------ RESPONSIVE MEJORADO ------------ */
@media(max-width: 1000px) {
  .video-sync-module {
    grid-template-columns: 1fr;
    padding: 16px;
    max-height: calc(100vh - 32px);
    height: calc(100vh - 32px);
  }
  
  video {
    max-height: 50vh;
  }
  
  .button-group {
    flex-direction: column;
  }
  
  #infoContent h2 {
    font-size: 20px;
  }
  
  .video-controls {
    flex-wrap: wrap;
    gap: 8px;
  }
  
  .speed-control {
    order: 3;
    width: 100%;
    justify-content: space-between;
    margin-top: 8px;
  }
  
  .time-display {
    order: 4;
    width: 100%;
    text-align: center;
    margin-top: 4px;
  }
}

@media(max-width: 768px) {
  .video-sync-module {
    padding: 12px;
    gap: 12px;
    max-height: calc(100vh - 24px);
    height: calc(100vh - 24px);
  }
  
  video {
    max-height: 45vh;
  }
  
  .video-panel,
  .info-panel {
    padding: 12px;
  }
  
  .autoplay-controls {
    padding: 10px;
  }
  
  .autoplay-settings {
    flex-wrap: wrap;
    gap: 6px;
  }
  
  .autoplay-settings input[type="number"] {
    width: 50px;
  }
  
  #infoContent h2 {
    font-size: 20px;
  }
  
  #infoContent p {
    font-size: 14px;
  }
}

@media(max-width: 600px) {
  body {
    padding: 0;
  }
  
  .video-sync-module {
    padding: 10px;
    gap: 10px;
    border-radius: 12px;
    max-height: 100vh;
    height: 100vh;
  }
  
  video {
    max-height: 40vh;
  }
  
  .video-panel,
  .info-panel {
    padding: 12px;
    border-radius: 10px;
  }
  
  .video-controls {
    padding: 6px 10px;
    gap: 6px;
  }
  
  .control-btn {
    padding: 10px 14px;
    font-size: 13px;
    min-width: 80px;
    flex: 1;
    min-height: 44px; /* √Årea t√°ctil m√≠nima recomendada */
  }
  
  .speed-control {
    width: 100%;
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(255,255,255,0.1);
  }
  
  .speed-control label {
    font-size: 12px;
  }
  
  .speed-select {
    padding: 8px 12px;
    font-size: 13px;
    flex: 1;
    min-height: 44px;
  }
  
  .time-display {
    font-size: 11px;
    width: 100%;
    text-align: center;
    margin-top: 8px;
  }
  
  .autoplay-controls {
    padding: 10px;
    font-size: 12px;
  }
  
  .autoplay-toggle {
    font-size: 13px;
  }
  
  .autoplay-toggle input[type="checkbox"] {
    width: 20px;
    height: 20px;
    min-width: 20px;
    min-height: 20px;
  }
  
  .autoplay-settings {
    font-size: 11px;
    gap: 6px;
  }
  
  .autoplay-settings input[type="number"] {
    width: 55px;
    padding: 6px;
    font-size: 13px;
    min-height: 36px;
  }
  
  .timeline-container {
    margin-top: 12px;
  }
  
  #timeline {
    height: 12px; /* M√°s alto para mejor interacci√≥n t√°ctil */
  }
  
  .timeline-marker {
    width: 18px;
    height: 18px;
    top: 50%;
    transform: translate(-50%, -50%);
  }
  
  .timeline-marker:hover {
    transform: translate(-50%, -50%) scale(1.3);
  }
  
  #infoContent {
    padding: 12px;
  }
  
  #infoContent h2 {
    font-size: 18px;
    margin-bottom: 10px;
  }
  
  #infoContent p {
    font-size: 13px;
    line-height: 1.6;
  }
  
  .checkpoint-counter {
    font-size: 11px;
    margin-top: 6px;
  }
  
  button {
    padding: 12px 16px;
    font-size: 13px;
    min-height: 44px; /* √Årea t√°ctil m√≠nima */
    letter-spacing: 0.3px;
  }
  
  .button-group {
    gap: 8px;
    margin-top: 16px;
  }
  
  /* Contador de auto-skip m√°s peque√±o en m√≥vil */
  #autoSkipDisplay {
    top: 8px !important;
    right: 8px !important;
    padding: 6px 10px !important;
    font-size: 11px !important;
  }
}

@media(max-width: 400px) {
  .video-sync-module {
    padding: 10px;
    gap: 10px;
  }
  
  .video-panel,
  .info-panel {
    padding: 10px;
  }
  
  .control-btn {
    font-size: 12px;
    padding: 8px 12px;
    min-width: 70px;
  }
  
  #infoContent h2 {
    font-size: 16px;
  }
  
  #infoContent p {
    font-size: 12px;
  }
  
  button {
    font-size: 12px;
    padding: 10px 14px;
  }
}

/* Mejoras para orientaci√≥n landscape en m√≥vil */
@media(max-width: 900px) and (orientation: landscape) {
  .video-sync-module {
    grid-template-columns: 1fr;
    max-height: 100vh;
    overflow-y: auto;
  }
  
  .video-panel {
    max-height: 50vh;
  }
  
  video {
    max-height: 40vh;
    object-fit: contain;
  }
}

/* Mejoras para tablets */
@media(min-width: 601px) and (max-width: 1024px) {
  .video-sync-module {
    padding: 20px;
  }
  
  .control-btn {
    padding: 10px 16px;
    font-size: 13px;
  }
  
  .speed-select {
    padding: 8px 12px;
  }
}

</style>
</head>

<body>

<section class="video-sync-module">

  <!-- PANEL VIDEO -->
  <div class="video-panel">
    <div class="video-wrapper">
      <video id="mainVideo" preload="metadata"></video>
    </div>
    
    <div class="video-controls">
      <button class="control-btn" id="playPauseBtn">‚ñ∂ Reproducir</button>
      <button class="control-btn secondary" id="resetBtn">‚Üª Reiniciar</button>
      <div class="speed-control">
        <label for="speedSelect">Velocidad:</label>
        <select id="speedSelect" class="speed-select">
          <option value="0.5">0.5x</option>
          <option value="1" selected>1x</option>
          <option value="1.5">1.5x</option>
          <option value="2">2x</option>
        </select>
      </div>
      <div class="time-display">
        <span id="currentTime">0:00</span> / <span id="duration">0:00</span>
      </div>
    </div>
    
    <div class="autoplay-controls">
      <label class="autoplay-toggle">
        <input type="checkbox" id="autoplayToggle">
        <span>Modo Auto-play</span>
      </label>
      <div class="autoplay-settings" id="autoplaySettings">
        <label for="autoSkipTime">Auto-skip despu√©s de:</label>
        <input type="number" id="autoSkipTime" min="0" max="60" value="5" step="1">
        <span>segundos</span>
      </div>
    </div>
    
    <div class="timeline-container">
      <div id="timeline">
        <div class="timeline-progress" id="timelineProgress"></div>
      </div>
    </div>
    
    <div class="error-message" id="errorMessage"></div>
  </div>

  <!-- PANEL INFO -->
  <div class="info-panel">
    <div id="infoContent">
      <div class="loading">Cargando video...</div>
    </div>
    
    <!-- Panel "Pr√≥ximamente" - Se muestra mientras se reproduce -->
    <div id="upcomingPanel" class="upcoming-panel hidden">
      <div class="upcoming-header">
        <span class="upcoming-label">Pr√≥ximamente</span>
        <div class="countdown-display" id="countdownDisplay">--</div>
      </div>
      <div class="upcoming-content">
        <h3 id="upcomingTitle">Cargando...</h3>
        <p id="upcomingDescription">Preparando siguiente checkpoint...</p>
        <div class="upcoming-progress-bar">
          <div class="upcoming-progress-fill" id="upcomingProgressFill"></div>
        </div>
      </div>
    </div>
    
    <!-- Panel de estad√≠sticas -->
    <div id="statsPanel" class="stats-panel hidden">
      <div class="stats-grid">
        <div class="stat-item">
          <div class="stat-value" id="statCheckpoints">0/0</div>
          <div class="stat-label">Checkpoints</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="statProgress">0%</div>
          <div class="stat-label">Progreso</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="statTimeWatched">0:00</div>
          <div class="stat-label">Tiempo visto</div>
        </div>
      </div>
    </div>
    
    <!-- Panel de tips rotativos -->
    <div id="tipsPanel" class="tips-panel hidden">
      <div class="tip-icon">üí°</div>
      <div class="tip-content">
        <p id="tipText">Cargando tips...</p>
      </div>
    </div>
    
    <!-- Sistema de logros -->
    <div id="achievementsContainer" class="achievements-container"></div>
    
    <div class="button-group">
      <button id="nextBtn" class="hidden">Siguiente punto</button>
      <button id="replayBtn" class="hidden secondary">Repetir</button>
    </div>
  </div>

</section>


<script>

/* ----------------------------------------------------
   ANIMACIONES DE ENTRADA/SALIDA
   ---------------------------------------------------- */
(function() {
  // Obtener informaci√≥n del panel original desde sessionStorage
  const panelOriginData = sessionStorage.getItem('panelOrigin');
  
  const body = document.body;
  const module = document.querySelector('.video-sync-module');
  
  // Crear backdrop de transici√≥n
  const backdrop = document.createElement('div');
  backdrop.className = 'page-transition-backdrop';
  document.body.appendChild(backdrop);
  
  // Detectar si es m√≥vil para optimizaciones
  const isMobile = window.innerWidth < 768;
  
  function initAnimation() {
    if (panelOriginData) {
      try {
        const origin = JSON.parse(panelOriginData);
        
        if (module) {
          // Calcular posici√≥n relativa desde el centro de la pantalla
          const screenCenterX = window.innerWidth / 2;
          const screenCenterY = window.innerHeight / 2;
          
          // Calcular offset desde el centro hasta el panel original
          const originX = origin.x - screenCenterX;
          const originY = origin.y - screenCenterY;
          
          // Aplicar variables CSS para la animaci√≥n
          document.documentElement.style.setProperty('--origin-x', `${originX}px`);
          document.documentElement.style.setProperty('--origin-y', `${originY}px`);
          
          // Activar backdrop primero
          requestAnimationFrame(() => {
            backdrop.style.opacity = '1';
            
            // Agregar clase de entrada en el siguiente frame para mejor sincronizaci√≥n
            requestAnimationFrame(() => {
              body.classList.add('page-entering');
              
              // Remover will-change despu√©s de la animaci√≥n para mejor rendimiento
              setTimeout(() => {
                body.classList.remove('page-entering');
                module.style.willChange = 'auto';
                backdrop.style.opacity = '0';
              }, 700);
            });
          });
        }
      } catch (e) {
        console.warn('Error al procesar datos del panel original:', e);
        // Fallback: animaci√≥n simple
        if (module) {
          requestAnimationFrame(() => {
            backdrop.style.opacity = '1';
            body.classList.add('page-entering-no-origin');
            setTimeout(() => {
              body.classList.remove('page-entering-no-origin');
              module.style.willChange = 'auto';
              backdrop.style.opacity = '0';
            }, 500);
          });
        }
      }
    } else {
      // Si no hay datos del panel, usar animaci√≥n simple
      if (module) {
        requestAnimationFrame(() => {
          backdrop.style.opacity = '1';
          body.classList.add('page-entering-no-origin');
          setTimeout(() => {
            body.classList.remove('page-entering-no-origin');
            module.style.willChange = 'auto';
            backdrop.style.opacity = '0';
          }, 500);
        });
      }
    }
  }
  
  // Inicializar cuando el DOM est√© listo
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAnimation);
  } else {
    initAnimation();
  }
  
  // Detectar cuando se va a salir de la p√°gina - Optimizado
  window.addEventListener('beforeunload', () => {
    if (module && panelOriginData) {
      requestAnimationFrame(() => {
        backdrop.style.opacity = '1';
        body.classList.add('page-exiting');
        if (module) {
          module.style.willChange = 'transform, opacity, filter';
        }
      });
    }
  }, { passive: true });
  
  // Tambi√©n detectar navegaci√≥n hacia atr√°s
  window.addEventListener('popstate', () => {
    if (module && panelOriginData) {
      requestAnimationFrame(() => {
        backdrop.style.opacity = '1';
        body.classList.add('page-exiting');
        if (module) {
          module.style.willChange = 'transform, opacity, filter';
        }
        
        setTimeout(() => {
          if (module) {
            module.style.willChange = 'auto';
          }
          window.history.back();
        }, 600);
      });
    }
  }, { passive: true });
  
  // Optimizaci√≥n: Preload de recursos cr√≠ticos
  if ('requestIdleCallback' in window) {
    requestIdleCallback(() => {
      // Pre-cargar recursos si est√°n disponibles
      const video = document.getElementById('mainVideo');
      if (video && video.src) {
        video.preload = 'metadata';
      }
    });
  }
  
  // Optimizaci√≥n: Reducir repaints durante scroll
  let scrollTimeout;
  const scrollModule = document.querySelector('.video-sync-module');
  if (scrollModule) {
    scrollModule.addEventListener('scroll', () => {
      if (!scrollTimeout) {
        scrollModule.style.willChange = 'scroll-position';
      }
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        scrollModule.style.willChange = 'auto';
        scrollTimeout = null;
      }, 150);
    }, { passive: true });
  }
  
  // Bot√≥n de cerrar/volver
  function createCloseButton() {
    // Verificar si ya existe
    if (document.getElementById('panel-close-btn')) return;
    
    const closeBtn = document.createElement('button');
    closeBtn.id = 'panel-close-btn';
    closeBtn.innerHTML = '‚úï';
    closeBtn.setAttribute('aria-label', 'Cerrar panel');
    closeBtn.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      width: 44px;
      height: 44px;
      background: rgba(15, 15, 15, 0.9);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      color: #9AFF00;
      font-size: 24px;
      cursor: pointer;
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      font-family: Arial, sans-serif;
      line-height: 1;
    `;
    
    // Optimizaci√≥n: usar transform3d para mejor rendimiento
    closeBtn.addEventListener('mouseenter', () => {
      requestAnimationFrame(() => {
        closeBtn.style.background = 'rgba(154, 255, 0, 0.2)';
        closeBtn.style.borderColor = '#9AFF00';
        closeBtn.style.transform = 'translate3d(0, 0, 0) rotate(90deg) scale(1.1)';
        closeBtn.style.boxShadow = '0 6px 20px rgba(154, 255, 0, 0.4)';
      });
    });
    
    closeBtn.addEventListener('mouseleave', () => {
      requestAnimationFrame(() => {
        closeBtn.style.background = 'rgba(15, 15, 15, 0.9)';
        closeBtn.style.borderColor = 'rgba(255,255,255,0.1)';
        closeBtn.style.transform = 'translate3d(0, 0, 0) rotate(0deg) scale(1)';
        closeBtn.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
      });
    });
    
    // Soporte t√°ctil mejorado para m√≥viles
    let touchStartTime = 0;
    closeBtn.addEventListener('touchstart', (e) => {
      touchStartTime = Date.now();
      closeBtn.style.transform = 'translate3d(0, 0, 0) scale(0.95)';
    }, { passive: true });
    
    closeBtn.addEventListener('touchend', (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (touchDuration < 200) { // Tap r√°pido
        closeBtn.click();
      }
      closeBtn.style.transform = 'translate3d(0, 0, 0) scale(1)';
    }, { passive: true });
    
    closeBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      const body = document.body;
      const module = document.querySelector('.video-sync-module');
      
      // Activar backdrop y animaci√≥n de salida
      requestAnimationFrame(() => {
        backdrop.style.opacity = '1';
        body.classList.add('page-exiting');
        
        // Prevenir interacciones durante la animaci√≥n
        document.body.style.pointerEvents = 'none';
        
        // Asegurar will-change para mejor rendimiento
        if (module) {
          module.style.willChange = 'transform, opacity, filter';
        }
        
        setTimeout(() => {
          // Limpiar will-change
          if (module) {
            module.style.willChange = 'auto';
          }
          
          // Intentar volver atr√°s, si no funciona, ir al index
          if (window.history.length > 1) {
            window.history.back();
          } else {
            // Calcular ruta relativa al index
            const currentPath = window.location.pathname;
            const depth = (currentPath.match(/\//g) || []).length - 1;
            const backPath = '../'.repeat(depth) + 'index.html';
            window.location.href = backPath;
          }
        }, 600);
      });
    });
    
    document.body.appendChild(closeBtn);
  }
  
  // Crear bot√≥n cuando el DOM est√© listo
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', createCloseButton);
  } else {
    createCloseButton();
  }
})();

/* ----------------------------------------------------
   CHECKPOINTS: aqu√≠ defines los tiempos y el contenido
   ---------------------------------------------------- */
const checkpoints = [
  {
    time: 10,
    title: "Inicializaci√≥n del Sistema",
    text: "El sistema de Visi√≥n por Computadora inicia la detecci√≥n de objetos multiclase. Observa los cuadros delimitadores de colores: üü® Amarillo (Autos), üüß Naranja (Camiones), üü© Verde (Motocicletas), ‚¨ú Blanco (Autobuses). Cada veh√≠culo recibe un ID √∫nico para seguimiento continuo."
  },
  {
    time: 45,
    title: "Detecci√≥n de Oclusi√≥n",
    text: "El sistema demuestra su capacidad para detectar veh√≠culos parcialmente ocultos detr√°s de postes o estructuras de la gasolinera JOMAR. Los vectores rojos muestran la direcci√≥n y velocidad de desplazamiento en tiempo real."
  },
  {
    time: 60,
    title: "Seguimiento de Tr√°fico Pesado",
    text: "Vista de la rotonda: el sistema detecta con precisi√≥n veh√≠culos largos (autobuses y camiones). Los cuadros delimitadores se ajustan din√°micamente al tama√±o del objeto. El ID tracking mantiene la identidad de los veh√≠culos incluso cuando giran en la rotonda."
  },
  {
    time: 90,
    title: "Robustez ante Cambios de Iluminaci√≥n",
    text: "El algoritmo demuestra robustez ante cambios de luz y sombras alargadas. No confunde las sombras de los postes con veh√≠culos, manteniendo la detecci√≥n precisa sobre los objetos f√≠sicos. Se observa el monitoreo de la entrada y salida de la tienda de conveniencia."
  },
  {
    time: 135,
    title: "Vista de Gran Angular y Alta Densidad",
    text: "El dron toma altura mostrando una vista m√°s amplia. El sistema procesa decenas de veh√≠culos simult√°neamente en ambos carriles sin lag aparente (59-60 FPS estables). El panel derecho muestra el radar 360 con mapa de calor de la densidad de objetos."
  },
  {
    time: 180,
    title: "Clasificaci√≥n Avanzada",
    text: "El sistema distingue entre veh√≠culos estacionados vs. veh√≠culos en movimiento. Las estad√≠sticas en vivo (panel izquierdo) muestran contadores din√°micos de camiones, autos, sem√°foros y motocicletas detectados. Sistema de vigilancia a√©rea de grado industrial."
  }
];


/* ----------------------------------------------------
   VARIABLES GLOBALES
   ---------------------------------------------------- */
let currentCheckpoint = 0;
let checkpointTriggered = new Set();
let isPausedByCheckpoint = false;
let markers = [];

const video = document.getElementById("mainVideo");

// Detectar ruta base autom√°ticamente para el video
(function() {
  const currentPath = window.location.pathname;
  const videoFileName = 'captura.mp4';
  
  // Lista de rutas a probar en orden de prioridad
  const videoPaths = [];
  
  // 1. Ruta relativa (m√°s confiable - panel.html y mp4/ est√°n en el mismo directorio)
  videoPaths.push('mp4/' + videoFileName);
  
  // 2. Ruta relativa con ./ expl√≠cito
  videoPaths.push('./mp4/' + videoFileName);
  
  // 3. Construir ruta basada en la URL actual
  const currentUrl = new URL(window.location.href);
  const currentDir = currentUrl.pathname.substring(0, currentUrl.pathname.lastIndexOf('/') + 1);
  videoPaths.push(currentDir + 'mp4/' + videoFileName);
  
  // 4. Detectar si estamos en GitHub Pages con subdirectorio
  let basePath = '';
  if (currentPath.includes('/githubpagetest/')) {
    basePath = '/githubpagetest';
  }
  
  // 5. Ruta absoluta con basePath
  if (basePath) {
    videoPaths.push(basePath + '/public/gsap/PR/mp4/' + videoFileName);
  }
  
  // 6. Ruta absoluta sin basePath
  videoPaths.push('/public/gsap/PR/mp4/' + videoFileName);
  
  // 7. Ruta relativa desde la ra√≠z del sitio
  videoPaths.push('public/gsap/PR/mp4/' + videoFileName);
  
  // Funci√≥n para intentar cargar el video
  let currentPathIndex = 0;
  let isLoading = false;
  
  function tryLoadVideo() {
    if (currentPathIndex >= videoPaths.length) {
      console.error('No se pudo cargar el video desde ninguna ruta. Rutas probadas:', videoPaths);
      if (typeof showError === 'function') {
        showError('No se pudo cargar el video. Verifica que el archivo existe en: mp4/captura.mp4');
      }
      return;
    }
    
    if (isLoading) return;
    isLoading = true;
    
    const pathToTry = videoPaths[currentPathIndex];
    console.log(`Intentando cargar video desde: ${pathToTry}`);
    
    // Remover listeners anteriores
    video.removeEventListener('error', onVideoError);
    video.removeEventListener('loadeddata', onVideoLoaded);
    
    // Agregar listeners para este intento
    video.addEventListener('error', onVideoError, { once: true });
    video.addEventListener('loadeddata', onVideoLoaded, { once: true });
    
    video.src = pathToTry;
    video.load();
  }
  
  function onVideoError(e) {
    isLoading = false;
    const failedPath = videoPaths[currentPathIndex];
    console.warn(`‚ùå Error al cargar desde: ${failedPath}`);
    console.warn(`   URL completa: ${new URL(failedPath, window.location.href).href}`);
    console.warn(`   Error code: ${video.error ? video.error.code : 'unknown'}`);
    currentPathIndex++;
    setTimeout(() => {
      tryLoadVideo();
    }, 100);
  }
  
  function onVideoLoaded() {
    isLoading = false;
    const successfulPath = video.src;
    console.log('‚úì Video cargado exitosamente desde:', successfulPath);
    console.log('  URL completa:', new URL(successfulPath, window.location.href).href);
  }
  
  // Mostrar informaci√≥n de depuraci√≥n
  console.log('üîç Iniciando carga de video. Rutas a probar:');
  videoPaths.forEach((path, index) => {
    console.log(`   ${index + 1}. ${path}`);
  });
  console.log(`üìç URL actual: ${window.location.href}`);
  console.log(`üìÇ Directorio actual: ${currentDir}`);
  
  // Intentar cargar con la primera ruta
  tryLoadVideo();
})();

const info = document.getElementById("infoContent");
const nextBtn = document.getElementById("nextBtn");
const replayBtn = document.getElementById("replayBtn");
const timeline = document.getElementById("timeline");
const timelineProgress = document.getElementById("timelineProgress");
const playPauseBtn = document.getElementById("playPauseBtn");
const resetBtn = document.getElementById("resetBtn");
const currentTimeDisplay = document.getElementById("currentTime");
const durationDisplay = document.getElementById("duration");
const errorMessage = document.getElementById("errorMessage");
const speedSelect = document.getElementById("speedSelect");
const autoplayToggle = document.getElementById("autoplayToggle");
const autoplaySettings = document.getElementById("autoplaySettings");
const autoSkipTimeInput = document.getElementById("autoSkipTime");

// Variables de auto-play
let autoplayEnabled = false;
let autoSkipTimer = null;
let autoSkipTime = 5; // segundos por defecto

// Variables para paneles de entretenimiento
const upcomingPanel = document.getElementById("upcomingPanel");
const countdownDisplay = document.getElementById("countdownDisplay");
const upcomingTitle = document.getElementById("upcomingTitle");
const upcomingDescription = document.getElementById("upcomingDescription");
const upcomingProgressFill = document.getElementById("upcomingProgressFill");
const statsPanel = document.getElementById("statsPanel");
const statCheckpoints = document.getElementById("statCheckpoints");
const statProgress = document.getElementById("statProgress");
const statTimeWatched = document.getElementById("statTimeWatched");
const tipsPanel = document.getElementById("tipsPanel");
const tipText = document.getElementById("tipText");
const achievementsContainer = document.getElementById("achievementsContainer");

// Variables para tips y estad√≠sticas
let tipsIndex = 0;
let statsUpdateInterval = null;
let countdownInterval = null;
let startTime = null;
let totalTimeWatched = 0;

// Variables para persistencia
let totalTimeWatchedAccumulated = 0; // Tiempo total acumulado entre sesiones
let lastCheckpointReached = 0; // √öltimo checkpoint alcanzado
const STORAGE_KEY = 'videoSyncProgress';

// Tips relacionados con visi√≥n por computadora y drones
const tips = [
  "üí° Los sistemas de visi√≥n por computadora pueden procesar hasta 60 FPS en tiempo real.",
  "üîç La detecci√≥n de objetos multiclase permite identificar diferentes tipos de veh√≠culos simult√°neamente.",
  "üìä El ID tracking mantiene la identidad de objetos incluso cuando se ocultan parcialmente.",
  "üéØ Los vectores de movimiento muestran direcci√≥n y velocidad estimada de los objetos detectados.",
  "üåê El radar 360 proporciona una vista abstracta de la densidad de objetos sin ruido visual.",
  "‚ö° Los algoritmos modernos son robustos ante cambios de iluminaci√≥n y sombras.",
  "üöÅ Los drones t√°cticos pueden monitorear √°reas extensas desde el aire sin ser detectados.",
  "üìà Las estad√≠sticas en tiempo real permiten an√°lisis inmediato del tr√°fico y movimiento.",
  "üé® Los colores en los cuadros delimitadores ayudan a clasificar r√°pidamente los objetos.",
  "üî¨ La visi√≥n por computadora combina aprendizaje autom√°tico y procesamiento de im√°genes."
];

// Logros disponibles
const achievements = [
  { id: "first", icon: "üéØ", title: "Primer Checkpoint", desc: "Completaste tu primer an√°lisis" },
  { id: "halfway", icon: "üìä", title: "A mitad de camino", desc: "Completaste la mitad de los checkpoints" },
  { id: "expert", icon: "üèÜ", title: "Experto en CV", desc: "Completaste todos los checkpoints" },
  { id: "speed", icon: "‚ö°", title: "Velocidad", desc: "Completaste un checkpoint en menos de 30 segundos" }
];


/* ----------------------------------------------------
   UTILIDADES
   ---------------------------------------------------- */
function formatTime(seconds) {
  if (!isFinite(seconds) || isNaN(seconds)) return "0:00";
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function showError(message) {
  errorMessage.textContent = message;
  errorMessage.classList.add("show");
  setTimeout(() => {
    errorMessage.classList.remove("show");
  }, 5000);
}

function updateTimeDisplay() {
  currentTimeDisplay.textContent = formatTime(video.currentTime);
  if (video.duration) {
    durationDisplay.textContent = formatTime(video.duration);
  }
}

/* ----------------------------------------------------
   SISTEMA DE PERSISTENCIA (LOCALSTORAGE)
   ---------------------------------------------------- */
function saveProgress() {
  try {
    // Calcular tiempo total visto (acumulado de sesiones anteriores + tiempo actual de esta sesi√≥n)
    const currentSessionTime = video.currentTime || 0;
    const totalTimeToSave = totalTimeWatchedAccumulated + currentSessionTime;
    
    const progressData = {
      checkpointsCompleted: Array.from(checkpointTriggered),
      achievementsUnlocked: Array.from(achievementsShown),
      totalTimeWatched: totalTimeToSave,
      lastCheckpointReached: currentCheckpoint,
      lastUpdate: Date.now(),
      videoDuration: video.duration || 0
    };
    
    localStorage.setItem(STORAGE_KEY, JSON.stringify(progressData));
  } catch (e) {
    console.warn('No se pudo guardar el progreso:', e);
  }
}

function loadProgress() {
  try {
    const savedData = localStorage.getItem(STORAGE_KEY);
    if (!savedData) return null;
    
    const progressData = JSON.parse(savedData);
    return progressData;
  } catch (e) {
    console.warn('No se pudo cargar el progreso:', e);
    return null;
  }
}

function restoreProgress() {
  const savedData = loadProgress();
  if (!savedData) return false;
  
  // Restaurar checkpoints completados
  if (savedData.checkpointsCompleted && Array.isArray(savedData.checkpointsCompleted)) {
    savedData.checkpointsCompleted.forEach(index => {
      if (index >= 0 && index < checkpoints.length) {
        checkpointTriggered.add(index);
      }
    });
  }
  
  // Restaurar logros
  if (savedData.achievementsUnlocked && Array.isArray(savedData.achievementsUnlocked)) {
    savedData.achievementsUnlocked.forEach(achievementId => {
      achievementsShown.add(achievementId);
    });
  }
  
  // Restaurar tiempo total visto acumulado
  // El tiempo guardado es el total acumulado hasta ahora
  if (savedData.totalTimeWatched !== undefined) {
    totalTimeWatchedAccumulated = savedData.totalTimeWatched;
  }
  
  // Restaurar √∫ltimo checkpoint alcanzado
  if (savedData.lastCheckpointReached !== undefined) {
    lastCheckpointReached = savedData.lastCheckpointReached;
    currentCheckpoint = Math.max(0, savedData.lastCheckpointReached);
  }
  
  return true;
}

function showProgressRestored() {
  const savedData = loadProgress();
  if (!savedData) return;
  
  const completed = savedData.checkpointsCompleted ? savedData.checkpointsCompleted.length : 0;
  const total = checkpoints.length;
  const progressPercent = total > 0 ? Math.round((completed / total) * 100) : 0;
  
  if (completed > 0) {
    // Mostrar notificaci√≥n de progreso restaurado
    const notification = document.createElement("div");
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #9AFF00, #7FE000);
      color: #111;
      padding: 16px 24px;
      border-radius: 10px;
      box-shadow: 0 8px 30px rgba(154, 255, 0, 0.4);
      z-index: 3000;
      font-weight: 600;
      font-size: 14px;
      text-align: center;
      animation: slideDown 0.5s ease;
      max-width: 90%;
    `;
    notification.innerHTML = `
      <div style="display: flex; align-items: center; gap: 10px;">
        <span style="font-size: 20px;">üìä</span>
        <div>
          <div style="font-weight: 700; margin-bottom: 4px;">Progreso Restaurado</div>
          <div style="font-size: 12px; opacity: 0.8;">
            Has completado ${completed} de ${total} checkpoints (${progressPercent}%)
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(notification);
    
    // Remover despu√©s de 4 segundos
    setTimeout(() => {
      notification.style.animation = 'slideUp 0.5s ease';
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 500);
    }, 4000);
  }
}

// Agregar animaciones CSS para la notificaci√≥n
const style = document.createElement('style');
style.textContent = `
  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateX(-50%) translateY(-20px);
    }
    to {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
  }
  
  @keyframes slideUp {
    from {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    to {
      opacity: 0;
      transform: translateX(-50%) translateY(-20px);
    }
  }
`;
document.head.appendChild(style);

function updateTimelineProgress() {
  if (video.duration) {
    const percent = (video.currentTime / video.duration) * 100;
    const progressBar = document.getElementById("timelineProgress");
    if (progressBar) {
      progressBar.style.width = percent + "%";
    }
  }
}

function updateMarkerStates() {
  markers.forEach((marker, index) => {
    marker.element.classList.remove("active", "completed", "pending");
    
    if (index < currentCheckpoint) {
      marker.element.classList.add("completed");
    } else if (index === currentCheckpoint && checkpointTriggered.has(index)) {
      marker.element.classList.add("active");
    } else {
      marker.element.classList.add("pending");
    }
  });
  
  // Actualizar progreso de checkpoints
  updateCheckpointsProgress();
}

/* ----------------------------------------------------
   ACTUALIZAR PROGRESO DE CHECKPOINTS EN TIMELINE
   ---------------------------------------------------- */
function updateCheckpointsProgress() {
  if (!video.duration || checkpoints.length === 0) return;
  
  const checkpointsProgress = document.getElementById("timelineCheckpointsProgress");
  if (!checkpointsProgress) return;
  
  // Calcular cu√°ntos checkpoints se han completado
  const completedCount = checkpointTriggered.size;
  const totalCount = checkpoints.length;
  
  if (completedCount === 0) {
    checkpointsProgress.style.width = "0%";
    return;
  }
  
  // Si todos est√°n completados, mostrar hasta el final
  if (completedCount >= totalCount) {
    checkpointsProgress.style.width = "100%";
    return;
  }
  
  // Calcular la posici√≥n del √∫ltimo checkpoint completado
  // Encontrar el checkpoint completado m√°s avanzado
  let lastCompletedTime = 0;
  let lastCompletedIndex = -1;
  
  for (let i = 0; i < checkpoints.length; i++) {
    if (checkpointTriggered.has(i)) {
      if (checkpoints[i].time > lastCompletedTime) {
        lastCompletedTime = checkpoints[i].time;
        lastCompletedIndex = i;
      }
    }
  }
  
  // Si hay un checkpoint activo actualmente, incluir su posici√≥n tambi√©n
  if (currentCheckpoint < checkpoints.length && checkpointTriggered.has(currentCheckpoint)) {
    const currentTime = checkpoints[currentCheckpoint].time;
    if (currentTime > lastCompletedTime) {
      lastCompletedTime = currentTime;
      lastCompletedIndex = currentCheckpoint;
    }
  }
  
  // Si encontramos un checkpoint completado, calcular el porcentaje
  if (lastCompletedIndex >= 0) {
    // Calcular el porcentaje basado en el tiempo del √∫ltimo checkpoint completado
    const percent = (lastCompletedTime / video.duration) * 100;
    checkpointsProgress.style.width = Math.min(percent, 100) + "%";
  } else {
    checkpointsProgress.style.width = "0%";
  }
}


/* ----------------------------------------------------
   PANEL "PR√ìXIMAMENTE" Y CONTADOR REGRESIVO
   ---------------------------------------------------- */
let lastCheckpointForUpcoming = -1;

function updateUpcomingPanel() {
  // Determinar qu√© checkpoint mostrar
  let nextCp = null;
  let nextIndex = -1;
  
  // Si el checkpoint actual a√∫n no se ha activado, mostrar ese checkpoint
  if (currentCheckpoint < checkpoints.length && !checkpointTriggered.has(currentCheckpoint)) {
    nextCp = checkpoints[currentCheckpoint];
    nextIndex = currentCheckpoint;
  } 
  // Si el checkpoint actual ya se activ√≥, mostrar el siguiente
  else if (currentCheckpoint < checkpoints.length - 1) {
    nextCp = checkpoints[currentCheckpoint + 1];
    nextIndex = currentCheckpoint + 1;
  }
  
  // Si no hay siguiente checkpoint, ocultar panel
  if (!nextCp || nextIndex >= checkpoints.length) {
    upcomingPanel.classList.add("hidden");
    upcomingPanel.classList.remove("show");
    stopCountdown();
    lastCheckpointForUpcoming = -1;
    return;
  }
  
  // Si cambi√≥ el checkpoint a mostrar, actualizar contenido y reiniciar contador
  const checkpointChanged = lastCheckpointForUpcoming !== nextIndex;
  if (checkpointChanged) {
    upcomingTitle.textContent = nextCp.title;
    upcomingDescription.textContent = nextCp.text.substring(0, 100) + "...";
    lastCheckpointForUpcoming = nextIndex;
    // Reiniciar contador cuando cambia el checkpoint
    stopCountdown();
  }
  
  // Mostrar/ocultar panel seg√∫n el estado del video
  if (!video.paused && !isPausedByCheckpoint) {
    upcomingPanel.classList.remove("hidden");
    upcomingPanel.classList.add("show");
    // Iniciar contador si no est√° corriendo o si cambi√≥ el checkpoint
    if (!countdownInterval || checkpointChanged) {
      startCountdown();
    }
  } else {
    upcomingPanel.classList.add("hidden");
    upcomingPanel.classList.remove("show");
    stopCountdown();
  }
}

function startCountdown() {
  // Asegurar que no haya m√∫ltiples intervalos
  stopCountdown();
  
  // Funci√≥n para obtener el checkpoint objetivo
  const getTargetCheckpoint = () => {
    // Si el checkpoint actual a√∫n no se ha activado, mostrar ese checkpoint
    if (currentCheckpoint < checkpoints.length && !checkpointTriggered.has(currentCheckpoint)) {
      return { cp: checkpoints[currentCheckpoint], index: currentCheckpoint };
    } 
    // Si el checkpoint actual ya se activ√≥, mostrar el siguiente
    else if (currentCheckpoint < checkpoints.length - 1) {
      return { cp: checkpoints[currentCheckpoint + 1], index: currentCheckpoint + 1 };
    }
    return null;
  };
  
  // Verificar condiciones antes de iniciar
  const target = getTargetCheckpoint();
  if (!target) {
    return;
  }
  
  // Funci√≥n para actualizar el contador
  const updateCountdown = () => {
    // Verificar si el video est√° pausado o hay un checkpoint activo
    if (video.paused || isPausedByCheckpoint) {
      stopCountdown();
      return;
    }
    
    // Obtener el checkpoint objetivo actualizado
    const currentTarget = getTargetCheckpoint();
    if (!currentTarget) {
      stopCountdown();
      return;
    }
    
    const nextCheckpoint = currentTarget.cp;
    const nextTime = nextCheckpoint.time;
    
    // Calcular tiempo exacto hasta el checkpoint objetivo
    const currentTime = video.currentTime;
    const timeUntilNext = nextTime - currentTime;
    
    // Si ya pasamos el checkpoint, detener
    if (timeUntilNext <= 0) {
      countdownDisplay.textContent = "0";
      stopCountdown();
      return;
    }
    
    // Usar Math.floor para mostrar el tiempo m√°s preciso
    const seconds = Math.max(0, Math.floor(timeUntilNext));
    countdownDisplay.textContent = seconds.toString();
    
    // Calcular barra de progreso correctamente
    // Punto de inicio: tiempo del checkpoint anterior (o 0 si es el primero)
    let startTime = 0;
    if (currentTarget.index > 0) {
      startTime = checkpoints[currentTarget.index - 1].time;
    }
    
    // Tiempo total entre checkpoints
    const totalTime = nextTime - startTime;
    
    // Tiempo transcurrido desde el punto de inicio
    const elapsed = Math.max(0, currentTime - startTime);
    
    // Calcular porcentaje (asegurar que no sea negativo ni mayor a 100)
    const progress = totalTime > 0 ? Math.min(Math.max((elapsed / totalTime) * 100, 0), 100) : 0;
    upcomingProgressFill.style.width = progress + "%";
    
    // Cambiar color seg√∫n se acerca
    if (seconds <= 3) {
      countdownDisplay.style.color = "#ff6b6b";
      countdownDisplay.style.textShadow = "0 0 20px rgba(255, 107, 107, 0.8)";
    } else if (seconds <= 10) {
      countdownDisplay.style.color = "#ffd93d";
      countdownDisplay.style.textShadow = "0 0 20px rgba(255, 217, 61, 0.8)";
    } else {
      countdownDisplay.style.color = "#9AFF00";
      countdownDisplay.style.textShadow = "0 0 20px rgba(154, 255, 0, 0.5)";
    }
  };
  
  // Actualizar inmediatamente
  updateCountdown();
  
  // Actualizar cada 100ms para suavidad
  countdownInterval = setInterval(updateCountdown, 100);
}

function stopCountdown() {
  if (countdownInterval) {
    clearInterval(countdownInterval);
    countdownInterval = null;
  }
}


/* ----------------------------------------------------
   ESTAD√çSTICAS EN TIEMPO REAL
   ---------------------------------------------------- */
function updateStats() {
  const completed = checkpointTriggered.size;
  const total = checkpoints.length;
  const progressPercent = video.duration ? Math.round((video.currentTime / video.duration) * 100) : 0;
  
  statCheckpoints.textContent = `${completed}/${total}`;
  statProgress.textContent = `${progressPercent}%`;
  
  // Calcular tiempo visto (incluyendo tiempo acumulado de sesiones anteriores)
  if (startTime) {
    totalTimeWatched = video.currentTime;
  }
  const totalTime = totalTimeWatchedAccumulated + totalTimeWatched;
  statTimeWatched.textContent = formatTime(totalTime);
  
  // Mostrar panel si el video est√° reproduci√©ndose
  if (!video.paused && !isPausedByCheckpoint) {
    statsPanel.classList.remove("hidden");
    statsPanel.classList.add("show");
  } else {
    statsPanel.classList.remove("show");
  }
}

function startStatsUpdates() {
  stopStatsUpdates();
  statsUpdateInterval = setInterval(updateStats, 500);
}

function stopStatsUpdates() {
  if (statsUpdateInterval) {
    clearInterval(statsUpdateInterval);
    statsUpdateInterval = null;
  }
}


/* ----------------------------------------------------
   TIPS ROTATIVOS
   ---------------------------------------------------- */
function showNextTip() {
  if (tips.length === 0) return;
  
  tipText.textContent = tips[tipsIndex];
  tipsIndex = (tipsIndex + 1) % tips.length;
  
  // Mostrar panel si el video est√° reproduci√©ndose
  if (!video.paused && !isPausedByCheckpoint) {
    tipsPanel.classList.remove("hidden");
    tipsPanel.classList.add("show");
  } else {
    tipsPanel.classList.remove("show");
  }
}

let tipsInterval = null;

function startTipsRotation() {
  if (tipsInterval) return; // Ya est√° iniciado
  showNextTip();
  tipsInterval = setInterval(showNextTip, 8000); // Cambiar tip cada 8 segundos
}

function stopTipsRotation() {
  if (tipsInterval) {
    clearInterval(tipsInterval);
    tipsInterval = null;
  }
}


/* ----------------------------------------------------
   SISTEMA DE LOGROS
   ---------------------------------------------------- */
function checkAchievements() {
  const completed = checkpointTriggered.size;
  const total = checkpoints.length;
  
  // Primer checkpoint
  if (completed === 1 && !achievementsShown.has("first")) {
    showAchievement(achievements[0]);
    achievementsShown.add("first");
  }
  
  // Mitad de camino
  if (completed >= Math.ceil(total / 2) && !achievementsShown.has("halfway")) {
    showAchievement(achievements[1]);
    achievementsShown.add("halfway");
  }
  
  // Todos completados
  if (completed >= total && !achievementsShown.has("expert")) {
    showAchievement(achievements[2]);
    achievementsShown.add("expert");
  }
}

let achievementsShown = new Set();

function showAchievement(achievement) {
  const badge = document.createElement("div");
  badge.className = "achievement-badge";
  badge.innerHTML = `
    <div class="achievement-icon">${achievement.icon}</div>
    <div class="achievement-text">
      <div class="achievement-title">${achievement.title}</div>
      <div class="achievement-desc">${achievement.desc}</div>
    </div>
  `;
  
  achievementsContainer.appendChild(badge);
  
  // Guardar progreso cuando se desbloquea un logro
  saveProgress();
  
  // Remover despu√©s de 4 segundos
  setTimeout(() => {
    badge.classList.add("fade-out");
    setTimeout(() => {
      if (badge.parentNode) {
        badge.parentNode.removeChild(badge);
      }
    }, 500);
  }, 4000);
}


/* ----------------------------------------------------
   CREAR MARCADORES EN TIMELINE
   ---------------------------------------------------- */
function createTimelineMarkers() {
  if (!video.duration || video.duration === 0) {
    setTimeout(createTimelineMarkers, 100);
    return;
  }

  timeline.innerHTML = `
    <div class="timeline-checkpoints-progress" id="timelineCheckpointsProgress"></div>
    <div class="timeline-progress" id="timelineProgress"></div>
  `;
  // Actualizar referencia despu√©s de recrear
  const newTimelineProgress = document.getElementById("timelineProgress");
  if (newTimelineProgress) {
    // timelineProgress ya est√° definido como const, necesitamos usar el elemento directamente
  }
  markers = [];

  checkpoints.forEach((cp, index) => {
    const marker = document.createElement("div");
    marker.classList.add("timeline-marker", "pending");
    marker.style.left = (cp.time / video.duration * 100) + "%";
    marker.setAttribute("data-index", index);
    marker.setAttribute("aria-label", `Checkpoint: ${cp.title} en ${formatTime(cp.time)}`);
    
    const tooltip = document.createElement("div");
    tooltip.classList.add("marker-tooltip");
    tooltip.textContent = `${cp.title} (${formatTime(cp.time)})`;
    marker.appendChild(tooltip);
    
    marker.addEventListener("click", () => jumpToCheckpoint(index));
    
    timeline.appendChild(marker);
    markers.push({ element: marker, checkpoint: cp, index });
  });

  updateMarkerStates();
}

video.addEventListener("loadedmetadata", () => {
  // Restaurar progreso guardado
  const progressRestored = restoreProgress();
  if (progressRestored) {
    showProgressRestored();
    updateMarkerStates();
  }
  
  createTimelineMarkers();
  updateTimeDisplay();
  showWelcomeMessage();
  startTipsRotation();
});

/* ----------------------------------------------------
   MENSAJE DE BIENVENIDA INICIAL
   ---------------------------------------------------- */
function showWelcomeMessage() {
  const duration = formatTime(video.duration);
  const totalCheckpoints = checkpoints.length;
  
  // Obtener progreso guardado
  const savedData = loadProgress();
  const completed = savedData ? (savedData.checkpointsCompleted ? savedData.checkpointsCompleted.length : 0) : checkpointTriggered.size;
  const progressPercent = totalCheckpoints > 0 ? Math.round((completed / totalCheckpoints) * 100) : 0;
  const hasProgress = completed > 0;
  
  info.innerHTML = `
    <div class="welcome-message">
      <h2 style="color: #9AFF00; margin-bottom: 16px; font-size: 24px;">
        üéØ Sistema de Visi√≥n por Computadora
      </h2>
      <p style="margin-bottom: 12px; line-height: 1.7; opacity: 0.9;">
        ${hasProgress ? '¬°Bienvenido de nuevo! Tu progreso ha sido restaurado.' : 'Bienvenido al an√°lisis interactivo de detecci√≥n y seguimiento de objetos en tiempo real.'}
      </p>
      ${hasProgress ? `
      <div style="background: linear-gradient(135deg, rgba(154, 255, 0, 0.15), rgba(127, 224, 0, 0.1)); padding: 14px; border-radius: 8px; border: 2px solid rgba(154, 255, 0, 0.3); margin: 16px 0;">
        <p style="margin: 0 0 10px 0; font-weight: 700; color: #9AFF00; font-size: 15px; display: flex; align-items: center; gap: 8px;">
          <span>üìà</span> Tu Progreso
        </p>
        <div style="margin-bottom: 10px;">
          <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 12px; opacity: 0.8;">
            <span>Progreso General</span>
            <strong style="color: #9AFF00;">${progressPercent}%</strong>
          </div>
          <div style="height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden;">
            <div style="height: 100%; width: ${progressPercent}%; background: linear-gradient(90deg, #9AFF00, #7FE000); border-radius: 4px; transition: width 0.3s ease;"></div>
          </div>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px; margin-top: 8px;">
          <div>
            <span style="opacity: 0.7;">Checkpoints:</span>
            <strong style="color: #9AFF00; margin-left: 4px;">${completed}/${totalCheckpoints}</strong>
          </div>
          <div>
            <span style="opacity: 0.7;">Logros:</span>
            <strong style="color: #9AFF00; margin-left: 4px;">${savedData && savedData.achievementsUnlocked ? savedData.achievementsUnlocked.length : achievementsShown.size}</strong>
          </div>
        </div>
      </div>
      ` : ''}
      <div style="background: rgba(154, 255, 0, 0.1); padding: 12px; border-radius: 8px; border-left: 3px solid #9AFF00; margin: 16px 0;">
        <p style="margin: 0 0 8px 0; font-weight: 600; color: #9AFF00; font-size: 14px;">
          üìä Informaci√≥n del Video
        </p>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 13px;">
          <div>
            <span style="opacity: 0.7;">Duraci√≥n:</span>
            <strong style="color: #9AFF00; margin-left: 6px;">${duration}</strong>
          </div>
          <div>
            <span style="opacity: 0.7;">Checkpoints:</span>
            <strong style="color: #9AFF00; margin-left: 6px;">${totalCheckpoints}</strong>
          </div>
        </div>
      </div>
      <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255,255,255,0.1);">
        <p style="margin: 0 0 12px 0; font-size: 13px; opacity: 0.8;">
          <strong style="color: #9AFF00;">üí° Caracter√≠sticas del Sistema:</strong>
        </p>
        <ul style="margin: 0; padding-left: 20px; font-size: 12px; line-height: 1.8; opacity: 0.85;">
          <li>Detecci√≥n multiclase de veh√≠culos</li>
          <li>Seguimiento con ID √∫nico por objeto</li>
          <li>Vectores de movimiento y velocidad</li>
          <li>Radar 360 con mapa de calor</li>
          <li>Estad√≠sticas en tiempo real</li>
        </ul>
      </div>
      <div style="margin-top: 16px; padding: 10px; background: rgba(154, 255, 0, 0.05); border-radius: 6px; text-align: center;">
        <p style="margin: 0; font-size: 13px; color: #9AFF00; font-weight: 600;">
          ‚ñ∂ Haz clic en Reproducir para comenzar el an√°lisis
        </p>
      </div>
    </div>
  `;
  
  info.classList.add("active");
}

video.addEventListener("error", (e) => {
  showError("Error al cargar el video. Verifica que el archivo existe y el formato es compatible.");
  info.innerHTML = '<div class="loading" style="color: #ff6b6b;">Error al cargar el video</div>';
});


/* ----------------------------------------------------
   INFORMACI√ìN CONTEXTUAL ENTRE CHECKPOINTS
   ---------------------------------------------------- */
function getContextualInfo(currentTime) {
  // Informaci√≥n contextual que aparece mientras el video corre
  const contextualMessages = [
    { range: [0, 10], text: "Sistema iniciando detecci√≥n de objetos en tiempo real..." },
    { range: [10, 45], text: "Observa los IDs √∫nicos asignados a cada veh√≠culo. El sistema mantiene el seguimiento incluso con oclusi√≥n parcial." },
    { range: [45, 60], text: "Los vectores rojos indican direcci√≥n y velocidad estimada. El radar 360 muestra la densidad de objetos detectados." },
    { range: [60, 90], text: "Seguimiento preciso de veh√≠culos largos. El sistema ajusta din√°micamente los cuadros delimitadores al tama√±o real." },
    { range: [90, 135], text: "Robustez ante cambios de iluminaci√≥n. El algoritmo distingue entre sombras y objetos reales." },
    { range: [135, 180], text: "Procesamiento de alta densidad: m√∫ltiples veh√≠culos simult√°neos sin p√©rdida de rendimiento." },
    { range: [180, 999], text: "Clasificaci√≥n avanzada: distingue entre veh√≠culos estacionados y en movimiento." }
  ];

  for (const msg of contextualMessages) {
    if (currentTime >= msg.range[0] && currentTime < msg.range[1]) {
      return msg.text;
    }
  }
  return null;
}

function updateContextualInfo() {
  if (isPausedByCheckpoint) return; // No mostrar info contextual si hay un checkpoint activo
  
  const contextualText = getContextualInfo(video.currentTime);
  if (contextualText) {
    // Solo actualizar si no hay informaci√≥n de checkpoint activa
    const hasCheckpointInfo = info.querySelector("h2");
    const hasWelcomeMessage = info.querySelector(".welcome-message");
    
    // Si hay mensaje de bienvenida o no hay checkpoint activo, mostrar info contextual
    if (!hasCheckpointInfo || hasWelcomeMessage) {
      info.innerHTML = `
        <p style="margin: 0;">üí° ${contextualText}</p>
      `;
      info.classList.add("active", "contextual");
    }
  }
}

/* ----------------------------------------------------
   SINCRONIZACI√ìN VIDEO > CHECKPOINT (MEJORADA)
   ---------------------------------------------------- */
video.addEventListener("timeupdate", () => {
  updateTimeDisplay();
  updateTimelineProgress();
  updateContextualInfo();
  updateUpcomingPanel();
  updateStats();

  // Buscar TODOS los checkpoints pendientes, no solo el siguiente
  // Esto permite que funcione incluso si el usuario navega manualmente
  for (let i = 0; i < checkpoints.length; i++) {
    if (checkpointTriggered.has(i)) continue;
    
    const cp = checkpoints[i];
    const tolerance = 0.5; // Tolerancia aumentada
    
    if (video.currentTime >= cp.time - tolerance) {
      checkpointTriggered.add(i);
      
      // Si es el checkpoint actual o uno que viene despu√©s, activarlo
      if (i >= currentCheckpoint) {
        currentCheckpoint = i;
        isPausedByCheckpoint = true;
        video.pause();
        showContent(cp, i);
        updateMarkerStates();
        break; // Solo activar un checkpoint a la vez
      }
    }
  }
});


/* ----------------------------------------------------
   MOSTRAR PANEL DE INFORMACI√ìN (MEJORADO)
   ---------------------------------------------------- */
function showContent(cp, index) {
  const counter = `${index + 1} de ${checkpoints.length}`;
  const nextCp = index < checkpoints.length - 1 ? checkpoints[index + 1] : null;
  const nextTime = nextCp ? formatTime(nextCp.time) : "Final";
  
  info.innerHTML = `
    <h2>${cp.title}</h2>
    <p>${cp.text}</p>
    <div class="checkpoint-counter">${counter}</div>
    ${nextCp ? `<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(154, 255, 0, 0.2); font-size: 12px; opacity: 0.7;">
      <strong>Pr√≥ximo:</strong> ${nextCp.title} (${nextTime})
    </div>` : ''}
  `;

  // Remover clase contextual y agregar active
  info.classList.remove("contextual");
  info.classList.add("active");
  nextBtn.classList.remove("hidden");
  
  if (index === checkpoints.length - 1) {
    replayBtn.classList.remove("hidden");
    nextBtn.textContent = "Finalizar";
  } else {
    replayBtn.classList.add("hidden");
    nextBtn.textContent = `Continuar ‚Üí`;
  }
  
  playPauseBtn.textContent = "‚ñ∂ Reproducir";
  
  // Iniciar auto-skip si est√° habilitado
  if (autoplayEnabled && autoSkipTime > 0) {
    startAutoSkip();
  } else {
    cancelAutoSkip();
  }
  
  // Verificar logros
  checkAchievements();
  
  // Guardar progreso
  saveProgress();
  
  // Ocultar paneles de entretenimiento cuando hay checkpoint activo
  upcomingPanel.classList.remove("show");
  statsPanel.classList.remove("show");
  tipsPanel.classList.remove("show");
  stopCountdown();
}


/* ----------------------------------------------------
   SALTAR A CHECKPOINT ESPEC√çFICO
   ---------------------------------------------------- */
function jumpToCheckpoint(index) {
  if (index < 0 || index >= checkpoints.length) return;
  
  const cp = checkpoints[index];
  video.currentTime = cp.time;
  currentCheckpoint = index;
  
  // Marcar todos los checkpoints anteriores como completados
  for (let i = 0; i < index; i++) {
    checkpointTriggered.add(i);
  }
  
  checkpointTriggered.add(index);
  isPausedByCheckpoint = true;
  video.pause();
  showContent(cp, index);
  updateMarkerStates();
  playPauseBtn.textContent = "‚ñ∂ Reproducir";
}


/* ----------------------------------------------------
   BOT√ìN "SIGUIENTE"
   ---------------------------------------------------- */
nextBtn.addEventListener("click", () => {
  // Cancelar auto-skip si se hace clic manualmente
  cancelAutoSkip();
  
  currentCheckpoint++;

  if (currentCheckpoint >= checkpoints.length) {
    nextBtn.classList.add("hidden");
    replayBtn.classList.remove("hidden");
    // Mantener la informaci√≥n visible pero con mensaje de finalizaci√≥n
    info.innerHTML = `
      <h2>An√°lisis Completado</h2>
      <p style="opacity: 0.8; text-align: center;">¬°Has completado todos los checkpoints! El sistema ha demostrado sus capacidades de detecci√≥n y seguimiento en tiempo real.</p>
      <div class="checkpoint-counter">${checkpoints.length} de ${checkpoints.length}</div>
    `;
    info.classList.add("active");
    isPausedByCheckpoint = false;
    video.play();
    playPauseBtn.textContent = "‚è∏ Pausar";
    return;
  }

  isPausedByCheckpoint = false;
  // No ocultar la informaci√≥n inmediatamente, permitir que se actualice con info contextual
  // La informaci√≥n se mantendr√° visible hasta el pr√≥ximo checkpoint
  nextBtn.classList.add("hidden");
  video.play();
  playPauseBtn.textContent = "‚è∏ Pausar";
  updateMarkerStates();
  
  // Mostrar informaci√≥n contextual mientras se reproduce
  setTimeout(() => {
    updateContextualInfo();
  }, 500);
});


/* ----------------------------------------------------
   BOT√ìN "REPETIR"
   ---------------------------------------------------- */
replayBtn.addEventListener("click", () => {
  resetVideo();
});


/* ----------------------------------------------------
   CONTROLES DE VIDEO
   ---------------------------------------------------- */
playPauseBtn.addEventListener("click", () => {
  if (video.paused) {
    if (isPausedByCheckpoint) {
      // Si est√° pausado por checkpoint, avanzar al siguiente
      nextBtn.click();
    } else {
      video.play();
      playPauseBtn.textContent = "‚è∏ Pausar";
      // Mantener informaci√≥n visible con contexto
      setTimeout(() => {
        updateContextualInfo();
      }, 300);
    }
  } else {
    video.pause();
    playPauseBtn.textContent = "‚ñ∂ Reproducir";
  }
});

resetBtn.addEventListener("click", () => {
  resetVideo();
});

function clearProgress() {
  try {
    localStorage.removeItem(STORAGE_KEY);
    totalTimeWatchedAccumulated = 0;
    achievementsShown.clear();
    checkpointTriggered.clear();
    currentCheckpoint = 0;
    lastCheckpointReached = 0;
  } catch (e) {
    console.warn('No se pudo limpiar el progreso:', e);
  }
}

function resetVideo() {
  // Guardar progreso antes de resetear
  saveProgress();
  
  video.pause();
  video.currentTime = 0;
  currentCheckpoint = 0;
  checkpointTriggered.clear();
  isPausedByCheckpoint = false;
  nextBtn.classList.add("hidden");
  replayBtn.classList.add("hidden");
  playPauseBtn.textContent = "‚ñ∂ Reproducir";
  updateMarkerStates();
  updateTimeDisplay();
  updateTimelineProgress();
  cancelAutoSkip(); // Cancelar auto-skip si est√° activo
  stopCountdown(); // Detener contador
  lastCheckpointForUpcoming = -1; // Resetear checkpoint de upcoming
  startTime = null; // Resetear tiempo de inicio
  totalTimeWatched = 0; // Resetear tiempo visto (solo de esta sesi√≥n)
  // Mostrar mensaje de bienvenida
  showWelcomeMessage();
}


/* ----------------------------------------------------
   CONTROL DE VELOCIDAD DE REPRODUCCI√ìN
   ---------------------------------------------------- */
speedSelect.addEventListener("change", (e) => {
  const speed = parseFloat(e.target.value);
  video.playbackRate = speed;
});


/* ----------------------------------------------------
   MODO AUTO-PLAY
   ---------------------------------------------------- */
autoplayToggle.addEventListener("change", (e) => {
  autoplayEnabled = e.target.checked;
  if (autoplayEnabled) {
    autoplaySettings.classList.add("active");
  } else {
    autoplaySettings.classList.remove("active");
    cancelAutoSkip();
  }
});

autoSkipTimeInput.addEventListener("change", (e) => {
  autoSkipTime = parseInt(e.target.value) || 5;
  // Si hay un timer activo, reiniciarlo con el nuevo tiempo
  if (autoSkipTimer) {
    cancelAutoSkip();
    if (isPausedByCheckpoint && autoplayEnabled) {
      startAutoSkip();
    }
  }
});

function startAutoSkip() {
  if (!autoplayEnabled || autoSkipTime <= 0) return;
  
  cancelAutoSkip(); // Cancelar cualquier timer existente
  
  // Mostrar contador visual
  updateAutoSkipDisplay(autoSkipTime);
  
  let remaining = autoSkipTime;
  autoSkipTimer = setInterval(() => {
    remaining--;
    updateAutoSkipDisplay(remaining);
    
    if (remaining <= 0) {
      cancelAutoSkip();
      // Avanzar autom√°ticamente al siguiente checkpoint
      if (nextBtn && !nextBtn.classList.contains("hidden")) {
        nextBtn.click();
      }
    }
  }, 1000);
}

function cancelAutoSkip() {
  if (autoSkipTimer) {
    clearInterval(autoSkipTimer);
    autoSkipTimer = null;
  }
  // Ocultar contador visual
  const skipDisplay = document.getElementById("autoSkipDisplay");
  if (skipDisplay) {
    skipDisplay.remove();
  }
}

function updateAutoSkipDisplay(seconds) {
  // Remover display anterior si existe
  const existingDisplay = document.getElementById("autoSkipDisplay");
  if (existingDisplay) {
    existingDisplay.remove();
  }
  
  // Crear o actualizar display
  const display = document.createElement("div");
  display.id = "autoSkipDisplay";
  display.textContent = `Auto-continuar en ${seconds}s`;
  
  const infoPanel = document.querySelector(".info-panel");
  if (infoPanel) {
    infoPanel.style.position = "relative";
    infoPanel.appendChild(display);
  }
}


/* ----------------------------------------------------
   CLIC EN TIMELINE PARA SALTAR
   ---------------------------------------------------- */
timeline.addEventListener("click", (e) => {
  if (e.target === timeline || e.target === timelineProgress) {
    const rect = timeline.getBoundingClientRect();
    const percent = (e.clientX - rect.left) / rect.width;
    const targetTime = percent * video.duration;
    video.currentTime = targetTime;
    
    // Encontrar el checkpoint m√°s cercano
    let nearestIndex = 0;
    let minDiff = Infinity;
    checkpoints.forEach((cp, index) => {
      const diff = Math.abs(cp.time - targetTime);
      if (diff < minDiff) {
        minDiff = diff;
        nearestIndex = index;
      }
    });
    
    // Si estamos cerca de un checkpoint, saltar a √©l
    if (minDiff < 2) {
      jumpToCheckpoint(nearestIndex);
    } else {
      isPausedByCheckpoint = false;
      video.pause();
      playPauseBtn.textContent = "‚ñ∂ Reproducir";
    }
  }
});


/* ----------------------------------------------------
   EVENTOS ADICIONALES
   ---------------------------------------------------- */
video.addEventListener("play", () => {
  playPauseBtn.textContent = "‚è∏ Pausar";
  if (!startTime) {
    startTime = Date.now();
  }
  startStatsUpdates();
  updateUpcomingPanel();
  startTipsRotation();
});

video.addEventListener("pause", () => {
  if (!isPausedByCheckpoint) {
    playPauseBtn.textContent = "‚ñ∂ Reproducir";
    // Cancelar auto-skip si se pausa manualmente
    cancelAutoSkip();
    stopStatsUpdates();
    stopCountdown();
  }
});

video.addEventListener("ended", () => {
  playPauseBtn.textContent = "‚ñ∂ Reproducir";
  if (currentCheckpoint < checkpoints.length) {
    nextBtn.click();
  }
});

// Soporte para teclado
document.addEventListener("keydown", (e) => {
  if (e.code === "Space" && document.activeElement !== video) {
    e.preventDefault();
    playPauseBtn.click();
  } else if (e.code === "ArrowRight") {
    video.currentTime = Math.min(video.currentTime + 5, video.duration);
  } else if (e.code === "ArrowLeft") {
    video.currentTime = Math.max(video.currentTime - 5, 0);
  }
});

// Guardar progreso antes de cerrar la p√°gina
window.addEventListener("beforeunload", () => {
  saveProgress();
});

// Guardar progreso peri√≥dicamente (cada 30 segundos)
setInterval(() => {
  if (!video.paused) {
    saveProgress();
  }
}, 30000);

</script>

</body>
</html>
