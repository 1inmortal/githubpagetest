<!DOCTYPE html>
<!--
    ╔══════════════════════════════════════════════════════════════╗
    ║                                                              ║
    ║  © 2025 - Advanced WebGL Background - Infinite Wall         ║
    ║  Propiedad Intelectual - Todos los derechos reservados      ║
    ║                                                              ║
    ║  Autor: Jarma (GitHub: githubpagetest)                      ║
    ║  Este código es propiedad exclusiva del autor.              ║
    ║  Prohibida su reproducción sin autorización.                ║
    ║                                                              ║
    ╚══════════════════════════════════════════════════════════════╝
-->
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Jarma">
    <meta name="copyright" content="© 2025 Jarma - Todos los derechos reservados">
    <link rel="icon" href="data:,">
    <title>Advanced WebGL Background - Infinite Wall</title>
    <style>
        /* =========================================
           ESTILOS GENERALES Y RESET
           ========================================= */
        :root {
            --font-main: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            font-family: var(--font-main);
            overflow-x: hidden;
            color: white;
            cursor: none; /* Ocultar cursor del sistema, usar cursor personalizado */
        }

        /* Canvas en background fijo */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            outline: none;
            background: #111;
        }

        /* Viñeta sutil */
        .cinematic-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 20%, rgba(0,0,0,0.1) 60%, rgba(0,0,0,0.3) 100%);
        }
        
        .cinematic-overlay::after {
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.05'/%3E%3C/svg%3E");
            opacity: 0.03;
            pointer-events: none;
        }

        /* =========================================
           UI INTERFACE
           ========================================= */
        .ui-layer {
            position: relative;
            z-index: 10;
            min-height: 200vh;
            display: flex;
            flex-direction: column;
        }

        .hero-section {
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            pointer-events: none;
            padding: 0 20px;
        }

        h1 {
            font-size: clamp(3rem, 8vw, 6rem);
            font-weight: 800;
            line-height: 0.9;
            letter-spacing: -0.04em;
            margin: 0 0 1rem 0;
            background: linear-gradient(180deg, #ffffff 0%, #a5a5a5 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 20px 40px rgba(0,0,0,0.5);
        }

        p.subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
            font-weight: 300;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        /* Panel de Controles */
        .controls-panel {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 800px;
            background: rgba(20, 20, 25, 0.85);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 24px;
            padding: 1.5rem;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            transition: transform 0.3s ease, opacity 0.3s ease, visibility 0.3s;
            z-index: 1000;
            opacity: 1;
            visibility: visible;
        }
        
        .controls-panel.hidden {
            opacity: 0;
            visibility: hidden;
            transform: translateX(-50%) translateY(20px);
            pointer-events: none;
        }
        
        /* Botón/Pestaña para toggle del panel */
        .panel-toggle {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 60px;
            background: rgba(20, 20, 25, 0.9);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        /* Cuando el panel está visible, el botón se mueve arriba */
        .panel-toggle.panel-visible {
            bottom: calc(2rem + 200px);
        }
        
        .panel-toggle:hover {
            background: rgba(30, 30, 35, 0.95);
            box-shadow: 0 15px 40px rgba(0,0,0,0.7);
            transform: translateX(-50%) scale(1.1);
        }
        
        .panel-toggle-icon {
            width: 24px;
            height: 24px;
            position: relative;
            transition: transform 0.3s ease;
        }
        
        /* Icono: flecha hacia arriba cuando panel visible, flecha hacia abajo cuando oculto */
        .panel-toggle-icon::before,
        .panel-toggle-icon::after {
            content: '';
            position: absolute;
            width: 3px;
            height: 12px;
            background: rgba(255, 255, 255, 0.9);
            left: 50%;
            top: 50%;
            transform-origin: center bottom;
            transition: all 0.3s ease;
            border-radius: 2px;
        }
        
        /* Flecha hacia abajo (panel oculto) */
        .panel-toggle-icon::before {
            transform: translate(-50%, -50%) translateX(-4px) rotate(45deg);
        }
        
        .panel-toggle-icon::after {
            transform: translate(-50%, -50%) translateX(4px) rotate(-45deg);
        }
        
        /* Flecha hacia arriba (panel visible) */
        .panel-toggle.panel-visible .panel-toggle-icon::before {
            transform: translate(-50%, -50%) translateX(-4px) rotate(-45deg);
        }
        
        .panel-toggle.panel-visible .panel-toggle-icon::after {
            transform: translate(-50%, -50%) translateX(4px) rotate(45deg);
        }

        .controls-row {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            align-items: center;
            justify-content: space-between;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: rgba(255,255,255,0.7);
            font-weight: 600;
        }

        .btn-group {
            display: flex;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 4px;
            gap: 4px;
            flex-wrap: wrap;
        }

        button {
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.8);
            padding: 8px 16px;
            font-size: 0.85rem;
            font-family: inherit;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        button:hover {
            color: white;
            background: rgba(255,255,255,0.2);
        }

        button.active {
            background: white;
            color: black;
            font-weight: 700;
            box-shadow: 0 2px 10px rgba(255,255,255,0.2);
        }

        /* Sliders */
        input[type=range] {
            appearance: none;
            -webkit-appearance: none;
            width: 140px;
            background: transparent;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #fff;
            margin-top: -6px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        @media (max-width: 768px) {
            .controls-panel {
                bottom: 0;
                width: 100%;
                max-width: 100%;
                border-radius: 24px 24px 0 0;
                padding: 1.5rem 1rem;
                transform: translate(-50%, 85%);
                background: rgba(10, 10, 15, 0.95);
                border-bottom: none;
            }
            
            .controls-panel::before {
                content: "";
                display: block;
                width: 40px;
                height: 4px;
                background: rgba(255,255,255,0.4);
                margin: -10px auto 15px;
                border-radius: 2px;
            }

            .controls-panel:hover, 
            .controls-panel:focus-within, 
            .controls-panel.expanded {
                transform: translate(-50%, 0);
            }

            .controls-row {
                gap: 1rem;
                flex-direction: column;
                align-items: stretch;
            }
            
            h1 { font-size: 2.5rem; }
        }
    </style>
</head>
<body data-author="Jarma" data-copyright="© 2025" data-project="Advanced WebGL Background - Infinite Wall" data-signature="jarma-2025-webgl-wall">

    <!-- Watermark oculto en HTML -->
    <div style="position: fixed; bottom: 0; right: 0; opacity: 0.01; pointer-events: none; z-index: 9999; font-size: 8px; color: rgba(0,243,255,0.1);">
        © 2025 Jarma - Propiedad Intelectual
    </div>

    <div id="canvas-container"></div>
    <div class="cinematic-overlay"></div>

    <div class="ui-layer">
        <div class="hero-section">
            <h1>KINETIC<br>HORIZON</h1>
            <p class="subtitle">Infinite WebGL Wall. Fully responsive to scroll & viewport.</p>
        </div>
        
        <div style="height: 100vh; display: flex; align-items: center; justify-content: center; pointer-events: none;">
            <p style="opacity: 0.5; text-align: center; color: white;">
                SCROLL DEEPER<br>↓
            </p>
        </div>
    </div>

    <!-- Botón/Pestaña para mostrar/ocultar panel -->
    <div class="panel-toggle" id="panel-toggle">
        <div class="panel-toggle-icon"></div>
    </div>

    <div class="controls-panel" id="main-controls">
        <div class="controls-row">
            <div class="control-group">
                <div class="control-label">Geometry Shape</div>
                <div class="btn-group" id="shape-controls">
                    <button data-val="hexagon" class="active">Hex</button>
                    <button data-val="triangle">Tri</button>
                    <button data-val="circle">Circle</button>
                    <button data-val="square">Square</button>
                </div>
            </div>

            <div class="control-group">
                <div class="control-label">Color Presets</div>
                <div class="btn-group" id="preset-controls">
                    <button data-val="cyber">Cyber</button>
                    <button data-val="neon">Neon</button>
                    <button data-val="matrix">Matrix</button>
                    <button data-val="sunset">Sunset</button>
                </div>
            </div>
        </div>

        <div class="controls-row">
            <div class="control-group">
                <div class="control-label">Density (Scale)</div>
                <input type="range" id="density-slider" min="10" max="50" value="24">
            </div>
            <div class="control-group">
                <div class="control-label">Wave Speed</div>
                <input type="range" id="speed-slider" min="0" max="200" value="100">
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        /**
         * ═══════════════════════════════════════════════════════════════
         * FIRMA Y PROPIEDAD INTELECTUAL
         * ═══════════════════════════════════════════════════════════════
         * © 2025 Jarma - Advanced WebGL Background - Infinite Wall
         * Propiedad Intelectual - Todos los derechos reservados
         * Autor: Jarma (GitHub: githubpagetest)
         * ═══════════════════════════════════════════════════════════════
         */
        
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        
        // Mensaje oculto de propiedad - visible en consola
        const __AUTHOR_SIGNATURE__ = {
            author: 'Jarma',
            copyright: '© 2025',
            project: 'Advanced WebGL Background - Infinite Wall',
            message: 'Este código es propiedad intelectual de Jarma. Prohibida su reproducción sin autorización.',
            github: 'githubpagetest',
            timestamp: new Date().toISOString(),
            version: '1.0.0'
        };
        
        // Mostrar mensaje en consola (solo en desarrollo o con flag especial)
        if (window.location.search.includes('debug=true') || window.console) {
            console.log('%c═══════════════════════════════════════════════════════════════', 'color: #00f3ff; font-weight: bold;');
            console.log('%c© 2025 Jarma - Advanced WebGL Background', 'color: #00f3ff; font-weight: bold; font-size: 14px;');
            console.log('%cPropiedad Intelectual - Todos los derechos reservados', 'color: #ffffff; font-size: 12px;');
            console.log('%cAutor: Jarma | GitHub: githubpagetest', 'color: #a5a5a5; font-size: 11px;');
            console.log('%c═══════════════════════════════════════════════════════════════', 'color: #00f3ff; font-weight: bold;');
            console.log('Firma del código:', __AUTHOR_SIGNATURE__);
        }

        /**
         * CONFIGURACIÓN Y PRESETS
         * © 2025 Jarma - Propiedad Intelectual
         */
        const PRESETS = {
            cyber: {
                baseColor: '#2a2a35', 
                activeColor: '#00f3ff',
                accentColor: '#5d00ff',
                bgColor: '#0a0a12', 
                bloomStrength: 1.2,
                bloomRadius: 0.5
            },
            neon: {
                baseColor: '#331a25',
                activeColor: '#ff0066',
                accentColor: '#ffaa00',
                bgColor: '#14050a',
                bloomStrength: 1.5,
                bloomRadius: 0.7
            },
            matrix: {
                baseColor: '#0a2a15',
                activeColor: '#00ff44',
                accentColor: '#ccff00',
                bgColor: '#021005',
                bloomStrength: 0.8,
                bloomRadius: 0.4
            },
            sunset: {
                baseColor: '#352020',
                activeColor: '#ff6b6b',
                accentColor: '#ffd93d',
                bgColor: '#150808',
                bloomStrength: 1.3,
                bloomRadius: 0.6
            }
        };

        const isMobile = window.innerWidth < 768;

        const state = {
            shape: 'hexagon', 
            // Interpretamos 'columns' como densidad en la vista inicial
            density: isMobile ? 14 : 24, 
            gap: isMobile ? 0.1 : 0.15,
            speed: 1.0, // Equivale a 100 en el slider (100/100 = 1.0)
            baseColor: new THREE.Color(),
            activeColor: new THREE.Color(),
            bgColor: new THREE.Color(),
            mouseEffectRadius: 6,
            mouseEffectStrength: 2.5,
            scrollProgress: 0,
            maxScrollZ: 15, // Distancia máxima que se aleja la cámara
            currentPreset: 'cyber' // Preset activo inicial
        };

        /**
         * HELPERS DE VISIBILIDAD (NUEVO)
         * Calculan el tamaño visible a cierta profundidad para cubrir toda la pantalla.
         */
        const visibleHeightAtDepth = (depth, camera) => {
            // compensar offset de cámara si depth es absoluta
            const cameraOffset = camera.position.z;
            const dist = Math.abs(depth - cameraOffset);
            
            // vFOV en radianes
            const vFOV = camera.fov * Math.PI / 180;
            // Altura = 2 * tan(fov/2) * distancia
            return 2 * Math.tan(vFOV / 2) * dist;
        };

        const visibleWidthAtDepth = (depth, camera) => {
            const height = visibleHeightAtDepth(depth, camera);
            return height * camera.aspect;
        };

        /**
         * SISTEMA PRINCIPAL (CLASE APP)
         * © 2025 Jarma - Propiedad Intelectual
         * Clase principal que gestiona la escena WebGL, animaciones y efectos
         */
        class App {
            constructor() {
                this.container = document.getElementById('canvas-container');
                
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.composer = null;
                this.clock = new THREE.Clock();
                
                this.gridMesh = null;
                this.auraMesh = null; // Mesh para el aura/energía debajo de cada elemento
                this.dummy = new THREE.Object3D();
                this.instances = [];
                
                this.cursorLight = null;
                this.dirLight = null;

                this.mouse = new THREE.Vector2(-100, -100);
                this.targetMouse = new THREE.Vector2(-100, -100);
                this.raycaster = new THREE.Raycaster();
                
                this.plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                
                this.colorA = new THREE.Color();
                
                // Sistema de cursor personalizado con diseño único de energía
                this.cursorGroup = null;
                this.cursorCore = null;
                this.cursorRings = null;
                this.cursorParticles = null;
                this.cursorEnergyBeams = null;
                this.cursorPosition = new THREE.Vector3(0, 0, 0);
                
                // Watermark oculto de propiedad intelectual
                this.watermarkText = null;

                this.init();
            }

            init() {
                this.createScene();
                this.createRenderer();
                this.createPostProcessing();
                this.createLights();
                this.applyPreset('cyber');
                this.createGrid(); // Ahora usará lógica de tamaño dinámico
                this.createCustomCursor(); // Crear cursor personalizado con diseño único
                this.createHiddenWatermark(); // Crear watermark oculto de propiedad
                this.addEventListeners();
                
                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);
            }

            createScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000000, 0.015);
                
                const fov = 50;
                const aspect = window.innerWidth / window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(fov, aspect, 0.1, 100);
                
                this.cameraBasePos = new THREE.Vector3(0, 0, 18);
                this.camera.position.copy(this.cameraBasePos);
                this.camera.lookAt(0, 0, 0);
            }

            createRenderer() {
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: false, 
                    powerPreference: "high-performance",
                    alpha: false 
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.8; // Aumentado para reflejos metálicos más brillantes
                this.renderer.outputColorSpace = THREE.SRGBColorSpace;
                
                // Deshabilitar pointer events en el canvas cuando el mouse está sobre el panel
                this.renderer.domElement.style.pointerEvents = 'auto';
                this.container.appendChild(this.renderer.domElement);
            }

            createPostProcessing() {
                const renderScene = new RenderPass(this.scene, this.camera);
                const bloomResolution = new THREE.Vector2(window.innerWidth / 2, window.innerHeight / 2);
                const bloomPass = new UnrealBloomPass(bloomResolution, 1.5, 0.4, 0.1);
                this.bloomPass = bloomPass;

                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(renderScene);
                this.composer.addPass(bloomPass);
            }

            createLights() {
                // Luz ambiental reducida para que los reflejos metálicos sean más visibles
                const ambient = new THREE.AmbientLight(0xffffff, 0.8); 
                this.scene.add(ambient);

                // Luz direccional principal - más intensa para reflejos metálicos
                this.dirLight = new THREE.DirectionalLight(0xffffff, 3.5);
                this.dirLight.position.set(10, 10, 20);
                this.scene.add(this.dirLight);

                // Luz direccional secundaria desde otro ángulo para más reflejos
                const dirLight2 = new THREE.DirectionalLight(0xffffff, 1.5);
                dirLight2.position.set(-10, 5, 15);
                this.scene.add(dirLight2);

                // Luz puntual del cursor - más intensa para reflejos
                this.cursorLight = new THREE.PointLight(0xffffff, 3, 15);
                this.cursorLight.position.set(0, 0, 5);
                this.scene.add(this.cursorLight);
            }

            applyPreset(name) {
                const p = PRESETS[name];
                if(!p) return;

                state.currentPreset = name;
                state.baseColor.set(p.baseColor);
                state.activeColor.set(p.activeColor);
                state.bgColor.set(p.bgColor);

                this.scene.background = state.bgColor;
                this.scene.fog.color = state.bgColor;

                if(this.bloomPass) {
                    this.bloomPass.strength = p.bloomStrength;
                    this.bloomPass.radius = p.bloomRadius;
                }

                if(this.cursorLight) this.cursorLight.color.set(p.activeColor);
                if(this.dirLight) this.dirLight.color.set(p.accentColor);

                if(this.gridMesh) this.updateGridColors();
                
                // Actualizar color del aura/energía
                if(this.auraMesh) {
                    this.auraMesh.material.color.set(p.activeColor);
                    this.auraMesh.material.emissive.set(p.activeColor);
                }
                
                // Actualizar colores del cursor personalizado
                if(this.cursorCore) {
                    this.cursorCore.material.color.set(p.activeColor);
                    this.cursorCore.material.emissive.set(p.activeColor);
                }
                
                if(this.cursorRings) {
                    this.cursorRings.forEach(ring => {
                        ring.material.color.set(p.activeColor);
                        ring.material.emissive.set(p.activeColor);
                    });
                }
                
                if(this.cursorEnergyBeams) {
                    this.cursorEnergyBeams.forEach(beam => {
                        beam.material.color.set(p.activeColor);
                        beam.material.emissive.set(p.activeColor);
                    });
                }
                
                if(this.cursorParticles && this.cursorParticles.geometry) {
                    const colors = this.cursorParticles.geometry.attributes.color;
                    const activeColor = p.activeColor;
                    for (let i = 0; i < colors.count; i++) {
                        colors.setXYZ(
                            i,
                            activeColor.r,
                            activeColor.g,
                            activeColor.b
                        );
                    }
                    colors.needsUpdate = true;
                }
            }

            /**
             * MODIFICACIÓN: Cálculo dinámico del Grid para cubrir todo el fondo
             */
            createGrid() {
                if (this.gridMesh) {
                    this.scene.remove(this.gridMesh);
                    this.gridMesh.geometry.dispose(); 
                    this.gridMesh.material.dispose();
                }
                
                // Eliminar aura anterior si existe
                if (this.auraMesh) {
                    this.scene.remove(this.auraMesh);
                    this.auraMesh.geometry.dispose();
                    this.auraMesh.material.dispose();
                    this.auraMesh = null;
                }

                // --- 1. Calcular el escenario "Peor Caso" (Cámara más lejana) ---
                // Cuando hacemos scroll, la cámara se aleja Z + 15 (state.maxScrollZ)
                // Queremos que el grid cubra la pantalla incluso en ese punto.
                const maxCameraDist = this.cameraBasePos.z + state.maxScrollZ;
                
                // La pared está en Z=0
                const wallDepth = 0; 

                // Usamos una cámara temporal o lógica matemática para saber cuánto ve a esa distancia
                // Distancia efectiva desde la cámara hasta la pared (maxCameraDist - wallDepth)
                const distToWall = Math.abs(maxCameraDist - wallDepth);
                
                // Calculamos dimensiones visibles con FOV
                const vFOV = this.camera.fov * Math.PI / 180;
                const visibleHeight = 2 * Math.tan(vFOV / 2) * distToWall;
                const visibleWidth = visibleHeight * this.camera.aspect;

                // --- 2. Overscan y Dimensionamiento ---
                const overscan = 1.3; // 30% extra para seguridad en parallax y bordes
                const targetWidth = visibleWidth * overscan;
                const targetHeight = visibleHeight * overscan;

                // --- 3. Calcular Tamaño de Celda basado en la Densidad Visual ---
                // Usamos la vista "normal" (sin scroll) para definir qué tan grandes se ven las celdas
                // para respetar el slider 'density' del usuario.
                const baseDist = Math.abs(this.cameraBasePos.z - wallDepth);
                const baseVisibleWidth = (2 * Math.tan(vFOV / 2) * baseDist) * this.camera.aspect;
                
                // Calculamos el tamaño real de la celda basado en cuántas queremos que quepan en la vista BASE
                const desiredColsInView = state.density;
                const cellSize = baseVisibleWidth / desiredColsInView; // Tamaño físico en unidades de mundo
                
                // --- 4. Calcular columnas y filas reales para cubrir el Target Width ---
                const cols = Math.ceil(targetWidth / cellSize);
                
                // Ajuste para hexágonos (altura de fila es menor)
                const isHex = state.shape === 'hexagon';
                const rowHeight = isHex ? cellSize * 0.866 : cellSize;
                const rows = Math.ceil(targetHeight / rowHeight);

                // Configuración de Geometría (Igual que antes pero usando cellSize derivado)
                let geometry;
                // Escalamos la geometría relativa al cellSize
                const s = cellSize * (1 - state.gap); // size minus gap
                const t = s * 0.2; // thickness proportional

                switch (state.shape) {
                    case 'square': 
                        geometry = new THREE.BoxGeometry(s, s, t); 
                        break;
                    case 'circle': 
                        geometry = new THREE.CylinderGeometry(s/2, s/2, t, 32); 
                        break;
                    case 'triangle': 
                        geometry = new THREE.CylinderGeometry(s/1.7, s/1.7, t, 3); 
                        break;
                    case 'hexagon': 
                    default: 
                        geometry = new THREE.CylinderGeometry(s/2, s/2, t, 6); 
                        break;
                }

                if (state.shape !== 'square') {
                    geometry.rotateX(Math.PI / 2); 
                    if (state.shape === 'triangle') geometry.rotateZ(Math.PI / 6);
                    if (state.shape === 'hexagon') geometry.rotateZ(Math.PI / 2);
                }

                const material = new THREE.MeshStandardMaterial({
                    color: state.baseColor,
                    roughness: 0.15, // Reducido para superficie más reflectante y pulida
                    metalness: 0.85, // Aumentado significativamente para efecto metálico
                    flatShading: state.shape === 'triangle' || state.shape === 'hexagon',
                    envMapIntensity: 1.2 // Intensidad del reflejo ambiental
                });

                const count = cols * rows;
                this.gridMesh = new THREE.InstancedMesh(geometry, material, count);
                this.gridMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                
                this.instances = [];
                let index = 0;
                const hexOffset = cellSize * 0.5;

                // --- 5. Generación centrada en (0,0) ---
                // Calculamos el punto de inicio para que el grid quede centrado
                // Total width coverage
                const gridPhysWidth = cols * cellSize;
                const gridPhysHeight = rows * rowHeight;

                const startX = -gridPhysWidth / 2 + cellSize / 2;
                const startY = -gridPhysHeight / 2 + rowHeight / 2;

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        let x = startX + (col * cellSize);
                        let y = startY + (row * rowHeight);

                        if (isHex && row % 2 !== 0) {
                            x += hexOffset;
                        }

                        this.dummy.position.set(x, y, 0);
                        this.dummy.updateMatrix();
                        this.gridMesh.setMatrixAt(index, this.dummy.matrix);
                        this.gridMesh.setColorAt(index, state.baseColor);

                        // Sistema de activación aleatoria para cada elemento
                        const activationPhase = Math.random() * Math.PI * 2; // Fase inicial aleatoria (0-2π)
                        const activationSpeed = 0.4 + Math.random() * 0.6; // Velocidad de activación (0.4-1.0) - más rápido
                        const activationStrength = 0.6 + Math.random() * 0.8; // Fuerza de elevación (0.6-1.4) - más visible
                        const activationDuration = 2.0 + Math.random() * 3.0; // Duración del ciclo (2.0-5.0 seg)
                        
                        this.instances.push({
                            id: index,
                            x: x,
                            y: y,
                            phase: Math.sqrt(x*x + y*y) * 0.5,
                            // Propiedades para sistema de activación aleatoria
                            activationPhase: activationPhase,
                            activationSpeed: activationSpeed,
                            activationStrength: activationStrength,
                            activationDuration: activationDuration,
                            baseElevation: (Math.random() - 0.5) * 0.15 // Elevación base aleatoria sutil
                        });

                        index++;
                    }
                }

                this.scene.add(this.gridMesh);
                
                // Crear aura/energía debajo de cada elemento
                this.createAura();
            }
            
            createAura() {
                // Eliminar aura anterior si existe
                if (this.auraMesh) {
                    this.scene.remove(this.auraMesh);
                    this.auraMesh.geometry.dispose();
                    this.auraMesh.material.dispose();
                }
                
                // Crear geometría de cono para el aura (emana hacia abajo)
                const auraHeight = 0.8; // Altura del aura
                const auraTopRadius = 0.15; // Radio superior (más pequeño, cerca del elemento)
                const auraBottomRadius = 0.4; // Radio inferior (más grande, se expande hacia abajo)
                const auraSegments = 16; // Segmentos para suavidad
                
                const auraGeometry = new THREE.ConeGeometry(
                    auraBottomRadius, 
                    auraHeight, 
                    auraSegments
                );
                
                // Rotar el cono para que apunte hacia abajo
                auraGeometry.rotateX(Math.PI);
                
                // Material emisivo con el color del preset
                const auraMaterial = new THREE.MeshStandardMaterial({
                    color: state.activeColor,
                    emissive: state.activeColor,
                    emissiveIntensity: 1.5,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide,
                    roughness: 0.1,
                    metalness: 0.3
                });
                
                const count = this.instances.length;
                this.auraMesh = new THREE.InstancedMesh(auraGeometry, auraMaterial, count);
                this.auraMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                
                // Inicializar posiciones del aura
                for (let i = 0; i < this.instances.length; i++) {
                    const d = this.instances[i];
                    // Posicionar el aura debajo del elemento
                    this.dummy.position.set(d.x, d.y, -auraHeight * 0.5);
                    this.dummy.rotation.set(0, 0, 0);
                    this.dummy.scale.set(1, 1, 1);
                    this.dummy.updateMatrix();
                    this.auraMesh.setMatrixAt(i, this.dummy.matrix);
                }
                
                this.scene.add(this.auraMesh);
            }
            
            /**
             * Cursor personalizado con diseño único de energía
             * Diseño: Núcleo central + anillos rotantes + partículas orbitantes + rayos de energía
             */
            createCustomCursor() {
                // Eliminar cursor anterior si existe
                if (this.cursorGroup) {
                    this.scene.remove(this.cursorGroup);
                    if (this.cursorCore) this.cursorCore.geometry.dispose();
                    if (this.cursorRings) {
                        this.cursorRings.forEach(ring => ring.geometry.dispose());
                    }
                    if (this.cursorParticles) this.cursorParticles.geometry.dispose();
                    if (this.cursorEnergyBeams) {
                        this.cursorEnergyBeams.forEach(beam => beam.geometry.dispose());
                    }
                }
                
                // Crear grupo para el cursor
                this.cursorGroup = new THREE.Group();
                
                // 1. NÚCLEO CENTRAL - Octaedro brillante de energía (tamaño de cursor normal)
                const coreGeometry = new THREE.OctahedronGeometry(0.04, 0);
                const coreMaterial = new THREE.MeshStandardMaterial({
                    color: state.activeColor,
                    emissive: state.activeColor,
                    emissiveIntensity: 2.5,
                    transparent: true,
                    opacity: 0.95,
                    metalness: 0.9,
                    roughness: 0.05,
                    depthTest: false, // Siempre visible por encima
                    depthWrite: false
                });
                this.cursorCore = new THREE.Mesh(coreGeometry, coreMaterial);
                this.cursorGroup.add(this.cursorCore);
                
                // 2. ANILLOS DE ENERGÍA - 4 anillos que rotan en diferentes ejes (tamaño reducido)
                this.cursorRings = [];
                const ringCount = 4;
                for (let i = 0; i < ringCount; i++) {
                    const ringRadius = 0.07 + i * 0.03;
                    const ringThickness = 0.005;
                    const ringGeometry = new THREE.TorusGeometry(ringRadius, ringThickness, 8, 32);
                    const ringMaterial = new THREE.MeshStandardMaterial({
                        color: state.activeColor,
                        emissive: state.activeColor,
                        emissiveIntensity: 1.8,
                        transparent: true,
                        opacity: 0.8 - i * 0.15,
                        metalness: 0.85,
                        roughness: 0.1,
                        depthTest: false, // Siempre visible por encima
                        depthWrite: false
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    
                    // Rotar cada anillo en un eje diferente
                    if (i === 0) ring.rotation.x = Math.PI / 2;
                    else if (i === 1) ring.rotation.y = Math.PI / 2;
                    else if (i === 2) ring.rotation.z = Math.PI / 2;
                    else {
                        // Cuarto anillo en diagonal
                        ring.rotation.x = Math.PI / 4;
                        ring.rotation.y = Math.PI / 4;
                    }
                    
                    this.cursorRings.push(ring);
                    this.cursorGroup.add(ring);
                }
                
                // 3. RAYOS DE ENERGÍA - 6 rayos que emanan del núcleo (tamaño reducido)
                this.cursorEnergyBeams = [];
                const beamCount = 6;
                for (let i = 0; i < beamCount; i++) {
                    const beamGeometry = new THREE.CylinderGeometry(0.003, 0.01, 0.12, 8);
                    const beamMaterial = new THREE.MeshStandardMaterial({
                        color: state.activeColor,
                        emissive: state.activeColor,
                        emissiveIntensity: 2.0,
                        transparent: true,
                        opacity: 0.7,
                        metalness: 0.8,
                        roughness: 0.2,
                        depthTest: false, // Siempre visible por encima
                        depthWrite: false
                    });
                    const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                    
                    // Posicionar rayos alrededor del núcleo (tamaño reducido)
                    const angle = (i / beamCount) * Math.PI * 2;
                    const radius = 0.05;
                    beam.position.x = Math.cos(angle) * radius;
                    beam.position.y = Math.sin(angle) * radius;
                    beam.rotation.z = angle + Math.PI / 2;
                    beam.rotation.x = Math.PI / 2;
                    
                    this.cursorEnergyBeams.push(beam);
                    this.cursorGroup.add(beam);
                }
                
                // 4. PARTÍCULAS ORBITANTES - Partículas pequeñas que orbitan alrededor (tamaño reducido)
                const particleCount = 16; // Reducido de 24 a 16
                const particleGeometry = new THREE.BufferGeometry();
                const particlePositions = new Float32Array(particleCount * 3);
                const particleColors = new Float32Array(particleCount * 3);
                const particleSizes = new Float32Array(particleCount);
                const particleAngles = new Float32Array(particleCount);
                const particleRadii = new Float32Array(particleCount);
                const particleHeights = new Float32Array(particleCount);
                
                const activeColor = state.activeColor;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const radius = 0.12 + Math.random() * 0.05; // Reducido de 0.35-0.5 a 0.12-0.17
                    const height = (Math.random() - 0.5) * 0.15; // Reducido de 0.4 a 0.15
                    
                    particlePositions[i * 3] = Math.cos(angle) * radius;
                    particlePositions[i * 3 + 1] = height;
                    particlePositions[i * 3 + 2] = Math.sin(angle) * radius;
                    
                    particleColors[i * 3] = activeColor.r;
                    particleColors[i * 3 + 1] = activeColor.g;
                    particleColors[i * 3 + 2] = activeColor.b;
                    
                    particleSizes[i] = 0.02 + Math.random() * 0.03; // Reducido de 0.06-0.14 a 0.02-0.05
                    particleAngles[i] = angle;
                    particleRadii[i] = radius;
                    particleHeights[i] = height;
                }
                
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
                particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
                particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
                
                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.05, // Reducido de 0.15 a 0.05
                    transparent: true,
                    opacity: 0.95,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    depthTest: false, // Siempre visible por encima
                    depthWrite: false,
                    sizeAttenuation: true
                });
                
                this.cursorParticles = new THREE.Points(particleGeometry, particleMaterial);
                this.cursorGroup.add(this.cursorParticles);
                
                // Guardar datos para animación
                this.cursorParticleAngles = particleAngles;
                this.cursorParticleRadii = particleRadii;
                this.cursorParticleHeights = particleHeights;
                
                // Asegurar que el cursor se renderice por encima de todo
                this.cursorGroup.renderOrder = 999;
                if (this.cursorCore) this.cursorCore.renderOrder = 999;
                if (this.cursorRings) {
                    this.cursorRings.forEach(ring => ring.renderOrder = 999);
                }
                if (this.cursorEnergyBeams) {
                    this.cursorEnergyBeams.forEach(beam => beam.renderOrder = 999);
                }
                if (this.cursorParticles) this.cursorParticles.renderOrder = 999;
                
                // Añadir al escenario
                this.scene.add(this.cursorGroup);
            }
            
            /**
             * Actualizar cursor personalizado - animaciones y posicionamiento
             */
            updateCustomCursor() {
                if (!this.cursorGroup) return;
                
                // Proyectar el mouse en un plano cercano a la cámara para que esté por encima de todo
                // Crear un plano a una distancia cómoda de la cámara (9.5 unidades antes de la cámara)
                const cursorPlaneZ = this.camera.position.z - 9.5;
                const cursorPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -cursorPlaneZ);
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersection = new THREE.Vector3();
                this.raycaster.ray.intersectPlane(cursorPlane, intersection);
                
                if (intersection) {
                    this.cursorPosition.copy(intersection);
                    // Asegurar que esté en el plano correcto
                    this.cursorPosition.z = cursorPlaneZ;
                    
                    // Posicionar el grupo del cursor
                    this.cursorGroup.position.copy(this.cursorPosition);
                    
                    const time = this.clock.getElapsedTime();
                    
                    // 1. Animar núcleo (pulso y rotación)
                    if (this.cursorCore) {
                        const pulse = 1 + Math.sin(time * 4) * 0.25;
                        this.cursorCore.scale.set(pulse, pulse, pulse);
                        this.cursorCore.rotation.x = time * 2;
                        this.cursorCore.rotation.y = time * 1.5;
                        this.cursorCore.rotation.z = time * 1;
                    }
                    
                    // 2. Animar anillos (rotación independiente)
                    if (this.cursorRings) {
                        this.cursorRings.forEach((ring, i) => {
                            const speed = 0.8 + i * 0.4;
                            if (i === 0) ring.rotation.z = time * speed;
                            else if (i === 1) ring.rotation.x = time * speed;
                            else if (i === 2) ring.rotation.y = time * speed;
                            else {
                                ring.rotation.x = time * speed * 0.7;
                                ring.rotation.y = time * speed * 0.9;
                            }
                        });
                    }
                    
                    // 3. Animar rayos de energía (pulso y rotación)
                    if (this.cursorEnergyBeams) {
                        this.cursorEnergyBeams.forEach((beam, i) => {
                            const pulse = 1 + Math.sin(time * 3 + i) * 0.3;
                            beam.scale.set(1, pulse, 1);
                            beam.rotation.z += 0.01;
                        });
                    }
                    
                    // 4. Animar partículas (órbita compleja)
                    if (this.cursorParticles && this.cursorParticles.geometry) {
                        const positions = this.cursorParticles.geometry.attributes.position;
                        const colors = this.cursorParticles.geometry.attributes.color;
                        const sizes = this.cursorParticles.geometry.attributes.size;
                        const activeColor = state.activeColor;
                        
                        for (let i = 0; i < positions.count; i++) {
                            // Órbita en múltiples planos
                            const angle = this.cursorParticleAngles[i] + time * (1.2 + i * 0.05);
                            const radius = this.cursorParticleRadii[i];
                            const height = this.cursorParticleHeights[i] + Math.sin(time * 2 + i) * 0.15;
                            
                            // Órbita elíptica con variación
                            const x = Math.cos(angle) * radius;
                            const y = height;
                            const z = Math.sin(angle) * radius * (0.8 + Math.sin(time + i) * 0.2);
                            
                            positions.setXYZ(i, x, y, z);
                            
                            // Color pulsante
                            const colorIntensity = 0.7 + Math.sin(time * 5 + i * 0.3) * 0.3;
                            colors.setXYZ(
                                i,
                                activeColor.r * colorIntensity,
                                activeColor.g * colorIntensity,
                                activeColor.b * colorIntensity
                            );
                            
                            // Tamaño pulsante
                            const sizeVariation = 0.7 + Math.sin(time * 4 + i) * 0.5;
                            sizes.setX(i, (0.06 + Math.random() * 0.08) * sizeVariation);
                        }
                        
                        positions.needsUpdate = true;
                        colors.needsUpdate = true;
                        sizes.needsUpdate = true;
                    }
                }
            }
            
            /**
             * Watermark oculto de propiedad intelectual
             * © 2025 Jarma - Visible solo con inspección especial
             */
            createHiddenWatermark() {
                // Crear un sprite de texto invisible (muy opaco) como marca de agua
                // Solo visible si se inspecciona el código o se ajusta la opacidad
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 64;
                
                context.fillStyle = 'rgba(0, 243, 255, 0.02)'; // Casi invisible
                context.font = 'bold 24px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText('© 2025 Jarma - Propiedad Intelectual', canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                const spriteMaterial = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0.01, // Prácticamente invisible
                    depthTest: false,
                    depthWrite: false
                });
                
                this.watermarkText = new THREE.Sprite(spriteMaterial);
                this.watermarkText.scale.set(8, 1, 1);
                this.watermarkText.position.set(0, -4, 0); // Posición en la parte inferior
                this.watermarkText.renderOrder = 1000; // Siempre visible
                this.scene.add(this.watermarkText);
                
                // Guardar referencia para poder acceder desde consola
                window.__WATERMARK__ = {
                    sprite: this.watermarkText,
                    show: () => {
                        this.watermarkText.material.opacity = 0.8;
                        console.log('%c🔍 Watermark visible - © 2025 Jarma', 'color: #00f3ff; font-weight: bold;');
                    },
                    hide: () => {
                        this.watermarkText.material.opacity = 0.01;
                    },
                    toggle: () => {
                        this.watermarkText.material.opacity = this.watermarkText.material.opacity > 0.5 ? 0.01 : 0.8;
                    }
                };
            }
            
            updateGridColors() {
                if(!this.gridMesh) return;
                for(let i=0; i<this.instances.length; i++) {
                     this.gridMesh.setColorAt(i, state.baseColor);
                }
                if(this.gridMesh.instanceColor) this.gridMesh.instanceColor.needsUpdate = true;
            }

            animate() {
                requestAnimationFrame(this.animate);
                
                const time = this.clock.getElapsedTime() * (state.speed * 0.5);
                
                this.mouse.lerp(this.targetMouse, 0.08);

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersection = new THREE.Vector3();
                this.raycaster.ray.intersectPlane(this.plane, intersection);
                
                if (intersection) {
                    this.cursorLight.position.x = intersection.x;
                    this.cursorLight.position.y = intersection.y;
                    this.cursorLight.position.z = 2; 
                }

                const parallaxX = this.mouse.x * 2;
                const parallaxY = this.mouse.y * 2;
                
                // Scroll aleja la cámara en Z
                const scrollZ = state.scrollProgress * state.maxScrollZ; 
                
                this.camera.position.x = THREE.MathUtils.lerp(this.camera.position.x, this.cameraBasePos.x + parallaxX, 0.05);
                this.camera.position.y = THREE.MathUtils.lerp(this.camera.position.y, this.cameraBasePos.y + parallaxY, 0.05);
                this.camera.position.z = THREE.MathUtils.lerp(this.camera.position.z, this.cameraBasePos.z + scrollZ, 0.05);
                
                this.camera.lookAt(0, 0, 0);

                if (this.gridMesh) {
                    const cursorX = intersection ? intersection.x : 9999;
                    const cursorY = intersection ? intersection.y : 9999;

                    for (let i = 0; i < this.instances.length; i++) {
                        const d = this.instances[i];
                        
                        // Ondas base (movimiento suave de fondo) - reducido para que la elevación aleatoria sea más visible
                        const wave1 = Math.sin(d.x * 0.3 + time) * Math.cos(d.y * 0.3 + time * 0.8) * 0.15;
                        const wave2 = Math.sin(d.x * 0.8 - time * 1.5) * 0.05;
                        let waveZ = wave1 + wave2;

                        // SISTEMA DE ACTIVACIÓN ALEATORIA CONECTADO - ELEVACIÓN Y BAJADA AUTOMÁTICA
                        // Cada elemento tiene su propio ciclo de activación que sube y baja continuamente
                        const activationTime = (time * d.activationSpeed) + d.activationPhase;
                        
                        // Usar seno para movimiento suave de subida y bajada (va de -1 a 1, luego a -1)
                        const sineWave = Math.sin(activationTime);
                        // Convertir a rango 0-1 para elevación positiva
                        const normalizedWave = (sineWave + 1) * 0.5; // 0 a 1
                        
                        // Función de pulso suave (ease-in-out) para transición más natural
                        const pulse = normalizedWave < 0.5 
                            ? 2 * normalizedWave * normalizedWave 
                            : 1 - Math.pow(-2 * normalizedWave + 2, 2) / 2;
                        
                        // Elevación aleatoria individual - más pronunciada
                        const randomElevation = pulse * d.activationStrength * 1.2; // Aumentado de 0.8 a 1.2
                        
                        // SISTEMA CONECTADO: Influencia de elementos cercanos
                        let neighborInfluence = 0;
                        const influenceRadius = 3.0; // Radio de influencia aumentado
                        const maxNeighbors = 12; // Más vecinos para efecto más conectado
                        let neighborCount = 0;
                        
                        for (let j = 0; j < this.instances.length && neighborCount < maxNeighbors; j++) {
                            if (i === j) continue;
                            
                            const other = this.instances[j];
                            const dx2 = d.x - other.x;
                            const dy2 = d.y - other.y;
                            const dist2 = Math.sqrt(dx2*dx2 + dy2*dy2);
                            
                            if (dist2 < influenceRadius) {
                                neighborCount++;
                                // El elemento vecino también tiene su ciclo de activación
                                const otherActivationTime = (time * other.activationSpeed) + other.activationPhase;
                                const otherSineWave = Math.sin(otherActivationTime);
                                const otherNormalized = (otherSineWave + 1) * 0.5;
                                const otherPulse = otherNormalized < 0.5 
                                    ? 2 * otherNormalized * otherNormalized 
                                    : 1 - Math.pow(-2 * otherNormalized + 2, 2) / 2;
                                
                                // Influencia inversamente proporcional a la distancia - más fuerte
                                const distanceFactor = 1 - (dist2 / influenceRadius);
                                const influence = distanceFactor * distanceFactor * otherPulse * 0.5; // Aumentado de 0.3 a 0.5
                                neighborInfluence += influence;
                            }
                        }
                        
                        // Combinar elevación propia + influencia de vecinos
                        const totalElevation = randomElevation + neighborInfluence;
                        waveZ += totalElevation;

                        // Efecto del mouse (hover)
                        const dx = d.x - cursorX;
                        const dy = d.y - cursorY;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        let hover = 0;
                        if (dist < state.mouseEffectRadius) {
                            hover = 1 - (dist / state.mouseEffectRadius);
                            hover = hover * hover; 
                        }

                        // Elevación final = onda base + elevación aleatoria + hover del mouse
                        const z = waveZ + d.baseElevation + (hover * state.mouseEffectStrength);
                        
                        // Escala aumenta más cuando está elevado para efecto más visible
                        const scale = 1 + (hover * 0.4) + (totalElevation * 0.25); // Aumentado de 0.15 a 0.25

                        this.dummy.position.set(d.x, d.y, z);
                        
                        // Rotación solo por hover del mouse (sin rotación circular automática)
                        const rotX = hover * (dy * 0.2); // Solo rotación por hover, sin rotación por elevación
                        const rotY = hover * (-dx * 0.2);
                        
                        // Sin rotación en Z (eliminada la rotación circular)
                        this.dummy.rotation.set(rotX, rotY, 0);
                        this.dummy.scale.set(scale, scale, scale);
                        
                        this.dummy.updateMatrix();
                        this.gridMesh.setMatrixAt(i, this.dummy.matrix);

                        // Color: más brillante cuando está elevado - efecto más pronunciado
                        this.colorA.copy(state.baseColor);
                        const colorIntensity = hover * 1.5 + (totalElevation * 1.2); // Aumentado de 0.8 a 1.2
                        this.colorA.lerp(state.activeColor, Math.min(colorIntensity, 1.0));
                        this.gridMesh.setColorAt(i, this.colorA);
                    }
                    
                    this.gridMesh.instanceMatrix.needsUpdate = true;
                    if(this.gridMesh.instanceColor) this.gridMesh.instanceColor.needsUpdate = true;
                    
                    // Actualizar aura/energía debajo de cada elemento
                    if (this.auraMesh) {
                        const auraHeight = 0.8;
                        for (let i = 0; i < this.instances.length; i++) {
                            const d = this.instances[i];
                            
                            // Calcular la elevación del elemento para posicionar el aura
                            const activationTime = (time * d.activationSpeed) + d.activationPhase;
                            const sineWave = Math.sin(activationTime);
                            const normalizedWave = (sineWave + 1) * 0.5;
                            const pulse = normalizedWave < 0.5 
                                ? 2 * normalizedWave * normalizedWave 
                                : 1 - Math.pow(-2 * normalizedWave + 2, 2) / 2;
                            const randomElevation = pulse * d.activationStrength * 1.2;
                            
                            // Influencia de vecinos (simplificada para el aura)
                            let neighborInfluence = 0;
                            const influenceRadius = 3.0;
                            for (let j = 0; j < this.instances.length; j++) {
                                if (i === j) continue;
                                const other = this.instances[j];
                                const dx2 = d.x - other.x;
                                const dy2 = d.y - other.y;
                                const dist2 = Math.sqrt(dx2*dx2 + dy2*dy2);
                                if (dist2 < influenceRadius) {
                                    const otherActivationTime = (time * other.activationSpeed) + other.activationPhase;
                                    const otherSineWave = Math.sin(otherActivationTime);
                                    const otherNormalized = (otherSineWave + 1) * 0.5;
                                    const otherPulse = otherNormalized < 0.5 
                                        ? 2 * otherNormalized * otherNormalized 
                                        : 1 - Math.pow(-2 * otherNormalized + 2, 2) / 2;
                                    const distanceFactor = 1 - (dist2 / influenceRadius);
                                    neighborInfluence += distanceFactor * distanceFactor * otherPulse * 0.3;
                                }
                            }
                            
                            const totalElevation = randomElevation + neighborInfluence;
                            const wave1 = Math.sin(d.x * 0.3 + time) * Math.cos(d.y * 0.3 + time * 0.8) * 0.15;
                            const wave2 = Math.sin(d.x * 0.8 - time * 1.5) * 0.05;
                            const elementZ = wave1 + wave2 + d.baseElevation + totalElevation;
                            
                            // Posicionar el aura debajo del elemento, siguiendo su elevación
                            this.dummy.position.set(d.x, d.y, elementZ - auraHeight * 0.5);
                            this.dummy.rotation.set(0, 0, 0);
                            
                            // Escalar el aura basado en la elevación (más grande cuando está elevado)
                            const auraScale = 1 + (totalElevation * 0.3);
                            this.dummy.scale.set(auraScale, auraScale, auraScale);
                            
                            this.dummy.updateMatrix();
                            this.auraMesh.setMatrixAt(i, this.dummy.matrix);
                        }
                        
                        this.auraMesh.instanceMatrix.needsUpdate = true;
                    }
                }
                
                // Actualizar cursor personalizado
                this.updateCustomCursor();

                this.composer.render();
            }

            addEventListeners() {
                window.addEventListener('resize', this.onResize.bind(this));
                window.addEventListener('mousemove', this.onMouseMove.bind(this));
                window.addEventListener('touchmove', this.onTouchMove.bind(this), { passive: true });
                window.addEventListener('scroll', this.onScroll.bind(this));
            }

            onResize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                
                this.renderer.setSize(width, height);
                this.composer.setSize(width, height);
                
                // MODIFICACIÓN: Regenerar grid al cambiar tamaño de ventana
                // para asegurar que cubra el nuevo aspect ratio
                this.createGrid();
            }

            onMouseMove(e) {
                // Siempre actualizar la posición del mouse para el cursor personalizado
                // incluso cuando está sobre el panel de controles
                this.targetMouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                this.targetMouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            }
            
            onTouchMove(e) {
                if(e.touches.length > 0) {
                    const t = e.touches[0];
                    this.targetMouse.x = (t.clientX / window.innerWidth) * 2 - 1;
                    this.targetMouse.y = -(t.clientY / window.innerHeight) * 2 + 1;
                }
            }

            onScroll() {
                const docHeight = document.documentElement.scrollHeight - window.innerHeight;
                const scroll = window.scrollY;
                state.scrollProgress = Math.min(scroll / (docHeight || 1), 1);
            }
        }

        // Esperar a que el DOM esté completamente cargado
        // © 2025 Jarma - Propiedad Intelectual
        let app;
        
        function initControls() {
            app = new App();
            
            // Mensaje oculto de inicialización
            if (window.console && (window.location.search.includes('debug=true') || window.location.hash === '#signature')) {
                console.log('%c🔐 Código firmado y protegido por derechos de autor', 'color: #ff0066; font-weight: bold;');
                console.log('%c© 2025 Jarma - Todos los derechos reservados', 'color: #ffaa00;');
            }

            /**
             * BINDING UI: Inicialización y conexión de controles del panel
             */
            
            // Sincronizar sliders con el estado inicial
            const densitySlider = document.getElementById('density-slider');
            const speedSlider = document.getElementById('speed-slider');
            
            if (densitySlider) {
                densitySlider.value = state.density;
            }
            
            if (speedSlider) {
                // El slider va de 0-200, state.speed = 1.0 equivale a 100
                speedSlider.value = state.speed * 100;
            }

            // Marcar preset inicial como activo
            document.querySelectorAll('#preset-controls button').forEach(btn => {
                if (btn.dataset.val === state.currentPreset) {
                    btn.classList.add('active');
                }
            });

            // Binding UI: Shape buttons - Cambiar forma de geometría
            document.querySelectorAll('#shape-controls button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    document.querySelectorAll('#shape-controls button').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    state.shape = e.target.dataset.val;
                    app.createGrid();
                });
            });

            // Binding UI: Preset buttons - Cambiar preset de color
            document.querySelectorAll('#preset-controls button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    document.querySelectorAll('#preset-controls button').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    state.currentPreset = e.target.dataset.val;
                    app.applyPreset(e.target.dataset.val);
                });
            });

            // Binding UI: Density slider - Ajustar densidad del grid
            if (densitySlider) {
                densitySlider.addEventListener('input', (e) => {
                    e.stopPropagation();
                    state.density = parseInt(e.target.value);
                    app.createGrid();
                });
                densitySlider.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                });
            }

            // Binding UI: Speed slider - Ajustar velocidad de animación
            if (speedSlider) {
                speedSlider.addEventListener('input', (e) => {
                    e.stopPropagation();
                    state.speed = parseInt(e.target.value) / 100;
                });
                speedSlider.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                });
            }

            // Binding UI: Panel móvil - Expandir/colapsar en pantallas pequeñas
            document.addEventListener('click', (e) => {
                if (window.innerWidth < 768) {
                    const panel = document.getElementById('main-controls');
                    if (!panel) return;
                    
                    // Si el click es en un botón o slider dentro del panel, mantener expandido
                    const isControlClick = e.target.closest('button') || e.target.closest('input[type="range"]');
                    
                    if (panel.contains(e.target)) {
                        // Si es click en controles, mantener expandido
                        if (isControlClick) {
                            panel.classList.add('expanded');
                        }
                        // Si es click en el panel pero no en controles, toggle
                        else if (e.target === panel || e.target.closest('.controls-panel::before')) {
                            panel.classList.toggle('expanded');
                        }
                    } else {
                        // Click fuera del panel, colapsar
                        panel.classList.remove('expanded');
                    }
                }
            });

            // Prevenir que eventos del canvas interfieran con el panel
            const panel = document.getElementById('main-controls');
            if (panel) {
                panel.addEventListener('mousemove', (e) => {
                    e.stopPropagation();
                });
                panel.addEventListener('mouseenter', (e) => {
                    e.stopPropagation();
                });
            }
            
            // Binding UI: Toggle del panel - Mostrar/ocultar panel de controles
            const panelToggle = document.getElementById('panel-toggle');
            if (panelToggle && panel) {
                let isPanelVisible = true;
                
                panelToggle.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isPanelVisible = !isPanelVisible;
                    
                    if (isPanelVisible) {
                        panel.classList.remove('hidden');
                        panelToggle.classList.add('panel-visible');
                    } else {
                        panel.classList.add('hidden');
                        panelToggle.classList.remove('panel-visible');
                    }
                });
                
                // Inicializar estado: panel visible, botón con clase panel-visible
                panelToggle.classList.add('panel-visible');
            }
        }

        // Inicializar cuando el DOM esté listo
        // © 2025 Jarma - Propiedad Intelectual
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initControls);
        } else {
            initControls();
        }
        
        // Watermark oculto en el objeto window (solo accesible desde consola)
        Object.defineProperty(window, '__CODE_SIGNATURE__', {
            value: {
                author: 'Jarma',
                copyright: '© 2025',
                project: 'Advanced WebGL Background - Infinite Wall',
                message: 'Este código es propiedad intelectual. Prohibida su reproducción sin autorización.',
                license: 'Propietario - Todos los derechos reservados',
                contact: 'GitHub: githubpagetest'
            },
            writable: false,
            enumerable: false,
            configurable: false
        });

    </script>
</body>
</html>